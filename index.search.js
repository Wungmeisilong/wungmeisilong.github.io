var relearn_search_index = [
  {
    "breadcrumb": "Maloudown",
    "content": " 1.文章 14.初次安装AD需要做哪些设置？ 13.物联网网络安全论 12.嵌入式系统设计知识点 物联网应用系统设计 10.云端一体化的环境变量问题 9.云端一体化如何查看云函数日志？ 8.速通ArkTS语言 6.github和atomgit的混合使用，哪些是值得注意的？ 5.自定义页面以康奈尔笔记格式输出 4.如何在github上使用高级搜索搜出自己想要的项目？ 文章标题的多样设计 常与问题总结 如何用旧电脑搭建自己的服务器？ 创建hugo静态网站的经历 网站内常用到的模版 网站的目录与子目录创建 2.AndroidStudio AndroidStudio AndroidStudio笔记 2-1.Toolbar工具栏 3.STM32_RFID 4.Esp8266_WiFi 物联网通信技术-小知识 5.CC2530_ZigBee 实验2 IO端口输出实验 6.Arduino 物联网控制-小知识 7.物联网工程 8.51单片机 pretues+kiel5仿真软件配合使用时需要注意的地方 9.操作系统 Linux期末复习 10.微信小程序 基础知识 11.哲学 心经 思想的边界 庄子之道 费尔巴哈提纲 如何理解费尔巴哈提纲的主要含义？ 12.实战项目 贺青工程 志愿活动软件设计与开发 验收问题 毕业设计 电赛 唛盟杯比赛详记 13.计算机组成原理 过年 计算机组成原理-复习 14.电子电路 模拟电子技术基础笔记 15.外语类 英语 16.考试类 教资 小学 18.C++编程语言 15.计算机图形学OpenGL与C++ 14.新标准C加加程序设计 13.从C到C++ 12.其他库的介绍 11.STL库学习之适配器 10.STL库学习之仿函数 9.STL库学习之迭代器与算法 8.STL库学习之容器 7.STL库学习之分配器 6.STL库学习之筑基概要 5.STL库之观其大略 4.C++2.0特性的使用 3.导读 2.组合与继承 1.代码编写规范 19.设计模式（C++） 20.C加加面试 1.网络编程 21.C语言程序设计（含面试） 1.在线题库练习 常用的数学表达\n常用箭头\n常用函数图像公式\n",
    "description": "",
    "tags": null,
    "title": "一、博客文章",
    "uri": "/branch-bundle-1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 14.初次安装AD需要做哪些设置？设置自动保存 打开程序点击系统设置，如下图： 按照下图步骤设置自动保存，每10分钟保存一次（你也可以设置成其他的，但不建议设置太小或太大比如1分\n13.物联网网络安全论物联网主要解决什么问题?- 主要解决物品到物品（T2T）、人到物品（H2T）、人到人（H2H）之间的互联，核心共性技术、网络与信息安全技术、以\n12.嵌入式系统设计知识点基于Cortex-A9微处理器的硬件平台 RISC和CISC RISC是精简指令集计算机，CISC是复杂指令集计算机 RISC（精简指令集计算机，\n物联网应用系统设计物联网结构系统与传统网路系统的区别 前者由三个部分构成 信息物品 自主网络 智能应用 需求分析 基本概念 需求规格说明：开发、测试、质量保证、项目管理以及\n10.云端一体化的环境变量问题参数context 与环境变量有关，不管是系统还是用户自定义的都用这个来获取，获取方式：context.env 先部署云函数到远端，然后在去远端\n9.云端一体化如何查看云函数日志？调用云函数的时候我们总有输入输出结果不符合自己预期的时候，这个时候查看日志很重要！！在云端一体化开发过程中，我们可以通过下面的方式解决这一问\n8.速通ArkTS语言数据类型 练习网址： 条件语句 拓展：for in与for of的使用 for in ：遍历得到数组的角标， for of ：直接得到元素。 函数 使用function关键字声明\n6.github和atomgit的混合使用，哪些是值得注意的？一台电脑如何使用多个远程仓库？ 下载好git，并做好相关的配置 关联github仓库 创建github仓库 克隆仓库到本地 git clone \u003c你的远程仓库U\n5.自定义页面以康奈尔笔记格式输出Cues Cues Notes 创建css文件 在hugo配置中设置 在markdown文档中引用 Summary 标签/提示 ：静态网页，康奈尔笔记，hugo，自定义页面输出格式。 Notes 创建\n4.如何在github上使用高级搜索搜出自己想要的项目？原文章链接 附件\n文章标题的多样设计在标题前面显示图标： +++ menuPre = \"\u003ci class='fab fa-github'\u003e\u003c/i\u003e \" +++添加这个后的效果如下： 附件\n常与问题总结1、使用git commi -m “……“时报错： Your branch is up to date with ‘origin/master‘ 今天在提交项目的时候报了这个错误，在网\n如何用旧电脑搭建自己的服务器？拥有一个属于自己的服务器个人感觉就很赞，我最初是在不买公网IP情况下，用一台电脑做服务器，然后另外一台电脑可以远程访问，部署网站，然后别人可\n创建hugo静态网站的经历附件 一、为什么要创建属于自己博客网站 自从进入大三的学习，自己接触了许多开发板、以及七七八八的软件，个人记忆力又不咋地，平时很容易把重要或者重\n网站内常用到的模版代码分制表 以\u003c tabs title=\"file name\" \u003e，\u003c /tabs \u003e结尾； 然后里面写以% tab title=\"code name\" style=\"info\" color=\"blue \" %，% /tab %结尾 他们都需要用{{}}括起来 ​ 代码 {{\u003c tabs title=\"hello.\" \u003e}}\n网站的目录与子目录创建不论是创建首页页面，还是左边框的选项，归根结底它们都是“目录”，从根上说，你需要创建一个目录然后在目录里面创建一个.md文件来装这个目录或说\n",
    "description": "",
    "tags": null,
    "title": "1.文章",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目",
    "content": " 志愿活动软件设计与开发设计一款可以参加志愿活动的小程序，其制作流程大致如下： 需求分析与规划 确定目标用户群体及其需求：考虑志愿者、活动组织者和管理员等不同角色的功能\n验收问题页面美化验收 1.登录页面 2.首页—将志愿活动和活动时长数据放到轮播图下面 3.我的页面优化了吗？ 4.点击找回密码后，页面颜色不够美\n",
    "description": "",
    "tags": null,
    "title": "贺青工程",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%B4%BA%E9%9D%92%E5%B7%A5%E7%A8%8B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 13.计算机组成原理",
    "content": " ",
    "description": "",
    "tags": null,
    "title": "过年",
    "uri": "/branch-bundle-1/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%87%E5%B9%B4/"
  },
  {
    "breadcrumb": "Maloudown",
    "content": " 9.黑神话悟空之黄风岭序章：灵蕴纪元 天地混沌初开，盘古巨斧挥动，劈开鸿蒙，清者上浮为天，浊者下沉为地，乾坤始定。女娲以泥土仿生灵模样，捏塑出万物之灵，灵蕴由此诞生\n8.桑叶白鸟卷在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主\n职场短篇在昏暗的办公室里，落长轻轻地推开门，他的脚步轻盈得几乎不发出任何声响。他的目光在办公室内扫视了一圈，最终落在了我身上。我依然坐在电脑前，手指\n白唐时间录序章 在这个看似平凡的现代世界中，时间的秘密潜藏于暗处，由几个古老家族和秘密组织共同守护。几世纪以来，他们不断研究揭示时间的奥秘，但也深知滥用\n7.致自福的一封信一 我的朋友你好啊，我已经太久没有写信给你了，兴许是最近看了些书，唤醒了自己写信的欲望，你知道吗？我已经毕业了，从一个大学生一瞬间变成一个步入\n刘丰三郎高考在即，在收到学校放假的通知后，我于第二日乘班车回了家。 在隔壁县读书的我，每次回家都要乘上4-5小时的班车，回家的路上能见到一片又一片的砂\n草屋夫妇第一章 胡冲村被一条蜿蜒曲折的河流环抱着，河水悠悠向东流去，在不远处与几条支流汇聚，形成了一个被称为三岔口的地方。从三岔口向西，沿着泥泞的小路\n君绘语第一章 与君初相识 高中那会儿我老失眠，原因一言难尽。 记得有一次我去吃饭，遇到张君，我们聊闲聊中，谈到了我失眠的事，张君听了说，他们有个朋友以睡\n白唐战绛graph TD; subgraph 主要人物 白唐瑶 --\u003e|女儿| 白正恩 白唐瑶 --\u003e|女儿| 唐淑清 白唐瑶 --\u003e|姐姐| 白唐文 白唐瑶 --\u003e|姐姐| 白唐\n阿牛和阿花的爱情故事牛村与花村仅隔一片红树林，深秋里，满山的红叶铺天盖地，牛村的村尾是个好地方，常聚着城里来的人，就是离阿牛家远了些。 “嘿！ 阿牛。你要老婆不……\n时空国度-木尸王朝第一章 序 火车站往东，沿着才华路步行约十分钟，便能抵达衡岭财经学院。这条路王肖一年会走五六次——多半是回家或返校。每当他踏上这条熟悉的道路，心\n木尸王朝 1.文中的人类变成树木的原因是什么？ 与金钱绑定的一种木材，注定了她会给人类带来财富，当我可以使用金钱来奴役别人时，金钱不再是一般等价\n",
    "description": "",
    "tags": null,
    "title": "二、小  说",
    "uri": "/textbook/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " AndroidStudioAndroidStudio简介 1.配置Android开发环境： 安装JDK： （1）下载JDK （2）配置环境变量； 安装Android Studio\nAndroidStudio笔记第一章 配置开发环境： 1.安装JDK “安装连接” 2.安装AndroidStudio “安装连接”\n2-1.Toolbar工具栏Toolbar是什么？ 简单理解就是页面的上的菜单栏，或者叫工具栏，在AndroidStudio的页面布局中使用Toolbar， menu文件的\n",
    "description": "",
    "tags": null,
    "title": "2.AndroidStudio",
    "uri": "/branch-bundle-1/2.androidstudio/"
  },
  {
    "breadcrumb": "Maloudown",
    "content": "",
    "description": "",
    "tags": null,
    "title": "三、关于",
    "uri": "/about_create_web/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": "Lorem Ipsum.\n",
    "description": "",
    "tags": null,
    "title": "3.STM32_RFID",
    "uri": "/branch-bundle-1/3.stm32_rfid/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 物联网通信技术-小知识通信串口 参照上一节课 物联网是新一代信息技术领域的重要组成部分。其英文名称是“The Internet of things”，顾名思义，“物联网就是物物相连的互联网\n",
    "description": "",
    "tags": null,
    "title": "4.Esp8266_WiFi",
    "uri": "/branch-bundle-1/4.esp8266_wifi/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 实验2 IO端口输出实验实验2 IO端口输出实验 1、实验要求： 利用实验箱的基础板，实现八盏灯的点亮，下面是八盏灯的位置图： 在实际中我们可能没有实验箱，往往需要自己做一\n",
    "description": "",
    "tags": null,
    "title": "5.CC2530_ZigBee",
    "uri": "/branch-bundle-1/5.cc2530_zigbee/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 物联网控制-小知识物联网的特点 物联网是互联网的拓展和延伸，物联网设备通常为带传感器的电子硬件，并与网络相连接。 物联网的应用层是核心。 物联网的作用 全面感知：全面\n",
    "description": "",
    "tags": null,
    "title": "6.Arduino",
    "uri": "/branch-bundle-1/6.arduino/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " ",
    "description": "",
    "tags": null,
    "title": "7.物联网工程",
    "uri": "/branch-bundle-1/7.%E7%89%A9%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " pretues+kiel5仿真软件配合使用时需要注意的地方不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形\n",
    "description": "",
    "tags": null,
    "title": "8.51单片机",
    "uri": "/branch-bundle-1/8.51%E5%8D%95%E7%89%87%E6%9C%BA/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " Linux期末复习认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般\n",
    "description": "",
    "tags": null,
    "title": "9.操作系统",
    "uri": "/branch-bundle-1/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 基础知识附件\n",
    "description": "",
    "tags": null,
    "title": "10.微信小程序",
    "uri": "/branch-bundle-1/10.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 心经波若波多密的意思 波若：彼岸 波多：抵达（渡） 意思是抵达彼岸 波若波多密的方法 布施 财布施：用钱去帮助亲人或他人 法布施：如教师的职业，教授别人知识 无\n思想的边界序言 我前几天看见篇文章说现在的一些科学是建立几句假设之上的，这几句假设就像悬空寺下的几个柱子，撑起了几百年的悬空寺，甚至在以后更长的时间里起\n庄子之道今天通过王德峰老师的视频课来进一步的了解《庄子》的哲学之道，推荐看曹楚基注释的《庄子》。 行无为而知避害，避害就是避开人为，像自然灾害不在道家\n费尔巴哈提纲一 从前的一切唯物主义（包括费尔巴哈的唯物主义）的主要缺点是：对对象、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作感性的人的\n在我个人看来中国的哲学重在修心，探讨入世出世，为人处世的哲学问题，而相比于西方的哲学，我觉得中国的哲学更贴近与生活，人的内心变化影响着人的生活，西方哲学注重探讨自然界的规律。所以我有时也很能理解为什么科技革命发生在西方，而不是我们中国，西方哲学下的社会似乎总能带来一些新东西，有时候会让你感觉到它带来了不属于这个世界的新事物，最典型的就是科技的发展带来的一些新事物。但这样的看法看待中国哲学和西方哲学还是太片面了，在哲学的大集合里，哲学主要还是为人服务的“ 工具 ”，哪个顺手我就用哪一个，哪个能帮我与事物更好的打交道，我就用哪个。\n学哲学是为了了解自己，看透世界，这就是当下我觉得学哲学的意义。\n学中国的哲学不是为了出家，不是为了攀登看破红尘的高山。如果你不是很富有，家境也不怎么样，我劝你打消这个念头，父母辛苦把你养大，你跑去山里去修道？国家现在还没有富起来，你不投身于社会为祖国做贡献，幻想着修自己心中所谓的道？你能安心吗？我想学完中国哲学的人不应该是有这样的想法，而是有与社会权力打交道的巧招妙招，有为家为国做贡献的决心，有好好活下去的勇气。\n",
    "description": "",
    "tags": null,
    "title": "11.哲学",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 贺青工程志愿活动软件设计与开发设计一款可以参加志愿活动的小程序，其制作流程大致如下： 需求分析与规划 确定目标用户群体及其需求：考虑志愿者、活动组织者和\n毕业设计目录 运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 收藏的一些资料 最终的操作结果 ESP32\u0026\u0026\n电赛以下笔记皆基于HAL库。 新建STM32CubeMX工程步骤 创建工程中如果勾选MCO表示向外部输出时钟， 输出的是哪一个引脚可以查看，如下图。 外\n唛盟杯比赛详记比赛说明 自己有幸参加这次唛盟杯的比赛，这次比赛流程如下： 一、报名时2024年1月1到31日本来是12月份但延期了。 二、培训时间，现在还不确定\n",
    "description": "",
    "tags": null,
    "title": "12.实战项目",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 过年\n计算机组成原理-复习1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表 比较内容 电子数字计算机 电子模拟计算机 数据表示方\n",
    "description": "",
    "tags": null,
    "title": "13.计算机组成原理",
    "uri": "/branch-bundle-1/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": "模拟电子技术知识。 模拟电子技术基础笔记常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的 本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4\n",
    "description": "",
    "tags": null,
    "title": "14.电子电路",
    "uri": "/branch-bundle-1/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 英语听力相关 ： Cues 这里是关键词和提示。 Notes 有声书。 视频学习： ted， comedy，stand up. 1.看原文； 2.看中英； 3.看原文； 4.记笔记； 5.关\n",
    "description": "",
    "tags": null,
    "title": "15.外语类",
    "uri": "/branch-bundle-1/15.%E5%A4%96%E8%AF%AD%E7%B1%BB/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 教资 小学科目一： 教育观与职业道德 教育与社会的发展 点击查看流程图 考题 简述教育对生产力的关系（制约作用）？ 教育与人的发展 点击查看流程图 教育制度 理解记住教\n",
    "description": "",
    "tags": null,
    "title": "16.考试类",
    "uri": "/branch-bundle-1/16.%E8%80%83%E8%AF%95%E7%B1%BB/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 15.计算机图形学OpenGL与C++理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL\n14.新标准C加加程序设计内存分区模型 内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理； 一、程序执行前 1.代码区 存放二进\n13.从C到C++指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量 指的是用 ““括\n12.其他库的介绍为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括： 数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从\n11.STL库学习之适配器整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知\n10.STL库学习之仿函数仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了op\n9.STL库学习之迭代器与算法标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代\n8.STL库学习之容器list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）\n7.STL库学习之分配器分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件\n6.STL库学习之筑基概要STL程序源代码位置 了解自身编译器STL程序源代码位置。 OOP 与 GP 面向对象编程（OOP）： 面向对象编程是一种编程范式，它将数据和处理这些数据的方\n5.STL库之观其大略一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数\n4.C++2.0特性的使用VS 2022的设置 首先你可以先用下面的代码测试使用可以执行： #include \u003ciostream\u003e void printTypes() { } template \u003ctypename T, typename... U\u003e void printTypes(const T\u0026 t, const U\u0026... u) { std::cout \u003c\u003c t \u003c\u003c std::endl; printTypes(u...); } int main() { printTypes('a', 1.5, 'b'); }如果报错了，如t\n3.导读书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard libra\n2.组合与继承类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构\n1.代码编写规范如何写一个标准的.h文件 以下内容来自B站。 接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码： class complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const\n",
    "description": "",
    "tags": null,
    "title": "18.C++编程语言",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": "组件协作 模板方法-template method 在C语言代码编写中主函数调用常调用库函数，进行功能实现。那么现在面向对象编程中，可以选择在库中调用未来写在主函数中的函数，这个设计方式就叫template method（个人的理解，不是定义）。举个例子，假设有一个lib.h的库，里面写了画圆的步骤，主体框架已经在rung()中写好，但是还有一个函数没用写，该函数是用来指定圆的半径等参数的，这个函数用virtual修饰，在未来主函数中可以继承该类并重写这个函数，最后在调用lib.h库里的run()即可。\n在这里画圆的框架以及步骤已经规定好，也就是稳定的，而圆的半径是变化，使用以上方法就把稳定与变化分开，这也是设计模式的核心要点之一。例子粗糙但已经能说明该设计模式了\n前一过程称为早绑定，后一过程称为晚绑定。\n策略方法-strategy 如下图是该方法的结构图。 该方法是为了应对未来的需求，这在业务就很常见，在未来会增加业务的功能，主要体现在代码运行时，假设现在有三种算分分别对应三种不同的情况，在运算时需要对不同的算法做不同的处理，以往我们会使用if-else或Switch-case，但是当情况不是三种或未来增加时，后者的代码会变得冗长，也不好维护，现在我们可以把三种情况对应的算法继承一个基类中的virtual修饰的方法，并重写这个方法。在运行处通过上下文调用对应的算法。\n",
    "description": "",
    "tags": null,
    "title": "19.设计模式（C++）",
    "uri": "/branch-bundle-1/19.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 1.网络编程网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用 数据湖结构与算法 附件\n",
    "description": "",
    "tags": null,
    "title": "20.C加加面试",
    "uri": "/branch-bundle-1/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章",
    "content": " 1.在线题库练习网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】\u0026rdq\n",
    "description": "",
    "tags": null,
    "title": "21.C语言程序设计（含面试）",
    "uri": "/branch-bundle-1/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。\nGLFW的主要功能包括：\n创建窗口 定义上下文 处理用户输入 GLAD（） GLAD是一个开源的、跨平台的库，用于管理OpenGL的函数指针。它提供了一种简单的方式来获取OpenGL的函数指针，使得开发OpenGL应用程序变得更加容易。\n相关说明：\nOpenGL本身知识规范/标准 各个厂家具体实现方式可以不同 不同操作系统处理方式也可以不同 主要功能：\n获取OpenGL函数指针 处理OpenGL版本兼容性问题 处理OpenGL扩展函数 …… 如果没有GLAD库，在Windows下：\ntypedef void (*GL_GENBUFFER) (GLsizei,GLuint*);//声明函数指针 GL_GENBUUFFER glGenBuffer = (GL_GENBUFFER)wglGetProcAddress('glGenBuffer');//获取函数指针 unsigned int buffer;//声明缓冲区对象 glGenBuffer(1,\u0026buffer);//调用函数 有了GLAD库，只需要：\nunsigned int buffer; glGenBuffer(1,\u0026buffer); 附件 ",
    "description": "",
    "tags": [
      "C++",
      "计算机图形学",
      "OpenGL"
    ],
    "title": "15.计算机图形学OpenGL与C++",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/15.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6opengl%E4%B8%8Ec%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: C++",
    "uri": "/tags/c\u0026#43;\u0026#43;/"
  },
  {
    "breadcrumb": "Maloudown",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "breadcrumb": "",
    "content": " Search 搜索 欢迎来到我的个人博客网站……\n",
    "description": "",
    "tags": null,
    "title": "Maloudown",
    "uri": "/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: OpenGL",
    "uri": "/tags/opengl/"
  },
  {
    "breadcrumb": "Maloudown",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: 编程语言",
    "uri": "/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 计算机图形学",
    "uri": "/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "序章：灵蕴纪元\n天地混沌初开，盘古巨斧挥动，劈开鸿蒙，清者上浮为天，浊者下沉为地，乾坤始定。女娲以泥土仿生灵模样，捏塑出万物之灵，灵蕴由此诞生，在三界间流淌，似无形的丝线，将世间万物紧密相连。\n这灵蕴，无影无形，却如血液骨髓般，深深融入山川大地。草木得其滋养，开启灵智，生出非凡神韵；鸟兽纳其恩泽，变幻出奇异形貌，拥有超凡力量；凡人修其道法，窥探长生奥秘，踏上超脱凡俗之路。然而，灵蕴并非永恒，每隔一亿两千万年，便会迎来一场湮灭浩劫。即便强大如上古神魔，若无蟠桃续命、金丹固本，也难逃归墟寂灭的命运。因此，三界众生为争夺这通天彻地的关键 “气”，陷入无尽的纷争与混战。\n世间修道者，依据根脚不同，分为神、佛、妖、魔、精、怪六类。神者，承天命而生，掌控天地法则。西王母高坐瑶池，执掌蟠桃盛宴，群仙皆来朝拜；轩辕黄帝运筹帷幄，炼制金丹，统御人族，开创盛世。佛者，斩断因果羁绊，渡化世间苦厄。地藏王菩萨立下宏愿，镇守地狱，誓度尽受苦众生；文殊菩萨挥动智慧之剑，斩断无尽烦恼，引渡迷途之人。妖者，嗜血成性，惑乱人心。九尾狐偷食月华，化作绝世美人，乱殷商宗庙，引发战火纷飞。魔者，执念深重，化为煞气。共工怒撞不周山，引发洪涛吞没八荒，带来无尽灾难。精者，自然通灵，与天地合一。山鬼饮露餐霞，于山林间轻歌曼舞；木魅依附古树，吟唱古老歌谣。怪者，因天地异变而生，拥有奇特神通。相柳九首齐吐毒沼，所到之处生机灭绝；夔牛独足踏地，震动雷霆，声震四野。\n欲踏上成道之路，修者需以灵蕴为根基，修六根清净，渡四灾劫难，夺三途机缘。六根者，眼贪色、耳逐声、鼻嗅香、舌嗜味、身耽欲、意生妄。此六根如蟊贼，悄然潜入，盗取修者灵台清明，使其沉沦于红尘浊气之中。当年神农尝百草，舌根陷入断肠草的甘苦诱惑，幸得白鹿衔茶相救，才得以解毒脱险；黄帝与蚩尤大战，眼根被迷雾中妖影所惑，幸亏风后造指南车，才破解迷局。修行之人的境界深浅，皆从六根清净与否中显现出来。彭祖烹雉羹，延寿八百载，却因贪食龙肝，遭天诛而陨落；广成子传授黄帝《自然经》，目观星河流转而不迷，耳闻天籁纷纭而不惑，六根澄明如镜，灵蕴浩瀚如海，终成一代宗师。\n成道之劫，被称为 “雷蛰碎骨、火焚燎魂、寒冻封窍、毒伤腐脉”。祝融掌控烈焰，焚尽南荒，后羿以寒浞弓射落火鸦，又取北冥玄冰镇压；玄冥降下霜雪，冰封不周山，女娲采扶桑木燃火融冰，化解危机。然而，劫难亦可转化为机缘。大禹疏洪水，铸九鼎，以灾砺心；神农尝百毒，著药经，以劫证道，成就千古传奇。 众生求索长生之路，不外乎三途。一曰夺，以强横手段强取灵蕴，逆天改命。蚩尤吞战魂，炼虎魄刀，共工盗不周山地脉，却因杀戮过重，反遭劫火反噬，身死道消。二曰修，遵循天地法则，徐徐图之，稳步精进。伏羲演八卦，遭天雷轰顶，却借龙马河图引雷入地，终悟阴阳化生之理，开创易经之道。三曰盗，窃取机缘，于险境中求生存。嫦娥窃取西王母不死药，羿射九日夺太阳精魄，虽得长生，却只能付出孤月冷辉相伴的代价，寂寞终老。\n大道至简，却绝非易事。轩辕黄帝乘龙登天之际，曾感慨万千：“灵蕴如川，取一瓢饮易，守万世清流难。”唯有斩断六根贼，渡过四重劫难者，才能于昆仑云海之间，见证那不朽的灵光闪耀，证得长生不老的无上大道。\n第一章\n年轻男子身姿挺拔，一臂甲乌金臂鞲泛着冷光，乌金皂罗袍衣甲裹身，褪甲乌金行缠束腿，站在那，自有一股英气逼人。 他望着四周破败之景，剑眉微蹙，开口问道：\n“此处妖怪横行，怎的清源百姓还在此苦守？何不逃离，免受这无尽惊扰？”\n一旁壮汉闻声，叹息摇头，操着浓重口音回道：\n“好汉有所不知，此地离黄风岭和黄金佛国近得很哩，哪能说走就走。”\n“此间有何说法？”男子上前问道。\n“此间还真有说法！！”壮汉用手微微撑起，舒了口气，这才继续说道：\n“想当年，哈咇国国王年事已高，怕得要命，四处寻长生仙方。有方士献言，说长期服用石英能长生不老。那国王一听， 立马张贴榜文，重金悬赏石英。不少采石人为了赏金，深入黄风岭荒漠。那时候，这还没叫清源，只是个采矿人入山前歇脚的地儿。 采矿人进山后，瞧见山里有石精，那石精脑袋里露着晶莹白矿，正是石英。可采矿人哪是石精对手，只能灰溜溜回来禀告国王。 国王心急，派太子带着军队去开采。军队到这儿，就在这安营扎寨，为保采矿顺利，还修了城墙，这清源城才有了雏形……”\n壮汉说到这，仰头望天，似陷入回忆。他深吸一口气，见男子正认真听着，他接着道：\n“太子带兵入山后，黄风迷道，尘沙蔽日，石精们更是狡猾危险，时常埋伏土中，瞅准机会成群结队窜出来，左右夹击。没多久， 军队就损兵折将，别说采矿，保命都难。”\n说到这壮汉拳头紧握，关节泛白，他接着道：\n“太子无奈，派人送千里急信回都城，哭诉此行凶险，将士们苦不堪言，求国王收回成命。可那国王，一心只想长生，硬是下旨让 军队继续开采……”壮汉说了很多，见一旁的男子不语，正要起身道谢男子，不想男子开口道：“壮士说得这般生动，莫不是亲身经历过这惨事？”\n壮汉苦涩一笑，看那天也还未明朗，示意男子坐下。\n“你若是对此有兴趣，倒也不妨与你说说，”壮汉缓缓道：\n“不瞒你说，昔年在下也在那支军队里头，还是太子前带刀侍卫的徒弟。入山之后，军队对那石精毫无办法，伤亡极为惨重，时刻都有被团团围住、 全军覆没的危险。国王那边又催得十分急切。正当大家一筹莫展的时候，有位姓齐的将军提议去黄风岭的土地庙拜一拜，祈求土地神助军脱局。 太子和几位将军起初都反对，说这法子过于荒唐。可齐将军斩钉截铁的认为可以一试。他原本是斯哈哩国的一名说客，后来游说到了哈咇国， 国王觉得他很有才能便将他招纳麾下，也不知怎的，后来就成了太子麾下的将军。齐将军用了一段往事并立下军令状，又经过一番辩论，大家这才信服。 可紧接着问题也来了，谁去土地庙哩？当时咱们在黄风岭沙门村附近，去土地庙虽算不上远，但黄风迷道，妖怪横行，石精挡道，路也确不好走。”\n男子听罢，眉头微拧，等着壮汉继续。\n“后来齐将军自荐，自己提议自己前往土地庙。”壮汉喝了口水，接着道：“许是老天可怜，齐将军去后一日，土地神竟托梦于太子，告知其脱困之法。 不过那法子只有太子和几位将军知晓。我和师傅那夜只是守在太子帐外，一炷香后，前线传来捷报，说石精已被击败，石英取得可以返程。 夜里，咱们正要动身，师傅发现齐将军自去沙门村后就没了踪影。师傅放心不下，护送太子出了黄风岭后，又折返回去寻齐将军。当时太子和师傅还起了争执， ，或是师傅说服了太子，太子后面又同意了。师傅走后，我被安排保护太子回都城。回城后，军队早已九死一生，带着石英返回，随太子出征的大军已伤亡过半。”\n壮汉说到这，眼神黯淡，“那夜，太子借送石英给老国王之机，发动兵变，把抱着长寿秘药的老国王刺死在龙床上。那后我也升迁，暂替师傅成了太子的带刀侍卫。 这二十年来，我一直打听师傅下落，这才来到这住下。清源城陈老太爷富贵且消息灵通，我拜入他府中做了这一带的庄头，替他收租，一边收租一边打探师傅消息。”\n男子听完，道：“壮士为寻师傅不息二十年寻找，实在令人敬佩。”\n庄头摆摆手，“好汉过奖了”\n男子道：“还不知如何称呼？”\n“在下姓赵单字一个铁，不知好汉哪方人士，叫我如何称呼……原来是傲来国人士，哦，孙好汉有礼了，”见男子再次询问黄金佛国之事，赵铁继续道：“黄金佛国？对对对， 再说那黄金佛国，盛产黄金，多少商客眼馋。可如今那地儿鼠妖遍野，去的商客怕是没等寻到黄金，就进了妖怪肚子。不过，有些不怕死的商客，这些年一直住在清源城， 屯兵储粮，就盼着有朝一日去黄金佛国淘金哩。”\n话说那天命人，曾在黑风山救下一猴，那猴子为表谢意，不仅传授泡酒之法，还赠予一瓶椰儿酿。天命人告别黑风山，一路奔着清源城而来。 这一日，夜幕低垂，天命人瞧见一背着背篓、身穿黄衣的道士正在山间采摘草药。天命人本欲悄然离去，却见那道士摘的小灵芝突然从土里钻出， 瞬间化作一只精怪，将道士打倒在地，满地药材散落一地。天命人见状，心生怜悯，使出戳棍之术，远远将那精怪打飞数丈远，那精怪随后化作一缕灰烬， 消散于夜色之中。\n天命人赶忙上前搀扶那道士，却不想，那哪是什么道士，分明是一只生着狗模样、身着道服的妖精。那妖精定睛一看，眼前这人臂甲乌金臂鞲闪烁，身披乌金皂罗袍衣甲， 褪甲乌金行缠束腿，腰间还挂着个葫芦，正是个猴子模样。那妖精暗自欣喜，嘟囔道：“哎呦，只知炼丹不练神功，今日竟栽在这小妖手里，晦气晦气……”\n天命人一时愣在原地，原以为是妖怪要害人，这才出手相救，不想这俩都是妖。这似与救那申猴极为相似，在救下申猴那时他也想，纵使这次是救对了，但是下次会不会救错。\n小时候，天命人也曾问老猴子：“师傅，以后我也当天命人了，下山遇到那些修道者该不该救。”\n“自是要救，但修道者既有善仁者，也有奸恶者。”老猴子说道。\n“我自是救善仁者……”天命人犹豫了会儿，又问道：“师傅，你说这世道是恶人多，还是善人多？”\n“自是善人多。”老猴子答道。\n“那为何这世间从未太平，恶人总是横行无忌。”\n“因为不分好歹的善是恶的帮凶，一霹雳手段，显菩萨心肠，这就是你的天命……”\n天命人谨记教诲，如今又救下了个妖，心中虽五味杂陈，但有些事似乎已渐渐明了。\n那妖精却开口道：“多谢好汉救命之恩。”说着，还咳嗽了几声，似乎很是难受。天命人从腰间取下葫芦，让其饮下，那椰儿酿内含灵蕴，又混有上等的泡酒物， 饮后片刻可恢复如初。那妖精饮罢，眼睛一亮，说道：“此物唯有申猴才能泡出这般味道！”\n“你认识申猴？”天命人好奇问道。\n“何止认识，我们还曾共事过，不过那都是以前的事了…… 不提也罢，不提也罢。” 妖精神色黯然，不愿多说。\n一番询问后，天命人才得知，这原来是六丁六甲之一的戌狗，与申猴同是天上神仙，曾一同被遣护送取经团队。戌狗为表感谢，赠予天命人化形丹和腰牌， 天命人知这与申猴路数如出一辙，便收下。临别前，戌狗还告诫天命人，善用化形丹，善用腰牌到道观好生习炼丹之术，以备后用。\n天命人暗自记下，继续赶路，离清源城越来越近，四周村镇也多了起来。天命人用了化形丹，化作人形，继续前行。走着走着，听见左边传来乒乒乓乓的打斗声， 只见一个农夫正持着大刀与一只蝙蝠精打得难解难分，一时间难分上下。天命人见那确是个农夫壮汉正遭只妖精扑来飞去，妖精嘴里嘟囔道要吃人哩， 好说要是也学了大圣的火眼金睛定也不必这么麻烦，天命人左右观之稍许，也是识得了哪是妖哪是人，便上前助拳。农夫见天命人出手，便退到一旁。 天命人不知从哪抽出一根兽棍，重重砸向蝙蝠精。那精一跃而上，得意地盘旋于空中。天命人正要一个立棍将其拿下，农夫喊道：“好汉，接刀斩它翅膀！” 说话间，那精侧身欲躲，不想天命人跃起一个横刀，那精的头便飞了出去。\n天命人正要扶那农夫，农夫却示意不用。\n临近城镇妖怪如此猖獗，天命人不忍问问了农夫，不想农夫却与之谈起了一段往事。\n农夫便是那赵铁，赵铁说完黄风岭与那黄金佛国的故事后，见那天命人在一旁嘀咕着什么，猴模猴样的，他又看了看即白的东方，\n“孙好汉！”赵三起身对天命人说道：“多谢刚才帮我杀了只疾蝠，若没有你我恐遭那精怪毒手。与你交谈也好事快活，你这朋友我认定了，以后若有机会定与你把酒言欢， 介时可到陈府找我。咋们就此别过！”\n天命人作别庄头后，便往城中而去。庄头见目送其天命人后，收拾好疾蝠尸首，往村庄去，走到村民腾出的大屋，庄头将疾蝠尸首丢在门前，径直往屋里去。\n这年秋收后，赵铁来村中收租。村民把村头那栋空置许久的大屋收拾出来，腾给赵铁暂住，并为他置办了丰盛的筵席，洗尘接风。酒足饭饱后，村长对赵铁坦言道：\n“田租实在太高了，能不能减少一些。”\n赵铁道：“田租是你们与主家定的，我既拿了月俸，只管来向你们要债。你与我商量此事，我也没有办法呀。”\n大家争来吵去，谈不出个结果，眼看天色渐晚，便都草草告辞。走在最后的老鳏夫对农夫道：\n“小村鄙陋，没什么好消遣的地方，倒是后山亭，是个赏月的好去处。农夫若是烦闷，可以去那处散散心。”\n言罢，这才告辞离去。于是昨夜赵铁挑灯正要去后亭赏月，不想遇到了两只妖精。\n次日，村民来大屋给庄头准备饭食，却见他坐在门前，腿旁的地上插着柄大刀，刀下钉着两具没有脑袋的蝠尸。一人上前作揖，问道：\n“这……这是……”\n庄头瞅了瞅那人，又恶狠狠地看了那疾蝠，说道：“昨晚山后亭砍杀的，山后亭可谓景色宜人啊！”\n说者无意，听者有心，其后几日，村民们缴齐了足额的田租，又置办了丰厚的酒席，恭敬地送庄头回城里去了。\n天命人在戌狗的指引下，带着腰牌去了清虚道观。也不知为何，道士自见到腰牌起，就很敬重天命人，还给他安排了住处。听天命人说想学些炼丹之术，那些道士便忙前， 忙后的帮着找丹书，传炼丹之法，负责此事的是观主的大弟子和三弟子，大弟子唤清空，三弟子唤明净。\n几日后，陈府派人来请求道士们去府上除妖，说府上派出去的仆人无缘无故失踪。道士们自是不愿意去，因为上一次因为摊上陈府事的师兄已经被丹炉炸死了， 道士们便相互推脱。天命人在房内看着丹书，听到有人吵闹，便循声出门看看，见他们在议论被丹炉炸死的道士，他这才想起戌狗之前对他说过的一段往事。\n那夜戌狗示意天命人一旁坐下，似有事想告，他说道。\n“清虚巷东头的小道观里，住着个道士。他自称得了海上仙方，是个妙手回春的道医。我盘算着在凡间学些凡人手段，于是便跟随了他，毕竟我也是个喜炼丹之术。 道士的丹药，生病的人吃了，不见大好，没病的人吃了，只如寻常，不曾出过什么差错。若有人来问，他便道：“世上哪有什么起死回生灵丹妙药， 只有体内的精、气、神调和舒畅，才是真的身体康泰。”大家都认为这道士不甚厉害，所以门庭冷落，求医者极少。\n城中有个陈老太爷，富比王侯，如今花甲之年，染了重疾，显出下世的光景来。他的儿子寻至观中，请道士去给老太爷治病。道士为老太爷特制了许多丹药， 府中人虽觉得道士不过胡来应付，却也不敢多言，只敢在旁瞧个热闹，岂料，老太爷自服了那些药丸，渐渐竟能进些饮食，气也顺畅了，似有痊愈之兆。 偏巧，道士某次炼丹，炉子却炸了开来，连带着他一起送了命。这世道，有大才，反到是烧身之难哟！”\n看见来访的是陈府的人，天命人便上前自荐自己去除妖。众人将信将疑，说话间一人从人群中走来，来的是前几天遇到的庄头，庄头向众人讲述了那晚的天命人的事迹， 陈府上下知道庄头的身份以及他的厉害，自然无人怀疑，道士们见说话的是陈府的人，便与之商量，收了一袋银钱后，天命人这才同陈府的人去府上。\n",
    "description": "",
    "tags": null,
    "title": "9.黑神话悟空之黄风岭",
    "uri": "/textbook/9.%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E4%B9%8B%E9%BB%84%E9%A3%8E%E5%B2%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 21.C语言程序设计（含面试）",
    "content": "网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】” “LeetCode【较难】” 课程学习 “书籍” “大学慕课” Github项目 “C/C++面试总结项目” “书籍：Github项目” “C/C++面试总结” “系统设计” 题目笔记 1.cahr *s = \"AAAA\"指针接受一个字符串（右值），当想通过s[0] = ‘B’修改时是无法修改成功的，因为\"AAAA\"只能读，不能写。 2.一般函数内如果返回char s[] = {“abcd”};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。 3.在自动类型转换中：\nunsiged int a = 9; int b = 1; printf(\"%d\", b+a);此处会触发隐式转换——int类型转为uniged int 类型。\n4.大端模式和小端模式的作用是什么，为什么会出现这两种模式？\n作用： **大端模式：**在这种模式下，数据的高字节（最重要的字节）保存在内存的低地址处，而数据的低字节（最不重要的字节）保存在内存的高地址处。这种方式类似于人类读写数值的习惯，即从高位到低位 。 **小端模式：**在这种模式下，数据的低字节保存在内存的低地址处，而数据的高字节保存在内存的高地址处。这种方式在进行数据类型转换时不需要调整字节内容，直接截取低字节即可\n测试代码：\n#include \u003cstdio.h\u003e int main(){ int i; union test{ unsigned int n; char arr[4]; }; union test num; num.n = 0x12345678;//注意:12所在位置是高位 for(i = 0; i\u003c4; i++){ printf(\"\u0026arr[%d] = %p, arr[%d] = %#x\\n\",i,\u0026num.arr[i],i,num.arr[i]); } return 0; } /* 代码解释： 代码中，%x表示输出16进制，x前加 # 标志表示，如果使用 %ox（八进制）， 则输出的数前面会加上前缀 0；如果使用 %#x 或 %#X（十六进制）， 则输出的数前面会加上前缀 0x 或 0X。这样做可以明确地表示数值的进制， 便于阅读和理解。 结果： \u0026arr[0] = 000000000062FE10, arr[0] = 0x78 \u0026arr[1] = 000000000062FE11, arr[1] = 0x56 \u0026arr[2] = 000000000062FE12, arr[2] = 0x34 \u0026arr[3] = 000000000062FE13, arr[3] = 0x12 结论： 高位存储在高地址，所以是小端模式。 */ 5.printf的返回值类型是变量的字符个数。 6.#和##运算符的使用\n#include \u003cstdio.h\u003e #define T(x) printf(\"\"#x\" square is the \",(x)*(x)) #define TEST(n) X##n int main(void){ T(4); int TEST(0) = 10; int TEST(1) = 20; printf(\"%d\",X1); }结果：\n4 square is the 16 X1 = 107.结构体中存储字符串时我们可以使用字符指针或者字符数组，但是一般推荐字符数组。选择字符数组还是字符指针取决于具体的应用场景和需求。如果字符串长度固定或较短，且对性能和内存连续性有要求，字符数组可能是更好的选择。如果需要灵活处理不同长度的字符串，或者字符串长度可能非常大，使用字符指针可能更合适，但需要更加小心地管理内存。\n8.strlen()和strcpy()\nstrlen() 和 strcpy() 是 C 语言标准库中的两个常用函数，它们用于处理字符串。下面分别解释它们的用途和使用时需要注意的事项。\nstrlen() 函数 用途： strlen() 函数用于计算一个以空字符（'\\0'）结尾的字符串的长度。它返回字符串的长度，不包括最后的空字符。\n函数原型：\nsize_t strlen(const char *str);使用注意事项：\n参数必须是以空字符结尾的字符串：如果传入的参数不是以空字符结尾的字符串，strlen() 会一直读取内存直到遇到空字符，这可能导致程序读取到未分配的内存区域，造成越界错误。 返回值类型：strlen() 返回的是 size_t 类型，它是一个无符号整数类型，用于表示大小或长度。在比较时，需要注意不要与有符号整数类型进行比较，以避免潜在的负值问题。 效率问题：strlen() 需要遍历整个字符串直到找到空字符，因此对于非常长的字符串，可能会有一定的性能开销。 strcpy() 函数 用途： strcpy() 函数用于将源字符串（包括空字符）复制到目标字符串中。它会覆盖目标字符串原有的内容。\n函数原型：\nchar *strcpy(char *dest, const char *src);使用注意事项：\n目标字符串必须足够大：在使用 strcpy() 之前，必须确保目标字符串 dest 有足够的空间来存储源字符串 src 的内容，包括最后的空字符。否则，可能会导致缓冲区溢出，这是常见的安全漏洞。 不检查目标字符串大小：strcpy() 不会自动检查目标字符串的大小，如果目标字符串空间不足，会发生溢出。 不进行类型检查：strcpy() 不会对传入的参数类型进行检查，因此传入的参数必须是字符数组或字符指针。 返回值：strcpy() 返回目标字符串的指针，通常用于链式操作，但需要注意不要因此覆盖了重要的指针值。 安全性问题：由于上述原因，strcpy() 在很多情况下被认为是不安全的。在实际编程中，推荐使用 strncpy() 或其他更安全的字符串复制函数，这些函数允许指定最大复制的字符数，从而避免溢出。 9.修改字节对齐方式 ：#pragma pack(n) //n表示字节对起数，如2，4，8，\n10.不同位数电脑的字节对齐方式\n解释代码含义：\n#define offsetof(TYPE, MEMBER) ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER) (TYPE *)0:将0强制转换为TYPE类型指针，p = (TYPE *)0; ((TYPE *)0)-\u003e MEMNER:通过指针访问MEMBER成员， \u0026((TYPE *)0)-\u003e MEMNER：取得成员地址 ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER)：将成员地址转为size_t类型 总结：该宏定义的作用是求出MEMBER成员变量在TYPE中的偏移量。 示例：\n//#pragma pack(4) #include \u003cstdio.h\u003e #define offsetof(TYPE, MEMBER) ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER) typedef struct s { /* data */ union { int a;//4字节 char str[10];//10字节 }; struct s* next; }S; int main(){ printf(\"%ld\",offsetof(S, next)); return 0; }结果为16，因为电脑是64位的，所以以8字节对齐，联合体字节大小以最大的成员变量为准，故联合体的字节大小是10个字节\n12.返回二进制数中1的个数（经典题目） 13.求2的n次方 14.操作符[]的重载，代码实现读和写。 15.与操作与位操作\n#include \u003cstdio.h\u003e int main(){ int a = 0; a |= (1\u003c\u003c3);//将a的第3位设置为1 printf(\"%d\\n\",a); a \u0026= ~(1\u003c\u003c3);//将a的第3位设置为0 printf(\"%d\\n\",a); return 0; }知识点：\n只要出现置1：或操作 只要出现置0：与操作 16.sizeof的使用\n#include \u003cstdio.h\u003e int main(){ int a = 10; printf(\"%d\\n\",a); printf(\"%d\\n\",sizeof(a++)); printf(\"%d\\n\",a); return 0; }结果为：10,4,10,为什么最后不是11呢？ 17.指向地址的指针加一个整数\n#include \u003cstdio.h\u003e int main(){ unsigned char *p1 = (unsigned char *)0x08000010;//指向地址的指针 unsigned long *p2 = (unsigned long *)0x08000010;//指向地址的指针 printf(\"%#x\\n\",p1+5); printf(\"%#x\\n\",p2+5); return 0; }结果是0x08000015和0x08000024，\n对于前一个答案我们很清楚，因为一个unsigned char占一个字符，加5则是加5个字符； 后一个答案则是加5个long，一个long占4个字符，所以加5个long就是加20个字符，那么应该是0x08000030才对，为什么是0x08000024呢？因为使用的是16进制计算，20的十六进制就是14，所以是0x08000024。 18.volatile关键字\n#include \u003cstdio.h\u003e int squere(volatile int *pt){ //正确写法如下： //int a = *pt; //return a*a; return (*pt)*(*pt);//这样写可能会出错，因为编译器可能会优化代码，认为*pt的值没有改变，所以直接返回上一次的值 } int main(){ int a = 10; printf(\"%d\\n\",squere(\u0026a)); return 0; } 19.假设有两个变量a,b，不借助第三个变量交换两个变量的值。\n#include \u003cstdio.h\u003e int main(){ a=2;b=3; a=a^b;//0010^0011=0001 b=a^b;//0001^0011=0010 a=a^b;//0001^0010=0011 printf(\"%d,%d\\n\",a,b); return 0; }还可以使用减法的思想：\n#include \u003cstdio.h\u003e int main(){ a=2;b=3; a=a+b;//a=5 b=a-b;//b=2 a=a-b;//a=3 printf(\"%d,%d\\n\",a,b); return 0; }20.左移右移运算符和条件运算符的优先级\n#include \u003ciostream\u003e using namespace std; int main(){ int a = 99; int b = 100; cout\u003c\u003c(a\u003eb)?a:b; return 0; }结果输出为0，因为条件运算符的优先级低于左移运算符，所以先执行了左移运算符，结果为0。\n21.交换地址的高位和地位\n#include \u003cstdio.h\u003e void convert(unsigned int *); int main(){ unsigned int a; printf(\"请输入一个整数：\"); scanf(\"%x\",\u0026a); convert(\u0026a); printf(\"转换后的整数为：%x\\n\",a); return 0; } void convert(unsigned int *a){ unsigned int temp; temp = *a \u0026 0x0f; *a \u0026= 0xf0; *a = (*a \u003e\u003e 4) | (temp \u003c\u003c 4); } 结果： ```c 请输入一个整数：0x3A 转换后的整数为：0xa322.一级指针和二级指针 23.如果从数组x复制50个字节到数组y,最简单的方法是什么？\n#include \u003cstdio.h\u003e int main(){ char x[50] = \"hello world\"; char y[50]; memcpy(y,x,50); printf(\"%s\\n\",y); return 0; }memcpy 是一个用于在内存中复制数据的函数，定义在 C 标准库中的 \u003cstring.h\u003e 头文件中。它的原型如下：\nvoid *memcpy(void *dest, const void *src, size_t n);参数说明\ndest：指向目标内存位置的指针，即数据将被复制到的位置。 src：指向源内存位置的指针，即数据将从哪里复制。 n：要复制的字节数。 返回值\n返回指向目标内存位置的指针 dest。\n用途\nmemcpy 函数主要用于在内存中复制数据块，常用于以下场景：\n字符串复制：复制字符串内容。 结构体复制：复制结构体数据。 数组复制：复制数组元素。 使用注意事项\n目标内存必须足够大：确保目标内存区域足够大，能够容纳从源内存复制过来的数据，否则会导致缓冲区溢出。 源和目标内存不能重叠：如果源和目标内存区域有重叠，memcpy 的行为是未定义的。如果需要处理重叠的情况，可以使用 memmove 函数。 类型安全：memcpy 是一个低级别的内存操作函数，不进行类型检查，因此在使用时需要确保数据类型的一致性。 性能考虑：memcpy 通常比手动循环复制更高效，因为它利用了底层硬件的优化。 24.将字符数字转为整形数字\n思路：使用指针取出字符串中的每个字符，然后减去字符'0’的ASCII码值，即可得到对应的整形数字。 编写一个函数来实现这个操作，函数原型如下：\nint ascii_to_integer(const char *str);其中，str 是一个指向字符数字字符串的指针，函数返回对应的整形数字。\n#include \u003cstdio.h\u003e int ascii_to_integer(const char *str){ int digit = 0; while(*str \u003e= '0' \u0026\u0026 *str \u003c= '9'){ digit = digit * 10 + (*str - '0'); str++; } if(*str != '\\0') return 0; return digit; } int main(int argc, char *argv[]){ // int digit = ascii_to_integer(argv[1]);//在Linux中可以尝试这样写 char str[100]; printf(\"请输入一串数字字符：\"); scanf(\"%s\",str); printf(\"The digit is: %d\\n\", ascii_to_integer(str)); return 0; }24.百钱买百鸡问题\n解题思路如下图： #include \u003cstdio.h\u003e int main(){ int x, y, z; int t; for(t = 0;t\u003c=4;t++){ x = 4 * t; y = 25 - 7 * t; z = 75 + 3 * t; printf(\"cock:%d,hen:%d,chicken:%d-----sum:%d\\n\",x,y,z,x+y+z); } return 0; } 结果： cock:0,hen:25,chicken:75-----sum:100 cock:4,hen:18,chicken:78-----sum:100 cock:8,hen:11,chicken:81-----sum:100 cock:12,hen:4,chicken:84-----sum:10025.*和++运算符优先级 二者的运算优先级是一样的。\n#include \u003cstdio.h\u003e int main(){ int arr[10] = {1,2,3,4,5,6,7,8,9}; int *p = arr; for (int i = 0; i \u003c 3; i++){ printf(\"%d\",*p++); } p = arr; printf(\"\\n-------------------------------------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"%d\",*++p); } p = arr; printf(\"\\n-------------------------------------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"%d\",++(*p)); } return 0; }26.函数指针类型 27.编写函数实现整数四舍五入 思路：对于正数我们可以加0.5，然后取整； 对于负数则减去0.5，然后取整。\n#include \u003cstdio.h\u003e int round(int num){ if(num \u003e= 0){ return num + 0.5; }else{ return num - 0.5; } } int main(){ int num = 3.6; printf(\"round(%d) = %d\\n\",num,round(num)); return 0; }28.下图代码运行结果 29.函数指针数组 附件 ",
    "description": "",
    "tags": [
      "C++面试",
      "C++",
      "面经"
    ],
    "title": "1.在线题库练习",
    "uri": "/branch-bundle-1/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: C++面试",
    "uri": "/tags/c\u0026#43;\u0026#43;%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: M1-面试",
    "uri": "/categories/m1-%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 面经",
    "uri": "/tags/%E9%9D%A2%E7%BB%8F/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "内存分区模型 内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；\n一、程序执行前\n1.代码区 存放二进制指令，就是代码，特点：\n共享：多个进程的代码区是共享的，因为代码是相同的，所以只需要加载一份到内存中即可，节省内存空间。 只读：代码是只读的，防止程序意外地修改了代码。 2.全局区 全局变量和静态变量存储在全局区，还包括常量区、字符串常量和其他常量（如：const）,特点：\n全局区是程序结束后由系统释放。 全局变量和静态变量在程序结束后系统会自动释放，而局部变量在函数结束后由系统自动释放。 例子：\n#include \u003ciostream\u003e using namespace std; //全局变量 int g_a = 10; int g_b; //const 修饰的全局变量 const int c_g_a = 10; int main(int argc,char *argv[]){ //局部变量 int a = 10; int b = 20; //静态变量 static int s_a = 10; static int s_b; //字符串常量 char *P = \"hello world\"; //const修饰的局部变量 const int c_l_a = 10; cout\u003c\u003c\"局部变量a的地址：\"\u003c\u003c\u0026a\u003c\u003cendl; cout\u003c\u003c\"局部变量b的地址：\"\u003c\u003c\u0026b\u003c\u003cendl; cout\u003c\u003c\"全局变量a的地址：\"\u003c\u003c\u0026g_a\u003c\u003cendl; cout\u003c\u003c\"全局变量b的地址：\"\u003c\u003c\u0026g_b\u003c\u003cendl; cout\u003c\u003c\"静态变量a的地址：\"\u003c\u003c\u0026s_a\u003c\u003cendl; cout\u003c\u003c\"静态变量b的地址：\"\u003c\u003c\u0026s_b\u003c\u003cendl; cout\u003c\u003c\"字符串常量P的地址：\"\u003c\u003cP\u003c\u003cendl; cout\u003c\u003c\"const修饰的局部变量c_l_a的地址：\"\u003c\u003c\u0026c_l_a\u003c\u003cendl; cout\u003c\u003c\"const修饰的全局变量c_g_a的地址：\"\u003c\u003c\u0026c_g_a\u003c\u003cendl; return 0; }3.总结\n代码区：存放二进制指令，共享，只读。 全局区：存放全局变量和静态变量，程序结束后由系统释放。 二、程序运行后\n1.栈区\n由编译器自动分配释放，存放函数的参数值，局部变量等。\n注意： 不要返回局部变量的地址，因为局部变量在函数结束后会被系统释放，再次访问会导致程序崩溃。\n例子：\n#include \u003ciostream\u003e using namespace std; int *GetAddr(int b){//形参数据也放在栈区 b = 10; int a = 10; return \u0026a;//返回局部变量的地址 } int main(){ int *p = GetAddr(); cout\u003c\u003c*p\u003c\u003cendl;//第一次可以打印正确的数据，是因为编译器做了保留， cout\u003c\u003c*p\u003c\u003cendl;// 但是第二次访问将不再保留 return 0; }2.堆区\n由程序员分配释放，如果程序员不释放，程序结束时由系统回收。\n在C++中主要利用new和delete操作符进行动态内存管理。\n例子1-在堆上开辟空间：\n#include \u003ciostream\u003e using namespace std; int* getAddr(){ //在堆上开辟空间，并初始化为10 int *p = new int(10);//new出来的数据返回的是一个指针 //使用存在栈区的局部指针指向堆区的数据，栈区的内容会被程序自动释放，但是指向堆区的数据不会被释放 return p; } int main(){ int *p = getAddr(); cout\u003c\u003c*p\u003c\u003cendl;//输出10 delete p;//释放空间 return 0; }图解： 例子2-堆区上的数据开辟与释放\n#include \u003ciostream\u003e using namespace std; void test(){ int *P = new int(10); cout\u003c\u003c*P\u003c\u003cendl; delete P; } void test2(){ int *arr = new int[10]; for(int i = 0;i\u003c10;i++){ arr[i] = i+10; } for(int i = 0;i\u003c10;i++){ cout\u003c\u003carr[i]\u003c\u003c\" \"; } delete[] arr; } int main(){ test(); }引用 给变量取别名。\n一、变量引用\n引用注意事项：\n引用必须初始化，int \u0026b;//这样是不正确的 引用初始化后不能改变 通过引用参数产生的效果与指针地址传递效果一样，引用语法更清楚； 测试代码：\n//值传递 void test1(int a,int b) { } //地址传递 void test2(int *a,int *b) { int temp = *a; *a = *b; *b = temp; } //引用传递 void test3(int \u0026a,int \u0026b) { int temp = a; a = b; b = temp; }二、应用做函数的返回值\n不要返回局部变量的引用 函数返回值是引用，那么这个函数调用可以作为左值 测试代码：\n// 二、引用做函数返回值 //1.不能返回应用返回值 int\u0026 test04()//以引用的方式返回b,相当于给这个b起了一个别名 { int b = 10;//局部变量存放在栈区，函数结束后会被释放 return b; } //2. 函数的调用可以作为左值 int\u0026 test05() { static int b = 10;//静态变量存放在全局区，程序结束后由系统自动释放 return b; } int main() { int\u0026 ret04 = test04(); int\u0026 ret05 = test05(); std::cout \u003c\u003c \"ret04= \"\u003c\u003cret04 \u003c\u003c std::endl; std::cout \u003c\u003c \"ret04= \" \u003c\u003c ret04 \u003c\u003c std::endl;//第二次访问返回的是乱码 std::cout \u003c\u003c \"ret05= \" \u003c\u003c ret05 \u003c\u003c std::endl; test05() = 130;//函数的返回是引用，函数的调用可以作为左值 std::cout \u003c\u003c \"ret05= \" \u003c\u003c ret05 \u003c\u003c std::endl; system(\"pause\"); return 0; }测试代码结果 三、引用的本质\n引用的本质在C++内部实现是一个指针常量，引用类型必须和引用实体是同类型。\n四、常量引用\n作用：用来修饰形参，防止误操作。\n代码说明：\n//四、常量引用 //int \u0026ref = 10; 这样的操作是不被允许的，因为赋值给引用的是一个字面量,引用需要一个合法的空间， // 程序运行时没有专门为其分配可修改的内存空间 // 但是如果在前面在上const，这条代码就通过 // const int \u0026ref = 10; //用来修饰形参，防止误操作 void test06(const int \u0026val) { //val = 100;不被允许修改 std::cout \u003c\u003c \"val = \" \u003c\u003c val \u003c\u003c std::endl; }函数进阶 一、函数默认参数\n返回值 函数名(参数 = 默认值){}\n注意事项：\n1.如果某个位置已经有了默认参数，那么该位置往后都必须有默认参数\n//函数默认参数 void test(int a ,int b = 20,int c = 30) { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; std::cout \u003c\u003c \"c = \" \u003c\u003c c \u003c\u003c std::endl; }2.函数的声明有默认参数，函数实现不能有默认参数,声明和实现只能有一个有默认值\n#include \u003ciostream\u003e //函数声明 void test(int a=10,int b = 20);// //函数实现 void test(int a ,int b) { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; }二、函数占位参数\n作用：为了函数声明和定义的统一 语法：返回类型 函数名(数据类型){}\n//函数占位参数 void test(int a,int)//第二个参数为占位参数 { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; } int main() { test(10,10);//占位参数必须填补,否则无法运行 }注意：占位参数可以有默认参数，此时调用时就不用在传值\n//函数占位参数 void test(int a,int = 10)//第二个参数为占位参数，含默认值 { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; } int main() { test(10);//不需要传站位参数 }三、函数重载\n满足条件：\n在同一个作用域下。 函数名相同， 参数类型不同， 参数个数不同， 参数顺序不同。 作用： 提高复用性\n注意：\n1.返回值不能作为重载的条件\n2.引用作为重载的条件\n加const和不加是可以重载的\nvoid fun(int \u0026a){ std::cout\u003c\u003c\"fun(int \u0026a)\"\u003c\u003cstd::endl; } void fun(const int \u0026a){ std::cout\u003c\u003c\"fun(const int \u0026a)\"\u003c\u003cstd::endl; } int main(){ int a = 10; const int \u0026b = 20; fun(a);//调用fun(int \u0026a) fun(b);//调用fun(const int \u0026a) fun(10);//调用fun(const int \u0026a) return 0; }3.函数重载遇到默认参数\nvoid fun2(int a,int b = 10){ std::cout\u003c\u003c\"fun(int \u0026a)\"\u003c\u003cstd::endl; } void fun2(int a){ std::cout\u003c\u003c\"fun(const int \u0026a)\"\u003c\u003cstd::endl; } int main(){ fun2(10);//此时程序出现二义性，无法确定调用哪个函数 return 0; }类和对象的基本概念 C++的特性：封装、多态、继承\n一、基本概念\n抽象：将事物所能进行的的行为归纳出来，形成函数，这些函数可以操作事物归纳后的数据结构。 类： 、 封装 将事物归纳的数据结构和操作该数据结构的算法呈现显而易见的紧密关系，叫封装。\n一、 封装的意义\n1.将属性和行为作为一个整体，表现生活中的事物。\nnamespace test_class { //设计一个圆的类 #define PI 3.14 class Circle { //访问权限 public: //属性 int m_r; //行为 double calculateZC() { return 2 * PI * m_r; } }; void test() { Circle c1; c1.m_r = 10; cout \u003c\u003c \"圆的周长 = \" \u003c\u003c c1.calculateZC() \u003c\u003c endl; } }2.访问权限\npublic 公共权限 protected 保护权限 private 私有权限 二、访问权限说明\npublic修饰的成员，可以在类内或者类外直接访问 protected修饰的成员，只能在类内和子类中访问 private修饰的成员，只能在类内访问 继承 多态 类 将数据结构和操作该数据结构的函数捆绑在一起形成一个类。\n在类中使用缺省函数 需要注意避免二义性： 构造函数 类中为什么需要构造函数 构造函数在数组中的使用 class A{ int a; public: A(){std::cout\u003c\u003c\"hello\\n\";}//1 A(int b){std::cout\u003c\u003c\"value: \"\u003c\u003cb\u003c\u003cstd::endl;}//2 } int main(){ A arr[2] = {1}; }上面的语句就调用了第1，2个构造函数，首先数据里的1会调用2，而数组的第二个是空值那么就会调用第1个。\n复制构造函数-copy constructor 函数名与类名相同，参数为A(A\u0026 a)或A(const A\u0026 a)（二选一）。\n三种情况下复制构造函数起作用\n同类对象a,b，将a的值初始化b； A a; A b(a); 将类当作参数传入函数； 将类作为返回值； 注意：对象之间的复制是不会导致复制构造函数的\n转换构造函数 什么是转换构造函数 示例代码： 在上面的例子当中，c1 = 9;会被自动转换为调用转换构造函数，如果不想让这样的事情发生，可以在转换构造函数前面加上修饰字段 explicit，这样再次使用c1 = 9;时程序会报错。\n析构函数-destructors 这里补充几点，一个类只能有一个析构函数；\n析构函数与数组：\n数组成员的每一次结束时都会调用析构函数，假设类A数组array[2]，则生命周期结束时会调用两次析构函数。\n析构函数什么时候被调用呢？\nclass CMyclass { public: ~CMyclass() { cout \u003c\u003c \"destructor\" \u003c\u003c endl; } }; CMyclass obj; CMyclass fun(CMyclass sobj ) { //参数对象消亡也会导致析 //构函数被调用 return sobj; //函数调用返回时生成临时对象返回 } int main(){ obj = fun(obj); //函数调用的返回值（临时对象）被 return 0; //用过后，该临时对象析构函数被调用 }上面结果输出三个destructor，在fun(CMyclass sobj)参数对象消亡调用析构函数（具体可以联想复制构造函数），会调用一次析构函数；当函数返回赋值给obj后，再次调用析构函数；整个程序结束再次调用析构函数。 this指针 静态成员函数中可以直接使用this指针来代表指向该函数作用的对象的指针\n示例1：\nclass Complex { public: double real, imag; void Print() { cout \u003c\u003c real \u003c\u003c \",\" \u003c\u003c imag ; } Complex(double r,double i):real(r),imag(i) { } Complex AddOne() { this-\u003ereal ++; //等价于 real ++; this-\u003ePrint(); //等价于 Print return * this; } }; int main() { Complex c1(1,1),c2(0,0); c2 = c1.AddOne();//调用AddOne函数后内部this指针变为c1，所以是c1中的read++ return 0; } //输出 2,1 示例2：\nclass A { int i; public: void Hello() { cout \u003c\u003c i \u003c\u003c \"hello\" \u003c\u003c endl; } }; // 翻译为void Hello(A * this ) { cout \u003c\u003c this-\u003ei \u003c\u003c \"hello\"\u003c\u003c endl; } int main() { A * p = NULL; p-\u003eHello(); //翻译为Hello(p); } //编译报错 报错的原因是p指针式一个空指针，它并不指向任何A的对象，所以编译到 this-\u003ei 会报错。\n静态成员变量和函数 基本特点：\n普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问。 对第二句话的理解，如下代码示例：\nclass Dog { public: // 普通成员函数 void bark() { std::cout \u003c\u003c \"Woof!\" \u003c\u003c std::endl; } // 静态成员函数 static std::string getSpecies() { return \"Canine\"; } };要调用bark我们需要先创建一个Dog的类对象，然后通过 . 调用，也就是非静态成员作用于对象的意思，但是对于 getSpecies 就不需要，可以直接 Dog::getSpecies调用。\n如何访问静态成员？\n类名::成员名 CRectangle::PrintTotal();\n对象名.成员名 CRectangle r; r.PrintTotal();\n指针-\u003e成员名 CRectangle * p = \u0026r; p-\u003ePrintTotal();\n引用.成员名 CRectangle \u0026 ref = r; int n = ref.nTotalNumber;\n设置静态成员变量的目的是什么？\n设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。比如，考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，用静态成员将这两个变量封装进类中，就更容易理解和维护。\n注意事项：\n必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。 成员对象和封闭类 有成员对象的类叫 封闭(enclosing)类。 任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。具体的做法就是：通过封闭类的构造函数的初始化列表。 封闭类的复制构造函数:\nclass A { public: A() { cout \u003c\u003c \"default\" \u003c\u003c endl; } A(A \u0026 a) { cout \u003c\u003c \"copy\" \u003c\u003c endl;} }; class B { A a; }; int main() { B b1,b2(b1);//b2调用自生默认复制构造函数，而内部的A a也会调用默认的复制构造函数 return 0; }友元 友元函数: 一个类的友元函数可以访问该类的私有成员。 可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。 友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。 友元类之间的关系不能传递，不能继承。 常量成员 常量成员函数：内部不能改变属性的值，也不能调用非常量成员函数。\n**注意：**如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么，最好将其写成常量成员函数。 mutable成员变量 可以在const成员函数中修改的成员变量\nclass CTest { public: bool GetData() const { m_n1++;//这个值更可以更改 return m_b2; } private: mutable int m_n1; bool m_b2; };运算符重载函数 浅拷贝与深拷贝： 为解决这个问题，我们需要修改赋值运算符重载：\nString \u0026 operator = (const String \u0026 s){ if( this == \u0026 s) return * this; delete [] str; str = new char[strlen(s.str)+1]; strcpy( str,s.str); return * this; }自增自减运算法重载 class CDemo { private : int n; public: CDemo(int i=0):n(i) { } CDemo \u0026 operator++(); //用于前置形式 CDemo operator++( int ); //用于后置形式 operator int ( ) { return n; } friend CDemo \u0026 operator--(CDemo \u0026 ); friend CDemo operator--(CDemo \u0026 ,int); }operator int ( ) {return n;}\n这里，int 作为一个类型强制转换运算符被重载, 此后\nDemo s; (int) s ; //等效于 s.int(); 类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型。\n继承和派生 **注意：**在派生类的各个成员函数中，不能访问基类中的private成员。\n派生类的内存空间 类之间的关系 继承：“是”关系。\n基类 A，B是基类A的派生类。 逻辑上要求：“一个B对象也是一个A对象”。 复合：“有”关系。\n类C中“有”成员变量k，k是类D的对象，则C和D是复合 关系 一般逻辑上要求：“D对象是C对象的固有属性或组成部 分” 复合关系的示例： 基类与派生类名字重名的情况 一般来说，基类和派生类不定义同名成员变量。但如果要方位可以使用基类::基类成员来访问。\n访问权限 • 基类的private成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 • 基类的public成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 派生类的成员函数 派生类的友元函数 其他的函数 • 基类的protected成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 派生类的成员函数可以访问当前对象和其它对象的基类的保护成 举一个例子：\nclass Father { private: int nPrivate; //私有成员 public: int nPublic; //公有成员 protected: int nProtected; // 保护成员 }; class Son :public Father{ void AccessFather () { nPublic = 1; // ok; nPrivate = 1; // wrong nProtected = 1; // OK，访问从基类继承的protected成员 Son f; f.nProtected = 1; //ok，派生类的成员函数可以访问当前对象和其它对象的基类的保护成 } }; int main(){ Father f; Son s; f.nPublic = 1; // Ok s.nPublic = 1; // Ok f.nProtected = 1; // error，因为只能在派生类（或友元类）中访问 f.nPrivate = 1; // error s.nProtected = 1; //error s.nPrivate = 1; // error return 0; }派生类构造函数中包含成员变量时该如何写？ class Bug { private : int nLegs; int nColor; public: int nType; Bug ( int legs, int color); void PrintBug (){ }; }; class Skill { public: Skill(int n) { } }; class FlyBug: public Bug { int nWings; Skill sk1, sk2; public: FlyBug( int legs, int color, int wings); }; FlyBug::FlyBug( int legs, int color, int wings): Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) { }//注意这种写法。 private 和 protected的继承 • protected继承时，基类的public成员和protected成员成为派生类的protected成员。 • private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员。 • protected和private继承不是“是”的关系。\n问题：\n即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。\n解决办法：\n通过强制指针类型转换，可以把ptrBase转换成Derived类的指针\nBase * ptrBase = \u0026objDerived; Derived *ptrDerived = (Derived * ) ptrBase;程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。\n虚函数和多态 多态的表现形式 派生类的指针（或引用）可以给基类赋值。 当指针指向基类时调用，基类的函数，当指针指向派生类时，调用调用派生类的函数，这叫做多态。 另外，在非虚函数和非构造、析构函数中调用虚函数，也叫做多态。 例子： 如果在构造、析构函数中调用虚函数，那么会怎么样呢？\n如果这么做，那么编译器只会调用当前的虚函数，如果当前没有重写虚函数，则会从基类中找进行调用，为什么要这么做呢？其实这是为了防止未初始化就调用派生类的虚函数的情况。\n你想想啊，一类的初始化先从基类的构造函数开始，如果这个时候构造函数具有多态性，那么此时将调用派生类的对应虚函数，但是派生类这个时候都还没有初始化。\n例子： `\n补充：在上面的图例子中，派生类写了与基类虚函数相同的名字，但是没有在前面加修饰符virtual，这种情况编译器认为是虚函数。 多态的作用 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。\n虚函数的访问权限 动态联编的实现机制 “多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 —- 这叫“动态联编”。\n每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。 下面一段代码将验证，对象的首地址是存了虚函数表的地址的：\n#include \u003ciostream\u003e using namespace std; class A { public: virtual void Func() { cout \u003c\u003c \"A::Func\" \u003c\u003c endl; } }; class B:public A { public: virtual void Func() { cout \u003c\u003c \"B::Func\" \u003c\u003c endl; } }; int main() { A a; A * pa = new B(); pa-\u003eFunc(); //64位程序指针为8字节 long long * p1 = (long long * ) \u0026 a; long long * p2 = (long long * ) pa; * p2 = * p1; pa-\u003eFunc(); return 0; }纯虚函数和抽象类 纯虚函数：没有函数体的虚函数 抽象类：有纯虚函数的类 注意：\n包含纯虚函数的类叫抽象类 抽象类只能作为基类来派生新类使用，不能创建独立的抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 A a ; // 错，A 是抽象类，不能创建对象 A * pa ; // ok,可以定义抽象类的指针和引用 pa = new A ; //错误, A 是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。 附件 ",
    "description": "",
    "tags": [
      "C++",
      "C",
      "基础知识",
      "基本概念"
    ],
    "title": "14.新标准C加加程序设计",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: C",
    "uri": "/tags/c/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: R1-编程语言",
    "uri": "/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 基本概念",
    "uri": "/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 基础知识",
    "uri": "/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 20.C加加面试",
    "content": "网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用\n数据湖结构与算法 附件 ",
    "description": "",
    "tags": [
      "C++面试",
      "C++",
      "面经"
    ],
    "title": "1.网络编程",
    "uri": "/branch-bundle-1/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量\n指的是用 ““括起来的字符串。\n长字符串编写： 带有L的字符是宽字符，如L\"sddsf”，类型是const wchar_t. 3.指向数组的指针\n4.常量 5.指针和常量\n使用一个指针时涉及到两个对象:该指针本身和被它所指的对象。将一个指针的声明用cons“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，我们必须使用声明运算符*const，而不能只用简单的const。\n定义常量指针的声明运算符是const。并没有cons** 声明符，所以出现在之前的conr是作为基础类型的一部分。例如\n// 到char的hconst指针 char *const cp; char const* pc; // 到const char的指针 const char* pc2; //到const char的指针 有人发现从右向左读这种定义很有帮助。例如，“cp是一个conse指针到char”，以及“pe2是一个指针措到const chor”\n引用 void f(){ int ii=1; int \u0026rr = ii; rr++;//实际上是ii++,rr不能像指针一样操作。 int *pp = \u0026ii; } 附件 ",
    "description": "",
    "tags": [
      "C++",
      "C",
      "基础知识",
      "基本概念"
    ],
    "title": "13.从C到C++",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：\n数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 std::unordered_map 和 std::unordered_set）的基础。\n快速比较：在数据库和各种数据结构中，哈希函数可以快速比较字符串或对象，常用于检查两个字符串是否相等。\n数据分布：在分布式系统中，哈希函数可以将数据均匀地分布到多个节点上，以实现负载均衡。\n密码学应用：在密码学中，哈希函数用于生成数据的摘要，用于数据完整性验证和数字签名。\n缓存实现：哈希函数可以用于实现缓存机制，通过快速定位缓存中的数据。\n负载均衡：在网络流量管理中，哈希函数可以用于将请求分配到不同的服务器上。\nC++ 库中哈希函数的实现和底层逻辑 在 C++11 及以后的版本中，标准库提供了一个专门的哈希函数库 \u003cfunctional\u003e，其中包含了 std::hash 模板类。std::hash 为基本数据类型（如 int、double、std::string 等）提供了特化版本。\n实现底层逻辑： 整数类型：对于整数类型，std::hash 直接返回数值本身或其变体。例如，对于 int 类型，std::hash\u003cint\u003e()(10) 可能直接返回 10 或者 10 的一个简单变换。\n浮点类型：对于浮点类型，std::hash 通常会将浮点数的位表示转换为整数，然后应用整数的哈希函数。\n字符串类型：对于字符串，std::hash 通常会遍历字符串中的每个字符，将每个字符的哈希值组合起来，生成最终的哈希值。这可以通过位操作和数学函数（如乘法、加法、异或等）来实现。\n自定义类型：对于自定义类型，如果需要使用 std::hash，则需要为该类型提供自定义的哈希函数。\n组合哈希：对于复合类型（如结构体或类），哈希函数需要将各个成员的哈希值组合起来。这通常通过将成员的哈希值进行某种形式的数学运算（如加权求和、异或等）来实现。\n均匀分布：一个好的哈希函数应该能够产生均匀分布的哈希值，以减少哈希冲突。\n确定性：哈希函数应该是确定性的，即对于同一个输入总是产生相同的哈希值。\n快速计算：哈希函数的计算应该尽可能快，以减少对性能的影响。\n在 C++ 中，std::hash 的实现可能因编译器和平台而异，但基本原理是相似的。正确实现哈希函数对于哈希表的性能至关重要，因为它直接影响到哈希表的冲突率和检索效率。\nhash function-哈希函数 如果要自己给自己的数据写一个哈希函数，那又该怎么写呢？能否基于这些数据计算出hash code的呢？\n编写模版规范 ​ 类型1 类型1示例 类型2 类型3 #include \u003cfunctional\u003e namespace test_hash_function { class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const {//需要重载== return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: std::size_t operator()(const Customer\u0026 c) const { return ...; } }; unordered_set\u003cCustomer, CustromerHash\u003e custsct; } #include \u003cfunctional\u003e namespace test_hash_function { template \u003ctypename T\u003e inline void hash_combine(size_t\u0026 seed, const T\u0026 val) { seed ^= hash\u003cT\u003e()(val) + 0x9e3779b9 + (seed \u003c\u003c 6) + (seed \u003e\u003e 2); } template \u003ctypename T\u003e inline void hash_val(size_t\u0026 seed, const T\u0026 val) { hash_combine(seed, val); } template \u003ctypename T, typename... Types\u003e inline void hash_val(\tsize_t\u0026 seed, const T\u0026 val, const Types\u0026... args) { hash_combine(seed, val); hash_val(seed, args...); } template \u003ctypename... Types\u003e inline size_t hash_val(const Types\u0026... args) { size_t seed = 0; hash_val(seed, args...); return seed; } class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const { return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: size_t operator()(const Customer\u0026 c) const { return hash_val(c.fname, c.lname, c.on); } }; void test() { unordered_set\u003cCustomer, CustomerHash\u003e s; s.insert(Customer(\"Asd\", \"dfw\", 1L)); s.insert(Customer(\"Dfg\", \"kjt\", 2L)); s.insert(Customer(\"VVB\", \"ert\", 3L)); s.insert(Customer(\"TgR\", \"uik\", 4L)); s.insert(Customer(\"Gdf\", \"pii\", 5L)); s.insert(Customer(\"Gdf\", \"pii\", 6L)); s.insert(Customer(\"Gdf\", \"pii\", 7L));//8 cout \u003c\u003c s.bucket_count() \u003c\u003c endl; CustomerHash hh; cout \u003c\u003c hh(Customer(\"Asd\", \"dfw\", 1L)) % 8 \u003c\u003c endl;//4 cout \u003c\u003c hh(Customer(\"Dfg\", \"kjt\", 2L)) % 8 \u003c\u003c endl;//0 cout \u003c\u003c hh(Customer(\"VVB\", \"ert\", 3L)) % 8 \u003c\u003c endl;//3 cout \u003c\u003c hh(Customer(\"TgR\", \"uik\", 4L)) % 8 \u003c\u003c endl;//7 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 5L)) % 8 \u003c\u003c endl;//2 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 6L)) % 8 \u003c\u003c endl;//7 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 7L)) % 8 \u003c\u003c endl;//4 for (unsigned i = 0; i \u003c s.bucket_count(); i++) { cout \u003c\u003c \"bucked #\" \u003c\u003c i \u003c\u003c \"has\" \u003c\u003c s.bucket_size(i) \u003c\u003c \"element\\n\"; } } } // bucked #0has1element // bucked #1has0element // bucked #2has1element // bucked #3has1element // bucked #4has2element // bucked #5has0element // bucked #6has0element // bucked #7has2element #include \u003cfunctional\u003e namespace test_hash_function { class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const {//需要重载== return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: size_t customer_hash_func(const Customer\u0026 c) const { return ...; } }; unordered_set\u003cCustomer, size_t(*)(const Custromer\u0026)\u003e custsct(20,customer_hash_func);//注意与类型1的不同写法 } 第三种方式是对类里面的hash进行偏特化，比如你使用了unordered_set那么对于它的Hash，可以单独进行偏特化。 tuple 在C++中，tuple 是一个标准库模板类，它提供了一种方式来存储不同类型数据的集合。tuple 类似于一个固定大小的数组，但是数组中的每个元素可以是不同的类型。这个特性使得 tuple 非常灵活，可以用于多种场景。\n附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "12.其他库的介绍",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。\n下面做一个模拟问答，来加以了解：\n—c 模拟问答 算法：你好，vector的迭代器，我需要知道你的迭代器类别，这样我才能正确地进行操作。\nvector的迭代器：好的，我先问一下我的适配器。\rvector的迭代器：适配器，算法想知道 iterator_traits\u003cInputIterator\u003e::iterator_category 是什么类型的迭代器？\rvector_iterator的适配器：你好，我们这里是随机访问迭代器（Random Access Iterator）。\r算法：太好了，随机访问迭代器可以让我进行更高效的操作。那么，如果我想访问第8个元素，我该怎么做？\rvector_iterator的适配器：很简单，你可以直接通过加上偏移量来访问第8个元素。比如，如果你有一个指向第一个元素的迭代器 first，那么 first + 7（因为迭代器是从0开始计数的）就会给你第8个元素的迭代器。\r算法：明白了，那我可以直接使用 *(first + 7) 来获取第8个元素的值了。\rvector_iterator的适配器：是的，完全正确。\r算法：如果我需要反向迭代器，或者插入迭代器，你们能提供吗？\rvector_iterator的适配器：当然可以。我们 vector 提供了多种迭代器适配器，包括反向迭代器（reverse_iterator）、插入迭代器（insert_iterator）等，以满足不同的需求。\r算法：那太好了，这样我可以更灵活地处理 vector 中的数据了。谢谢你的帮助！\rSTL中适配器的重要特性 对于容器、迭代器和仿函数它们第二次迭代器都有一个重要的特性，就是适配器会包含（也有继承）对应的类，比如stack包含了deque，然后使用了deque的某些功能，屏蔽了deque的某些某能，实现了先进后出的功能。\n仿函数适配器 binder2nd适配器 该适配器是用于绑定的，比如对于一个容器，需要操作比88小于数，这使用可以用binder2nd，第一个参数可以传入比较大小的less仿函数，第二个传入比较的数值x，本质上在binder2nd中，less的第二个参数传入就是x,这样就达到比较的目的了。 小结：把A类和数值a传入另一个类B中，在B中再操作A和a.这样就实现了绑定。\nnot1 对结果取反 一些新的适配器 bind 迭代器适配器 reverse——iterator 三个细节：\n1.begin=rend,end=rbigin 2.取值是取后一个，所以内部实现的*是做–操作； 3.operate ++()操作重载后内部实现为–，operate –()重载后内部实现++操作。 具体图下图所示 insert_iterator 在下面的案例中copy(bar.begin(),bar.end(),inserter(foo,it));欲将list的bar数据从it指向的位置 开始插入，但是foo的空间不够，为什么还能成功？\n设计的小技巧，当传入copy中时，因为inserter对operate =()做了重载，重载中调用了insert()该函数能决绝以上问题， 因此不会因为foo的内存不足导致插入失败。 ostream_iterator 下面通过一个案例说明该迭代器的一些特性和使用方法：\n1.当执行初始化操作std::ostream_iterator out_it(std::cout,\",\")时调用构造函数，并初始化。 2.执行copy操作时，因为ostream_iterator对operate =()重载，所以会将值value传给*out_stream，通过这个方法把数据打印在屏幕上。 istream_iterator 下面也是两个例子说明istream_iterator的特性：\n1.std::istream_iterator\u003cdouble\u003e iit(std::cin);时同样会调用对应的构造函数，并且此处会调用operate ++()重载，在该重载中，*in_stream接收按键输入的一个值，也就是说才定义时，就已经在准备接收一个值，如果此时在该语句下写一段打印操作没见无法看到输出！ 2.下面是copy操作，对于这个操作，我们可以观察是否有对*和=的操作符进行重载，对于=的重载上述已经介绍， *的重载是将value返回，也就是 *first的操作取得的是容器中的值。 附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "11.STL库学习之适配器",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。\n你的理解是正确的，仿函数（functor）是 C++ 中的一个概念，它指的是那些可以像函数一样被调用的对象。这些对象通常重载了函数调用操作符 operator()，使得对象可以被当作函数来使用。以下是对你描述的一些补充说明：\n仿函数的特点 重载 operator()：仿函数类必须重载函数调用操作符 operator()，这样对象就可以被像函数那样调用。\n可以携带状态：与普通函数不同，仿函数可以拥有成员变量，这意味着它们可以携带状态。这些状态可以是私有的，也可以是公开的，取决于仿函数的设计。\n可以进行重载：仿函数可以重载 operator()，以接受不同数量和类型的参数。\n可以定义在类中：仿函数可以是类的成员函数，也可以是独立的类。\n可以有返回值：当仿函数被调用时，可以返回一个值，就像普通函数那样。\n可以作为参数传递：由于仿函数可以像函数一样被调用，它们可以作为参数传递给接受函数作为参数的函数。\n仿函数的应用 算法的参数：仿函数经常用作 STL 算法的参数，例如 std::sort 和 std::find_if，因为这些算法需要一个可以被调用的实体来比较元素或测试条件。\n回调函数：在事件驱动的编程中，仿函数可以作为回调函数，响应特定的事件。\n策略模式：在设计模式中，仿函数可以用于实现策略模式，允许算法的行为在运行时动态改变。\n简化代码：通过使用仿函数，可以减少函数指针和全局函数的使用，使得代码更加简洁和易于管理。\n示例代码 struct Max { // 重载()操作符，使其可以被调用 int operator()(int a, int b) const { return (a \u003e b) ? a : b; } }; int main() { Max max_functor; int result = max_functor(10, 20); // 使用仿函数对象调用 std::cout \u003c\u003c \"Max value: \" \u003c\u003c result \u003c\u003c std::endl; return 0; }在这个例子中，Max 是一个仿函数，它重载了 operator() 来比较两个整数并返回最大值。然后，我们可以像调用函数一样调用 max_functor 对象。\n仿函数内部一般设计什么？ 仿函数一般重载operate()后，会在内部设计运算操作，如算数、逻辑、相对关系等运算。如下图所示。 从上面一张图也可以发现，plus,minus,logical_and,equal_to,less类都集成了binary_function，该类的作用是什么呢？\nstd::binary_function 的主要作用是：\n泛型框架：提供一个泛型框架，允许函数对象接受任意类型的参数。 类型转换：允许参数类型和返回类型的转换，使得函数对象可以用于不同的数据类型。 模板编程：支持模板编程，使得可以创建通用的算法和函数。 原型 std::binary_function 的原型如下：\ntemplate \u003cclass Arg1Type, class Arg2Type, class ResultType\u003e struct binary_function { typedef Arg1Type first_argument_type; typedef Arg2Type second_argument_type; typedef ResultType result_type; }; Arg1Type：第一个参数的类型。\nArg2Type：第二个参数的类型。\nResultType：函数返回值的类型。\n继承和使用\n函数对象如 std::plus, std::minus, std::logical_and, std::equal_to, std::less 等都继承自 std::binary_function。这意味着这些函数对象都定义了 first_argument_type, second_argument_type, 和 result_type 这三个类型别名，它们分别表示函数对象接受的第一个参数类型、第二个参数类型和返回值类型。\n关于 std::binary_function的具体细节在适配器一节会重点讲到。\n下图是是否继承binary_function的一些示例，如果不继承会怎么样呢？以我个人的理解，继承会让仿函数的扩展性更高，它将来可以扩展出更好的功能。如下图所示。 除了上面讲到的binary_function还有unary_function，该类是针对单个变量的操作，比如取反，加加。如下图： 关于binary_function的细节此处先不介绍，下一节将着重说明。\n对于仿函数，鲜明的特点就是对operate()做了重载，这样的类创建出来的对象叫仿函数对象，具有函数的行为。如果要对重载做更多操作需要结合一些仿函数适配器，比如相面讲到的binary_function和unary_funtion。\n附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "10.STL库学习之仿函数",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代器）： 输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。\n用法示例：\nstd::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::input_iterator\u003cint\u003e it = vec.begin(); while (it != vec.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; ++it; }2.Forward Iterator（前向迭代器）： 前向迭代器支持双向遍历，可以向前和向后移动。\n用法示例：\nstd::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; std::forward_iterator\u003cint\u003e it = lst.begin(); while (it != lst.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; ++it; }3.Output Iterator（输出迭代器）： 输出迭代器允许对容器中的元素进行写操作，但不支持读操作。\n用法示例：\nstd::vector\u003cint\u003e vec; std::back_insert_iterator\u003cstd::vector\u003cint\u003e\u003e it(vec); *it = 1; // 写操作 ++it; *it = 2; // 写操作 4.Bidirectional Iterator（双向迭代器）： 双向迭代器支持双向遍历，可以向前和向后移动。\n用法示例：\nstd::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; std::bidirectional_iterator\u003cint\u003e it = lst.end(); while (it != lst.begin()) { --it; std::cout \u003c\u003c *it \u003c\u003c \" \"; }5.Random Access Iterator（随机访问迭代器）： 随机访问迭代器支持任意位置的快速访问，类似于指针操作。\n用法示例：\nstd::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::random_access_iterator\u003cint\u003e it = vec.begin(); it += 2; // 随机访问 std::cout \u003c\u003c *it \u003c\u003c \" \";各种容器的迭代器类型 测试代码：\n#include \u003citerator\u003e namespace test_iterator_category { template \u003ctypename T\u003e void display_category(T itr) { typename iterator_traits\u003cT\u003e::iterator_category cagy; // 使用 std::iterator_traits 获取迭代器类别 // 这里不需要递归调用 display_iterator 函数 cout \u003c\u003c typeid(cagy).name() \u003c\u003c endl; } void test() { cout \u003c\u003c \"\\ntest_iterator_category....................\\n\"; display_category(array\u003cint, 10\u003e::iterator()); display_category(vector\u003cint\u003e::iterator()); display_category(list\u003cint\u003e::iterator()); display_category(forward_list\u003cint\u003e::iterator()); display_category(deque\u003cint\u003e::iterator()); display_category(set\u003cint\u003e::iterator()); display_category(map\u003cint, int\u003e::iterator()); display_category(multiset\u003cint\u003e::iterator()); display_category(multiset\u003cint, int\u003e::iterator()); display_category(istream_iterator\u003cint\u003e()); display_category(ostream_iterator\u003cint\u003e(cout,\"\")); } }此处可以参考一下display_category(array\u003cint, 10\u003e::iterator());中传递array\u003cint, 10\u003e::iterator()的方法。\n测试结果：\ntest_iterator_category.................... struct std::random_access_iterator_tag struct std::random_access_iterator_tag struct std::bidirectional_iterator_tag struct std::forward_iterator_tag struct std::random_access_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::input_iterator_tag struct std::output_iterator_tag迭代器对算法的影响 例子1-distance 迭代器如何计算容器元素之间的距离呢？当调用迭代器时，迭代器是如何操作以协助算法完成后续的增删改查的？\n在计算距离方面，我们可以看到调用接口需要传入容器的头，以及容器尾部，接着使用：\n... typedef typename iterator_traits\u003cInputIterator\u003e::itrerator_category category; return __distance(first,last, category);typedef typename iterator_traits\u003cInputIterator\u003e::itrerator_category category;这一句会判断迭代器的类型，进而执行加操作或一步一步加操作。详细如下图所示。 例子2-copy copy的动作也不仅仅是对迭代器类型的判断，还做了许多特化、偏特化。如下图所示。 例子3-destroy 例子4-__unique_copy 对传入的迭代器类型的暗示 在调用一些需要传入迭代器的函数时，从函数的形参名可以判断传入的迭代器类型，如InputIterator，由于forward_iterator_tag、bidirection_iterator_tag、random_asccess_iterator_tag与input_iterator的继承关系可知，前三者都可以传入，以此类推如果形参是forward_iterator_tag那么除了其本身，bidirection_iterator_tag、random_asccess_iterator_tag也可传入。\n算法源码剖析 accumulate-累计 测试用例：\n#include \u003cfunctional\u003e//std::minus #include \u003cnumeric\u003e//std::accumulate namespace test_accumulate { int myfcn(int x, int y) { return x + 2 * y; } struct myclass { int operator()(int x, int y) { return x + 3 * y; } } myobj; } void test(){ int init = 10; int nums[] = {10,10,10}; cout \u003c\u003c accumulate(nums, nums + 3, init)\u003c\u003cendl;//40 cout \u003c\u003c accumulate(nums, nums + 3, init, test_accumulate::myfcn)\u003c\u003cendl;//70 cout \u003c\u003c accumulate(nums, nums + 3, init, test_accumulate::myobj) \u003c\u003c endl;//100 }for_each 拿到每一个元素时都对该元素执行某一操作。 测试用例：\nnamespace test_for_each { void myfcn(int i) { cout\u003c\u003ci\u003c\u003c\"-\"; } struct myclass { void operator()(int i) { cout \u003c\u003c \"[\" \u003c\u003c i\u003c\u003c\"] \"; } } myobj; void test() { vector\u003cint\u003e c; c.push_back(10); c.push_back(20); c.push_back(30); for_each(c.begin(), c.end(), test_for_each::myfcn);//10-20-30- cout \u003c\u003c \"\\n\"; for_each(c.begin(), c.end(), test_for_each::myobj);//[10] [20] [30] } }replace,replace_if,rreplace_copy replace用于将新值替换为旧值，例如将数组中所有的8替换为9.详细源码如下图所示。 replace、replace_if 和 replace_copy 是 C++ 标准库中的算法，它们用于在容器或数组中替换元素。这些函数属于 \u003calgorithm\u003e 头文件。下面是每个函数的详细介绍和作用：\n1. replace replace 函数用于将容器中所有满足特定条件的元素替换为另一个值。这个函数直接在原容器上操作，不创建新的容器。\n函数原型:\nvoid replace(ForwardIterator first, ForwardIterator last, const T\u0026 old_value, const T\u0026 new_value); first, last：定义了要替换元素的范围。 old_value：要被替换的值。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; replace(v.begin(), v.end(), 2, 5); // v 变为 {1, 5, 3, 4, 3, 5} 2. replace_if replace_if 函数用于将容器中满足特定条件的元素替换为另一个值。与 replace 不同，replace_if 需要一个谓词（条件函数），只有满足这个条件的元素才会被替换。这个函数也直接在原容器上操作。\n函数原型:\nvoid replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T\u0026 new_value); first, last：定义了要替换元素的范围。 pred：一个谓词函数，返回 true 表示替换，false 表示不替换。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; replace_if(v.begin(), v.end(), [](int i) { return i == 2; }, 5); // v 变为 {1, 5, 3, 4, 3, 5} 3. replace_copy replace_copy 函数用于将容器中所有满足特定条件的元素复制到另一个容器中，并替换为另一个值。这个函数不会改变原容器，而是创建一个新的容器，其中包含替换后的元素。\n函数原型:\ntemplate \u003cclass InputIterator, class OutputIterator\u003e OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T\u0026 old_value, const T\u0026 new_value); first, last：定义了要替换元素的范围。 result：指向目标容器的迭代器，用于存储替换后的元素。 old_value：要被替换的值。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; vector\u003cint\u003e v2(v.size()); replace_copy(v.begin(), v.end(), v2.begin(), 2, 5); // v 保持不变，v2 变为 {1, 5, 3, 4, 3, 5} count，count_if 源代码如下： 小结： find，find_if sort binary_search 算法原理：\n二分查找的基本思想是将一个有序序列分为两半，通过比较中间元素和目标值来缩小搜索范围。如果中间元素正好是目标值，则查找成功；如果目标值小于中间元素，则在序列的左半部分继续查找；如果目标值大于中间元素，则在右半部分继续查找。这个过程不断重复，直到找到目标值或搜索范围为空。\n函数原型：\nbinary_search 的函数原型如下：\ntemplate \u003cclass ForwardIterator, class T\u003e bool binary_search(ForwardIterator first, ForwardIterator last, const T\u0026 value); first, last：定义了要搜索的范围，first 是序列的开始迭代器，last 是序列的结束迭代器（指向序列末尾的下一个位置）。 value：要查找的值。 返回值：\n如果在序列中找到 value，则返回 true。 如果没有找到，则返回 false。 示例代码：\n#include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003ciostream\u003e int main() { std::vector\u003cint\u003e data = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int target = 5; bool found = std::binary_search(data.begin(), data.end(), target); if (found) { std::cout \u003c\u003c \"Element found in the array.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"Element not found in the array.\" \u003c\u003c std::endl; } return 0; }注意事项：\n有序序列：binary_search 要求序列必须是有序的，否则查找结果将不可预测。 效率：二分查找的时间复杂度为 O(log n)，其中 n 是序列中的元素数量。这使得它比线性查找（O(n)）更高效，尤其是在大数据集上。 稳定性：如果存在多个相同的目标值，binary_search 将返回第一个匹配的位置。如果需要找到所有匹配项，可能需要使用其他方法。 附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "9.STL库学习之迭代器与算法",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）,否则借助insert_aux()迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。\ndeque中+=的实现：1.先计算+=后是否超过缓冲区，如果没有则直接+=，否则需要判断需要跨几个缓冲区，然后再去确定前进几个缓冲区。 Vector的内存扩充：\nstd::vector 在需要更多空间时，通常会将容量增加到当前大小的两倍（这是最常见的增长策略，但不是唯一的，具体实现可能有所不同）。\n当发生扩充时，std::vector 会分配一个新的更大的内存块，然后将所有元素从旧内存块复制到新内存块，最后释放旧内存块。\nDeque的内存扩充：\nstd::deque（双端队列）的内存管理机制与 std::vector 不同。std::deque 是一个使用多个固定大小的内存块来存储元素的容器，这些内存块被称为“chunks”或“maps”。\n当 std::deque 需要更多空间时，它可能会在已有的内存块之后添加新的内存块，或者在前面添加，这取决于哪个方向上的空间更紧张。 std::deque 不会像 std::vector 那样将所有元素复制到一个新的连续内存块中，而是在多个内存块之间分配元素。\nstack和queue stack和queue默认使用deque的功能来分别实现先进后出和先进先出的功能，除此之外还可以使用list，stack还可以使用vector，但是deque就不能用vector，以我的理解，是因为vector不提供后端操作。\nRb-tree 在C++中，set和map的底层实现都是基于红黑树（RB-tree）。红黑树是一种自平衡的二叉搜索树，能够保证在最坏情况下，插入、删除和查找操作的时间复杂度均为O(log n)。\ntemplate \u003c int key, int value, identity\u003cint\u003e, less\u003cint\u003e, alloc \u003e class rb_tree;set 和 map 的区别：\nset：set中的元素是唯一的键值，即Key和Value是同一个。插入时使用insert_unique()方法，确保键值不重复。\nmap：map中的元素是键值对（Key-Value），键值用于索引，值表示与索引相关联的数据。插入时使用insert_equal()方法，允许键值重复。\n红黑树的结构：\n红黑树的结构包括节点、根节点、最左节点和最右节点等。根节点通过header.parent保存，最左节点通过header.left保存，最右节点通过header.right保存。\n插入操作 set：插入操作调用insert_unique()，确保键值唯一。 map：插入操作调用insert_equal()，允许键值重复。 迭代器 set：迭代器是RB-tree的const_iterator，不允许修改元素值。 map：迭代器也是RB-tree的const_iterator，但允许修改元素的值（因为值部分不是键）。 set和multiset set与map的底层实现基本可以参考下面的源码图，\n需要说明的一点是，在不允许更改键值上，二者的设计还是有区别，主要体现在set使用const_iterator,这样迭代器指向的键值就无法更改，而map在设计上在传进来的Key设置为const，确保键值不会被更改。\nhashtable-哈希表 在C++中，hash_set、hash_map、hash_multiset和hash_multimap等数据结构的底层实现确实采用了哈希表的思想。具体来说，这些数据结构的设计核心是通过哈希函数将键（key）映射到数组的索引位置，从而实现高效的插入、删除和查找操作。\n数据存储的设计思想 每个键值通过一个哈希函数计算出一个哈希值。这个哈希值通常是一个整数，用于确定键值在数组中的存储位置。例如，对于一个整数键值12，哈希函数可能会直接返回12，这样12就会被存储在数组的第12个位置。\n哈希表的核心是一个数组（通常是一个vector），数组的每个元素（即每个位置）可以存储一个指针。这个指针指向一个单向链表的头节点。如果多个键值通过哈希函数计算出相同的哈希值，它们会被存储在同一个位置的链表中。参考下图： 当多个键值映射到同一个哈希值时，这些键值会被存储在一个链表中。链表的每个节点包含一个键值和指向下一个节点的指针。这种设计允许在发生哈希冲突时，通过遍历链表来查找或插入特定的键值。 为了保持高效的性能，哈希表通常会有一个动态扩容机制。当哈希表中的元素数量超过一定阈值时，哈希表会自动重新分配更大的数组，并重新计算所有键值的哈希值，以减少链表的长度，从而提高查找效率。\n在实际应用中，哈希函数可能会导致不同的键值计算出相同的哈希值，这种现象称为哈希冲突。常见的解决策略包括链地址法（即使用链表存储冲突的元素）和开放地址法（即在数组中寻找下一个空闲位置）。\n具体实现过程 当插入一个新键值时，首先通过哈希函数计算出其哈希值，然后根据哈希值找到对应的数组位置。如果该位置已经有元素（即发生冲突），则将新元素插入到该位置的链表中。 查找操作同样通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，直到找到匹配的键值或链表结束。 删除操作首先通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，找到并删除匹配的键值。 实现代码 hashtable类的实现提供了六个模板参数。\ntemplate \u003cclass value, class key, class hashFcn,//计算编号 class extractKey,//取出键值 class EqualKey,//判断类型是否相等 class Alloc=alloc \u003e 如果要自己使用这个哈希表，需要写hashFcn()的重载，对齐进行偏特化等操作,如下图： 如果传入的是字符串，那么字符串的编号计算可以参考下图计算方法： 附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "8.STL库学习之容器",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件 ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "7.STL库学习之分配器",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "STL程序源代码位置 了解自身编译器STL程序源代码位置。\nOOP 与 GP 面向对象编程（OOP）：\n面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。\n补充说明：OOP 通过类（Class）来定义对象的蓝图，支持继承、封装和多态等特性，从而提高代码的重用性和灵活性。例如list中有自己的sort()函数，专门为list而设计，比::sort()的算法更优。\n泛型编程（GP）：\n泛型编程是一种编程范式，它允许开发者定义操作类型数据结构的函数和类，而不需要在编译时指定具体的数据类型。这种方法强调了数据和处理方法的分离，提供了更高的代码复用性和类型安全性。\n补充说明：GP 通过模板（Templates）或泛型容器（如 std::vector、std::map）来实现，允许开发者写出与数据类型无关的代码，从而在不同的数据类型间共享相同的算法逻辑。例如vector和deque没有为自身设计sort(),在做排序操作时，需要调用::sort()来实现。\n操作符重载 STL源码程序中会包含很多的操作符重载，一般你会看到operate修饰符，后面就紧跟着操作符。注意：::、.、.*和 :?不能进行操作符重载。\n在我看来操作符重载是一个重要的特性，它可以让你实现任何类的运算法则，这些法则有你自己规定，操作空间还是比较宽泛。\n模版-template 最常见的写法如下：\ntemplate \u003ctypename T\u003e class FOO{ ... }类模板 最常见的写法如下：\ntemplate \u003cclass T\u003e class FOO{ ... }成员模版 泛化、特化和偏特化 以我个人的理解，泛化是为了应对大部分的情况，特化是为了应对特殊的情况，或使用单独的方法处理对某些情况而言更好，偏特化比偏特化更近一步，把处理的手段限定在一定范围内，举个简单的例子，假设为设计计算两种情况的相加做如下定义：\n1.泛化\n泛化编程在C++中通过模板实现。以下是一个泛化编程的示例，其中 AND 类是一个模板类，可以处理任何类型的数据。\ntemplate \u003cclass T,class U\u003e class AND{ ... }2.特化\n特化是对模板类或函数的特定实例化。以下是特化的示例，其中 AND 类被特化为处理 string 和 Text 类型：\ntemplate \u003cclass T, class U\u003e class AND { // ... 类的泛型实现 }; template \u003c\u003e class AND\u003cstring, Text\u003e { // ... 类的特化实现 };3.偏特化\n偏特化允许对模板类的部分参数进行特化。以下是偏特化的示例，其中 AND 类被偏特化为处理第一个类型为 int 的情况：\ntemplate \u003cclass T, class U\u003e class AND { // ... 类的泛型实现 }; template \u003cclass U\u003e class AND\u003cint, U\u003e { // ... 类的偏特化实现 }; 附件 ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "6.STL库学习之筑基概要",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/6.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AD%91%E5%9F%BA%E6%A6%82%E8%A6%81/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数据 分配器-Allocators，配合容器分配内存 算法- Algorithms，处理某一数据的最优办法 迭代器- Iterators，指针的泛型，本质与指针类似 适配器- Adapters， 仿函数-Functors，类似函数。 六者的关系\nbegin()和end() 以迭代器为例，begin()指向迭代器的首地址，而end()指向迭代器尾地址的下一位，可以用前闭后开区间来表示，即**[ )**\n容器的分类 数组容器的使用 array 的使用 示例1 .h文件 testCode 结果 #ifndef __AUXFUN__ #define __AUXFUN__ #include \u003ciostream\u003e #include \u003cstring\u003e #define RAMD_MAX 32767 using namespace std; long get_a_target_long() { long target = 0; cout \u003c\u003c \"target (0--\" \u003c\u003c RAMD_MAX \u003c\u003c \"):\"; cin \u003e\u003e target; return target; } //将数值转为string，这样可以测试类似object的情况 string get_a_target_string() { long target = 0; char buf[10]; cout \u003c\u003c \"target (0--\" \u003c\u003c RAMD_MAX \u003c\u003c \"):\"; cin \u003e\u003e target; snprintf(buf, 10, \"%d\", target); return string(buf); } int compareLongs(const void* a, const void* b) { return (*(long*)a - *(long*)b); /* 1.类型转换：因为参数是const void* 类型，你需要将它们转换为具体的数据类型指针（在这个例子中是long* ），以便可以解引用并获取它们的值。 2.解引用：在转换之后，通过在类型转换的结果前使用* 操作符来获取指针指向的实际值。 3.强制转换的结果：* (long*)a实际上是一个long值，它是通过解引用转换后的指针得到的。*/ } int compareString(const void* a, const void* b) { if (*(long*)a \u003e *(long*)b) return 1; else if (*(long*)a \u003c *(long*)b) return -1; else return 0; } #endif // !__ENTRY__ #include \"TestHeardFiles/AuxFun.h\" #include \u003cctime\u003e #include \u003ccstdlib\u003e//qsort()、 bsearch()、 NULL #include \u003carray\u003e const size_t ASIZE = 50000; namespace t01 { void test_array() { cout \u003c\u003c \"\\ntest_array().............. \\n\"; array\u003clong, ASIZE\u003e c;//使用数组容器 clock_t timeStart = clock(); for (long i = 0; i \u003c ASIZE; ++i) { c[i] = rand();//可以产生随机数的函数 } cout \u003c\u003c \"milli_seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"array.size(): \" \u003c\u003c c.size() \u003c\u003c endl;//返回数组大小 cout \u003c\u003c \"array.back(): \" \u003c\u003c c.back() \u003c\u003c endl;//返回数组最后一个数 cout \u003c\u003c \"array.data: \" \u003c\u003c c.data() \u003c\u003c endl;//返回第一个数的地址 long target = get_a_target_long(); timeStart = clock();//clock()返回毫秒数 qsort(c.data(), ASIZE, sizeof(long), compareLongs);//数组排序 long* pItem = (long*)bsearch(\u0026target, (c.data()), ASIZE, sizeof(long), compareLongs);//数组查找 cout \u003c\u003c \"qsort()+bsearch(),milli-seconds:\" \u003c\u003c clock() - timeStart \u003c\u003c endl; if (pItem != NULL) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"Not found!\" \u003c\u003c endl; } } int main() { t01::test_array(); } vector 的使用 vector是一种向后自动以2次方增加的内存的容器，一般使用push_back向后添加数据；\nvector也有一定的缺点，假设我只需要5个内存空间，但是vector分配的是8个，剩下的3个后面如果不使用就会浪费。\n示例2 代码 结果 #include \u003cvector\u003e #include \u003cstdexcept\u003e //obort() #include \u003ccstdio\u003e\t//snprintf() #include \u003calgorithm\u003e//sort() namespace t02 { void test_vector(long\u0026 value) { cout \u003c\u003c \"\\ntest_vector()..............\\n\"; vector\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性 //同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"vector.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"vector.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"vector.back(): \" \u003c\u003c c.back() \u003c\u003c endl; cout \u003c\u003c \"vector.data(): \" \u003c\u003c c.data() \u003c\u003c endl; cout \u003c\u003c \"vector.capacity(): \" \u003c\u003c c.capacity() \u003c\u003c endl;//返回的是向量当前分配的存储空间可以容纳的元素个数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //进行排序后使用bsearch查找。 { timeStart = clock(); sort(c.begin(), c.end());//该算法将任何类型进行排序，需要提供相应的比较函数 string* pItem = (string*)bsearch(\u0026target, (c.data()), c.size(), sizeof(string), compareString); cout \u003c\u003c \"sort()+bsearch(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != NULL) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } } } 从上面的结果来看，排序后使用二分查找反而比循环查找慢，原因在于排序话费了很多时间，因为string类型是一个object，其本身大小比较大，所以面对一个object进行查找时不建议使用排序后二分查找。\n在实际应用中，选择排序加二分查找还是直接线性查找，需要根据具体情况来决定：\n如果容器已经排序，或者数据量不大，直接使用二分查找可能更简单、更快。 如果容器未排序，且数据量很大，那么可能需要考虑是否值得为了一次查找而进行排序，或者是否可以通过其他方式（如使用更高效的数据结构，如哈希表）来提高查找效率。 如果查找操作非常频繁，而插入和删除操作不频繁，那么维护一个已排序的容器可能是合理的，这样每次查找都可以利用二分查找的效率。 总之，选择哪种方法取决于具体的应用场景和性能要求。在某些情况下，可能需要通过实验或性能分析来确定最佳的策略。\n链表容器-list std::list 是 C++ 标准库中的一个容器，它提供了双向链表的实现。\nstd::list 容器的特点：\n双向链表结构：std::list 由一系列节点组成，每个节点包含一个元素和两个指针，分别指向前一个节点和后一个节点。 动态内存分配：std::list 中的每个节点都是独立分配内存的。这意味着当你添加或删除元素时，std::list 会为新元素分配内存，或释放不再使用的元素所占用的内存。 内存空间利用：由于 std::list 的元素是单独分配的，因此不存在像 std::vector 那样的连续内存块，也就不会有额外的内存浪费。每个元素恰好占用它所需的空间，加上一些指针存储开销。 查询操作效率：\n查询效率较低：与 std::vector 或 std::array 这样的随机访问容器相比，std::list 的查询操作通常较慢。这是因为 std::list 没有提供快速的随机访问能力。 顺序访问：在 std::list 中，要访问一个特定位置的元素，你需要从头开始遍历，直到到达那个位置。这意味着访问时间与列表的大小成正比，最坏情况下的时间复杂度为 O(n)。 没有跳跃访问：与数组或 std::vector 不同，std::list 没有提供直接跳到任意位置的能力。在数组中，你可以通过简单的指针算术来访问任意位置的元素，而在 std::list 中，你必须遍历链表。 测试代码：\n示例3 代码 结果 #include \u003clist\u003e namespace t03 { void test_list(long\u0026 value) { cout \u003c\u003c \"\\ntest_list()..............\\n\"; list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性 //同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"list.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"list.back(): \" \u003c\u003c c.back() \u003c\u003c endl; string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } } How much memory space you need: 1000000 test_list().............. milli-seconds: 1073 list.size(): 1000000 list.max_size(): 329406144173384850 list.front(): 41 list.back(): 12679 target (0--32767):12345 ::find(),milli-seconds: 4 found,12345 list.sort(),milli-seconds: 1611 总结： std::list 的优点在于它的灵活性和高效的插入/删除操作，这些操作可以在 O(1) 时间内完成，因为它们只需要修改几个指针。然而，这种灵活性的代价是牺牲了快速随机访问的能力。因此，如果你的应用场景中需要频繁地在序列中间插入或删除元素，而不太关心随机访问性能，std::list 是一个很好的选择。反之，如果随机访问是一个关键操作，那么可能需要考虑使用其他类型的容器。\n链表容器-forward_list std::forward_list 是 C++ 标准库中的一个容器，它提供了单向链表的实现。\nstd::forward_list 容器的特点：\n单向链表结构：std::forward_list 由一系列节点组成，每个节点包含一个元素和一个指向下一个节点的指针。 内存分配：与 std::list 类似，std::forward_list 的元素也是动态分配内存的。但是，由于它是单向链表，所以只能从链表的前端（头部）开始进行内存分配。 操作限制：由于 std::forward_list 的单向特性，它只提供了 push_front() 和 pop_front() 操作来在链表的前端添加或删除元素。不支持快速的随机访问，也不支持在链表的中间或末尾进行插入和删除操作。 内存使用效率：\n无尾插法：std::forward_list 没有 push_back() 方法，只能使用 push_front() 在链表的头部插入元素。这意味着，如果你需要在链表的末尾添加元素，你将不得不遍历整个链表以到达末尾，这在大型数据集中可能效率较低。 节省空间：与 std::list 相比，std::forward_list 每个节点只需要存储一个指向下一个节点的指针，因此它的内存开销比 std::list 小。 适用场景：\n空间敏感的应用：如果你的应用对内存使用非常敏感，且需要从链表的前端进行频繁的插入和删除操作，std::forward_list 是一个不错的选择。 单向遍历：如果你的应用只需要从链表的前端开始遍历元素，那么 std::forward_list 可以提供良好的性能。 测试代码\n示例3 代码 结果 #include \u003cforward_list\u003e namespace t04 { void test_forward_list(long\u0026 value) { cout \u003c\u003c \"\\nforward_list()..............\\n\"; forward_list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_front(string(buf));//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back() } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"forward_list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"forward_list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; //cout \u003c\u003c \"forward_list.back(): \" \u003c\u003c c.back() \u003c\u003c endl;\t没有该函数 //cout \u003c\u003c \"forward_list.size(): \" \u003c\u003c c.size() \u003c\u003c endl;\t没有该函数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"forward_list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } } How much memory space you need: 1000000 forward_list().............. milli-seconds: 965 forward_list.max_size(): 384307168202282325 forward_list.front(): 12679 target (0--32767):12345 ::find(),milli-seconds: 3 found,12345 forward_list.sort(),milli-seconds: 1595 值得注意的是： std::forward_list 专为高效的前端插入和删除操作设计，std::forward_list 没有 push_back() 是因为它是单向链表， 只能高效地从前面操作。它没有 size() 函数，因为计算链表长度需要遍历整个链表，这与它优化前端操作的设计目标不符。\n总结：\nstd::forward_list 是一个轻量级的容器，它在内存使用上比 std::list 更为高效，但在功能上也更为有限。它适合于那些只需要单向遍历和操作的场景。由于其单向链表的特性，std::forward_list 在进行元素插入和删除时，只能从链表的前端进行，这限制了它的使用场景。在选择 std::forward_list 时，需要根据应用的具体需求来权衡其优势和局限性。\n链表容器-slist slist容器与forward_list容器一样，只是slis容器存在于ext\\slist头文件中。\n测试代码：\n示例3 代码 结果 #include \u003cforward_list\u003e namespace t04 { void test_forward_list(long\u0026 value) { cout \u003c\u003c \"\\nforward_list()..............\\n\"; forward_list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_front(string(buf));//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back() } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"forward_list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"forward_list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; //cout \u003c\u003c \"forward_list.back(): \" \u003c\u003c c.back() \u003c\u003c endl;\t没有该函数 //cout \u003c\u003c \"forward_list.size(): \" \u003c\u003c c.size() \u003c\u003c endl;\t没有该函数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"forward_list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } } How much memory space you need: 1000000 forward_list().............. milli-seconds: 965 forward_list.max_size(): 384307168202282325 forward_list.front(): 12679 target (0--32767):12345 ::find(),milli-seconds: 3 found,12345 forward_list.sort(),milli-seconds: 1595 双向容器-deque std::deque（双端队列）是一种容器，它允许在序列的前端和后端快速插入和删除元素。尽管从概念图上看， std::deque 似乎是一个连续的存储空间，但实际上它并不是连续的。std::deque 的实现通常是由一个或多个固定大小的连续内存块 （通常称为“节点”或“块”）组成的，这些块通过指针连接在一起。\n以下是对您提供内容的整理：\n存储机制：std::deque 由多个指针组成，每个指针指向一个具有一定容量的连续内存块。这些内存块被组织在一起，形成一个能够从两端快速增长的容器。 内存管理：当 std::deque 中的一个内存块满了，需要更多的空间时，它会“自动跳转”到下一个空闲的内存块的开始位置。如果所有现有的内存块都已满，std::deque 会分配一个新的内存块，并更新指针以指向这个新的块。 内存效率：使用固定容量的内存块可以减少内存浪费。例如，如果每个内存块的大小为8个元素，那么即使只存储一个元素，也只会浪费7个元素的空间（因为第一个块始终被使用）。这与 std::vector 相比，后者可能会因为频繁的内存重新分配而导致更多的内存浪费。 动态增长：当 std::deque 需要更多内存时，它会动态地增加新的内存块。这种设计使得 std::deque 能够在不牺牲太多内存的情况下，提供快速的插入和删除操作。 连续性：尽管 std::deque 在内部不是完全连续的，但它提供了随机访问的能力，这意味着你可以像访问 std::vector 或数组一样，通过索引来访问 std::deque 中的任何元素。 总的来说，std::deque 是一个灵活且高效的容器，适用于需要在序列的两端进行频繁插入和删除操作的场景。它的设计既考虑了性能， 也考虑了内存使用效率。\n测试代码：\n示例3 代码 结果 #include \u003cdeque\u003e namespace t05 { void test_deque(long\u0026 value) { cout \u003c\u003c \"\\ntest_deque()..............\\n\"; deque\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"deque.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"deque.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"deque.back(): \" \u003c\u003c c.back() \u003c\u003c endl; cout \u003c\u003c \"deque.size(): \" \u003c\u003c c.size() \u003c\u003c endl; string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); sort(c.begin(), c.end());//使用全局的sort,deque没有自己的sort。 cout \u003c\u003c \"deque.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } } How much memory space you need: 1000000 test_deque().............. milli-seconds: 1055 deque.max_size(): 461168601842738790 deque.front(): 41 deque.back(): 12679 deque.size(): 1000000 target (0--32767):12345 ::find(),milli-seconds: 4 found,12345 deque.sort(),milli-seconds: 3838 特殊容器-stack和queue std::stack（栈） 定义：\nstd::stack 是一个遵循后进先出（LIFO，Last In First Out）原则的容器适配器。它只能在序列的一端（栈顶）进行添加（push）和移除（pop）操作。\n主要操作：\npush()：在栈顶添加一个元素。 pop()：移除栈顶元素。 top()：返回栈顶元素的引用，不移除它。 特点：\n只能单端操作，即只能在栈顶进行操作。 没有提供直接的迭代器支持，但提供了 top() 方法来访问栈顶元素。 std::queue（队列） 定义：\nstd::queue 是一个遵循先进先出（FIFO，First In First Out）原则的容器适配器。它只能在序列的一端（队尾）进行添加（push）操作，在另一端（队首）进行移除（pop）操作。\n主要操作：\npush()：在队尾添加一个元素。 pop()：移除队首元素。 front()：返回队首元素的引用，不移除它。 back()：返回队尾元素的引用，不移除它。 特点：\n双端操作，即在队首进行移除操作，在队尾进行添加操作。 提供了迭代器支持，允许遍历队列中的所有元素。 与 std::deque 的不同.\n操作限制：std::stack 和 std::queue 限制了操作的位置，而 std::deque 允许在两端自由操作。 迭代器支持：std::stack 不支持迭代器，std::queue 支持迭代器但只能访问队列中的元素，而 std::deque 提供了随机访问迭代器，可以高效地访问序列中的任何位置。 使用场景：如果你需要一个简单的后进先出或先进先出的数据结构，std::stack 或 std::queue 可能更适合。如果你需要一个能够在两端快速操作且支持随机访问的容器，std::deque 是更好的选择。 测试代码：\n示例4 stack代码 queue代码 结果 #include \u003cstack\u003e namespace t06 { void test_stack(long\u0026 value) { cout \u003c\u003c \"\\ntest_stack()..............\\n\"; stack \u003cstring\u003e c;//stack又叫栈，特点是先进后出 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push(string(buf));//将随机数转为string类型，并使用push()将数据压入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"stack.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"stack.top(): \" \u003c\u003c c.top() \u003c\u003c endl; c.pop(); cout \u003c\u003c \"stack.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"stack.top(): \" \u003c\u003c c.top() \u003c\u003c endl; //与前面的容器不同，stack不可以进行查找操作 } } #include \u003cqueue\u003e namespace t07 { void test_queue(long\u0026 value) { cout \u003c\u003c \"\\ntest_queue()..............\\n\"; queue \u003cstring\u003e c;//queue又叫队列，特点是先进先出 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push(string(buf));//将随机数转为string类型，并使用push()将数据压入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"queue.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"queue.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"queue.back(): \" \u003c\u003c c.back() \u003c\u003c endl; c.pop(); cout \u003c\u003c \"queue.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"queue.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"queue.back(): \" \u003c\u003c c.back() \u003c\u003c endl; //与前面的容器不同，queue也不提供查找操作 } } How much memory space you need: 1000000 test_stack().............. milli-seconds: 1050 stack.size(): 1000000 stack.top(): 12679 stack.size(): 999999 stack.top(): 17172 test_queue().............. milli-seconds: 1027 queue.size(): 1000000 queue.front(): 21384 queue.back(): 1461 queue.size(): 999999 queue.front(): 10793 queue.back(): 1461 红黑树-multiset容器 multiset容器结构类似二叉树，准确说是红黑树，这种结构的的查找会快很多，但是插入则会耗费一定时间，这些时间都花费在了排序上。\n测试代码：\n示例8 multiset代码 multimap代码 结果 #include \u003cset\u003e namespace t08 { void test_multiset(long\u0026 value) { cout \u003c\u003c \"\\ntest_multiset()..............\\n\"; multiset \u003cstring\u003e c;//multiset结构式红黑树 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf));//将随机数转为string类型，并使用insert()将数据存入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"multiset.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"multiset.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//使用全局::fingd()查找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } { timeStart = clock(); auto pItem = c.find(target);//使用multiset自身的fingd()查找 cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } } #include \u003cmap\u003e namespace t09 { void test_multimap(long\u0026 value) { cout \u003c\u003c \"\\ntest_multimap()..............\\n\"; multimap \u003clong,string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(pair\u003clong,string\u003e(i,buf));//此处使用了pair设置键值对 //值得注意，multimap不可以用[]做insert，这一点可以结合map容器理解, //另外key是不会重复的，因为接收的是0-1000000，而值可能会重复，因为值是通过随机数函数rand()产生，范围为0-32767 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"multimap.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"multimap.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, (\" \u003c\u003c (*pItem).first \u003c\u003c\", \" \u003c\u003cpItem-\u003esecond\u003c\u003c\")\" \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } How much memory space you need: 1000000 test_multiset().............. milli-seconds: 3235 multiset.size(): 1000000 multiset.max_size(): 256204778801521550 target (0--32767):23456 ::find(),milli-seconds: 59 found, 23456 c.find(),milli-seconds: 0 found, 23456 test_multimap().............. milli-seconds: 1843 multimap.size(): 1000000 multimap.max_size(): 230584300921369395 target (0--32767):23456 c.find(),milli-seconds: 1 found, (23456, 31622) 从测试结果看，因为不会抛弃重复的值，multiset的元素个数与大小相等，且存值会话费很多时间。 相比之下multimap存值时间会话费少一些。\nunordered_multiset和unordered_multimap std::unordered_map 和 std::unordered_set 是 C++ 标准库中的两种容器，它们基于哈希表实现。这两种容器提供平均时间复杂度为 O(1) 的快速访问，插入和删除操作。下面简单解释它们的概念图，包括桶和负载因子的说明。\n概念图简述：\n桶（Buckets）：\n在 std::unordered_map 和 std::unordered_set 中，哈希表被分为多个“桶”。 每个桶存储指向一个链表的指针（在 std::unordered_map 的情况下）或直接存储元素（在 std::unordered_set 的情况下）。 当元素被插入时，它们的哈希值决定了它们将被存储在哪个桶中。\n链表（Chaining）：\n如果多个元素具有相同的哈希值（哈希冲突），它们将被存储在同一个桶中，并通过链表连接起来。 在 std::unordered_map 中，每个桶可能包含一个链表，链表中的每个节点存储一个键值对。 在 std::unordered_set 中，每个桶可能包含一个链表，链表中的每个节点存储一个元素。\n负载因子（Load Factor）：\n负载因子是哈希表中已存储元素数量与桶数量的比率。 负载因子影响哈希表的性能。较高的负载因子可能导致更多的哈希冲突，从而增加链表的长度，降低性能。 当负载因子超过一个预设的最大值时，哈希表可能会进行重新哈希（rehashing），即增加桶的数量并重新分配所有元素到新的桶中。\n概念图说明：\n桶：哈希表被分为多个桶，每个桶可以存储一个链表的头部指针。 指针：在 std::unordered_map 中，每个指针指向一个链表节点，该节点包含一个键值对。在 std::unordered_set 中，每个指针直接指向存储的元素。 元素：链表中的元素，可能是键值对或单个值。 负载因子说明：\n重新哈希（Rehashing）：当负载因子超过 max_load_factor() 时，哈希表会进行重新哈希，增加桶的数量，并将所有元素重新分配到新的桶中。 动态调整：这种动态调整机制使得 std::unordered_map 和 std::unordered_set 能够根据元素数量的变化自动调整大小，以保持操作的性能。 通过这种结构，std::unordered_map 和 std::unordered_set 能够在大多数情况下提供快速的访问和修改操作，但需要注意，极端情况下（如所有元素哈希到同一个桶中）性能可能会退化到 O(n)。\n测试代码：\n示例9 unordere_multiset代码 unordere_multiset结果 unordere_multimap代码 unordere_multimap结果 #include \u003cunordered_set\u003e namespace t10 { void test_unordered_multiset(long\u0026 value) { cout \u003c\u003c \"\\ntest_unordered_multiset()..............\\n\"; unordered_multiset \u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf));//将随机数转为string类型，并使用insert()将数据存入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"unordered_multiset.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl;// 打印 unordered_multiset 能存储的最大元素数量 cout \u003c\u003c \"unordered_multiset.bucket_count(): \" \u003c\u003c c.bucket_count() \u003c\u003c endl;// 打印 unordered_multiset 中桶的数量，即存储指向一定长度链表的指针的个数 cout \u003c\u003c \"unordered_multiset.max_load_factor(): \" \u003c\u003c c.max_load_factor() \u003c\u003c endl;// 打印 unordered_multiset 可以使用的最大负载因子，它影响桶中链表的最大长度 cout \u003c\u003c \"unordered_multiset.max_bucket_count(): \" \u003c\u003c c.max_bucket_count() \u003c\u003c endl;// 打印 unordered_multiset 可以使用的最大桶的数量，这个值通常由桶的增长策略和哈希表的容量决定 for (unsigned i = 0; i \u003c 20; i++) { cout \u003c\u003c \"bucket # \" \u003c\u003c i \u003c\u003c \" has \" \u003c\u003c c.bucket_size(i) \u003c\u003c \" element.\\n\"; } string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//使用全局::fingd()查找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } { timeStart = clock(); auto pItem = c.find(target);//使用multiset自身的fingd()查找 cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } } How much memory space you need: 1000000 test_unordered_multiset().............. milli-seconds: 1867 unordered_multiset.max_size(): 329406144173384850 unordered_multiset.bucket_count(): 1048576 unordered_multiset.max_load_factor(): 1 unordered_multiset.max_bucket_count(): 1152921504606846975 bucket # 0 has 0 element. bucket # 1 has 0 element. bucket # 2 has 0 element. bucket # 3 has 0 element. bucket # 4 has 0 element. bucket # 5 has 0 element. bucket # 6 has 0 element. bucket # 7 has 0 element. bucket # 8 has 0 element. bucket # 9 has 0 element. bucket # 10 has 0 element. bucket # 11 has 0 element. bucket # 12 has 0 element. bucket # 13 has 0 element. bucket # 14 has 0 element. bucket # 15 has 0 element. bucket # 16 has 0 element. bucket # 17 has 0 element. bucket # 18 has 0 element. bucket # 19 has 0 element. target (0--32767):12345 ::find(),milli-seconds: 108 found, 12345 c.find(),milli-seconds: 0 found, 12345 #include \u003cunordered_map\u003e namespace t11 { void test_unordered_multimap(long\u0026 value) { cout \u003c\u003c \"\\ntest_unordered_multimap()..............\\n\"; multimap \u003clong, string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(pair\u003clong, string\u003e(i, buf)); } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"unordered_multimap.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"unordered_multimap.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, (\" \u003c\u003c (*pItem).first \u003c\u003c \", \" \u003c\u003c pItem-\u003esecond \u003c\u003c \")\" \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } How much memory space you need: 1000000 test_unordered_multimap().............. milli-seconds: 1942 unordered_multimap.size(): 1000000 unordered_multimap.max_size(): 230584300921369395 target (0--32767):12345 c.find(),milli-seconds: 0 found, (12345, 5839) set和map容器 测试代码：\n示例10 set map 结果 namespace t12 { void test_set(long\u0026 value){ cout \u003c\u003c \"\\ntest-set()............................\\n\" \u003c\u003c endl; set\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf)); } catch (exception\u0026 p) { cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c p.what() \u003c\u003c endl; abort(); } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"set.max_size() \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"set.size() \" \u003c\u003c c.size() \u003c\u003c endl; string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target); cout \u003c\u003c \"::find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"not fount!\" \u003c\u003c endl; } { timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"not fount!\" \u003c\u003c endl; } } } namespace t13 { void test_map(long\u0026 value) { cout \u003c\u003c \"\\ntest_map()............................\\n\" \u003c\u003c endl; map\u003clong,string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c[i] = string(buf);//注意这种使用方式 } catch (exception\u0026 p) { cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c p.what() \u003c\u003c endl; abort(); } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"map.max_size() \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"map.size() \" \u003c\u003c c.size() \u003c\u003c endl; long target = get_a_target_long(); { timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"::find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found value, \" \u003c\u003c pItem-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"not fount value!\" \u003c\u003c endl; } } } How much memory space you need: 1000000 test-set()............................ milli-seconds: 2133 set.max_size() 256204778801521550 set.size() 32768 target (0--32767):12345 ::find(), milli-seconds: 1 found, 12345 find(), milli-seconds: 0 found, 12345 test_map()............................ milli-seconds: 1937 map.max_size() 230584300921369395 map.size() 1000000 target (0--32767):12345 ::find(), milli-seconds: 0 found value, 5839 分配器测试程序 附件 ",
    "description": "",
    "tags": [
      "C++",
      "STL库"
    ],
    "title": "5.STL库之观其大略",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: STL库",
    "uri": "/tags/stl%E5%BA%93/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主虽然天资聪颖，但今日却显得心不在焉，她的目光不时飘向窗外的花园，那里的蝴蝶正在花间翩翩起舞。\r太傅李大人轻声咳嗽，试图引起公主的注意，但柒公主却只是懒洋洋地翻了一页书，完全没有将心思放在学习上。李大人心中微微叹息，他知道这位公主自小受到皇上的宠爱，性格难免有些任性。他决定采取一些措施，于是他从桌上拿起了一根精致的戒尺。\n“公主殿下，”李大人的声音温和而坚定，“学习之道，贵在专注。今日若不专心，恐怕难以领悟圣人之言。”\n柒公主抬头，眼中闪过一丝不满，但还没等她反驳，戒尺已经轻轻地落在了她的手心。虽然力道不大，但足以让公主感到一丝疼痛。她惊讶地看着太傅，随即眼眶一红，泪水开始在眼眶中打转。\n就在这时，皇上恰好路过御书房，听到了公主的哭声。他急忙推门而入，看到这一幕，眉头紧锁。皇上推开了一旁的内侍，快步走到公主身边，轻声安慰。\n“是谁如此大胆，竟敢对朕的女儿动手？”皇上的声音中带着一丝怒气。\n内侍们吓得纷纷跪地，太傅李大人也急忙跪下，低声说道：“陛下，臣有罪。”\n皇上转头看向太傅，眼中闪过一丝复杂。他知道李大人是位尽职尽责的太傅，但看到女儿受委屈，心中难免有些不忍。他轻轻拍了拍公主的背，然后示意内侍将她送回寝宫。\n待公主离开后，皇上坐在了御书房的椅子上，示意太傅起身。他的声音平静，但带着一丝不容置疑的威严：“李爱卿，你有何解释？”\n太傅李大人站起身，他的额头上已经渗出了细密的汗珠。他知道，自己的举动可能会触怒皇上，但他坚信这是为了公主好。他深吸了一口气，然后缓缓开口：“陛下，臣此举虽有失礼之嫌，但实在是出于对公主学业的关心。”\n皇上微微点头，他知道李大人的忠心，但他也需要考虑到皇室的颜面。他沉思了片刻，然后说道：“李爱卿，朕知道你是出于好意，但公主毕竟是皇室中人，她的身份不容有失。今后，你还是要注意方式方法。”\n太傅李大人急忙应道：“陛下英明，臣铭记在心。”\n皇上挥了挥手，让太傅退下。他独自一人坐在御书房中，目光落在了窗外的花园上。他知道，在这个动荡的时代，皇室的每一个成员都必须更加小心谨慎。他决定过几天再去看望柒公主，亲自教导她一些治国之道。\n内侍们轻手轻脚地收拾着御书房，没有人敢打扰皇上的沉思。阳光渐渐西斜，御书房内弥漫着一种宁静而深沉的气氛。\n",
    "description": "",
    "tags": [
      ""
    ],
    "title": "8.桑叶白鸟卷",
    "uri": "/textbook/8.%E6%A1%91%E5%8F%B6%E7%99%BD%E9%B8%9F%E5%8D%B7/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "VS 2022的设置 首先你可以先用下面的代码测试使用可以执行：\n#include \u003ciostream\u003e void printTypes() { } template \u003ctypename T, typename... U\u003e void printTypes(const T\u0026 t, const U\u0026... u) { std::cout \u003c\u003c t \u003c\u003c std::endl; printTypes(u...); } int main() { printTypes('a', 1.5, 'b'); }如果报错了，如typename…未定义，那么请你按照如下步骤操作， C++语言标准选择预览 - 最新 C++ 工作草案中的功能 (/std:c++latest) 启用实验性C++标准库模块–是 生成ISO C++23标准库模块 – 是 const补充 const 参数 non-const 参数 const 函数 可执行 可执行 non-const 函数 报错 可执行 使用const需要注意两个问题，参数是否需要修改，参数进入函数内后数据是都会修改。解决这两个问题，在需要的地方加上const\n还有一种情况，\ntemplate\u003ctypename T\u003e class foo { public: T fooTo(T str) const { return str; }; T fooTo(T str) {return str;}; }; int main() { foo \u003c char \u003e f; const char x = 'a'; char y = 'c'; std::cout \u003c\u003c f.fooTo(x) \u003c\u003c std::endl; std::cout \u003c\u003c f.fooTo(y) \u003c\u003c std::endl; }运行结果如下: 在这个例子中，带const的参数只会执行带const的函数，而不带const的参数会只会执行不带const的函数，这就是带const和不带const函数出现时的情况。 但是这个结果我并不是很满意，应为我试着在不带const函数内部修改传入的参数，代码执行时将不会以我上面说的结论出现。或许还需要在研究研究……\n附件 ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "4.C++2.0特性的使用",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard library》 《STL C++》 《STL源码剖析》 《算法+数据结构=程序》 “网站CPLusPlus” “网站CppReference” “网站gcc.gnu” 学习路线 慕课C++学习 练习网站 conversion function-转换函数 接下来以一个分数的代码例子说明转换函数。\n情况1：让值转为其他类型\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } }; //使用示例： Fraction f(2,5); double d = 4+f;在上述的示例中，d = 4+f;程序会先判断有没有写opertaor +，如果没有会试着将f通过opertaor double()转为double类型。\n情况2：non-explicit-one-argument-ctor，不带explicit的一个参数的构造函数，将其他类型转为预所写类的类型\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } }; //使用示例： Fraction f1(2,5); Fraction f2 = 4+f1;同样在这个地方会先将4转为Fraction，然后在进行相加，转换函数使用的是构造函数，构造函数默认第二个参数是1，也就一个参数时也可用，但这个意思并不是说f1(2)你不写第二个参数。\n虽然向上面的情况可行，但是当你把两个情况结合在一起时，就会报错，例如你如下写：\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } Fraction operator + (const Fraction\u0026 f){ return Fraction(……); } };情况3：explicit-one-argument-ctor，带explicit的一个参数的构造函数 这个时候再使用刚才的例子，程序就会报错，因为此时是两种情况的结合，意味着两种情况都可以实现，编译器此时就不知道该使用哪个方法，为了解决这个问题，你可以使用关键字explicit来约束构造函数，让其他类型如法转为所写类，这个时候编译器会报错说无法将double类型转为Fraction。如下：\nclass Fraction { private: int m_num, m_den; public: explicit Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } Fraction operator + (const Fraction\u0026 f){ return Fraction(……); } }; //示例 Fraction f1(2,5); Fraction f2 = 4+f1;编写的类大两个大方向 智能指针 伪函数 这样的类会像函数一样接收参数，返回某一类型的值通常会看到类中重载operate() (……){……}函数。\n特化 偏特化–对应泛化 个数上的偏 以我的理解就是假设原先设计的模版为\ntemplate \u003ctypename a, typename b……\u003e class A {……}现在我使用偏特化，写为\ntemplate \u003ctypename b\u003e class A\u003cbool, typename b……\u003e {……}也就是第一个参数已经确定是bool类型了。（大概先这么理解吧:smile: :smile: :smile:）\n范围上的偏特化 一般我们的类模版你可以任意指定类型，但是现在我想写一个用指针指向的类模板，那么他就被限制在一定的范围内了\ntemplate \u003ctypename a\u003e class A {……} //范围偏特化 template \u003ctypename a\u003e class A\u003ctypename* a\u003e {……}模板模板类 假设我要创建一个容器，并指定这个容器内容的类型，这个时候可以使用模版模版类，详细看下图： 附件 Fraction.hpp (355 B) ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "3.导读",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系\ndelegation-委托 当一个类欲用一个指针指向另一个类，以达到想使用时就指向这个类的这种关系就叫delegation，假设我要实现一个计算，此时指针指向这个函数，让函数去做这个计算。这有些类似于复合，但是这里重点在于指针的使用。在写一些功能的时候也建议使用这种关系的特性，因为这样就将两者隔开，起到一定的保护作用。参考下图： Inheritance-继承 在C++有三种继承方式，其中public是常用的一种，继承表示从一个类中集成某些属性成为 另外一种 类。\nInheritance关系的两个类它们的构造函数与析构函数执行次序与之前描述复合时一样。如下图是这种关系的表示方法： 构造函数（constructor）：由内到外，代码表示为SunFunction::SunFunction(…):base(){…}; 析构函数（destructor）：由外到内，代码表示为SunFunction::SunFunction(…){……~base();}; 值得注意的是，如果一个类将来可能是父类，那么需要在析构函数前加virtual关键字，否则会报错undefine behavior。\n设计模式 **参考书籍：**Design PatternsExplained Simply\n附件 ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "2.组合与继承",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 18.C++编程语言",
    "content": "如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };构造函数的特性 这一点需要关注下面的代码：\ncomplex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {};关于const修饰符 如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。\nconst的使用 加const 不加const double read () const {return re;} double imag () const {return im;}此时做如下两种使用都是正确的\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl; const complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl; double read () {return re;} double imag () {return im;}此时做如下两种使用只有第一种可以被执行，第二种会报错。\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl; const complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl; 函数传递和返回值的两种方式 pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。\npass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节， 在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加\nvoid re(const classname\u0026 cl){};//加了const void re(classname cl){};//没有加const 对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？\n在设计类中的函数时，可以先考虑返回类型适不适合引用,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。\ninline complex\u0026 __ap(complex * this ,const complex \u0026 c){ this-\u003ere += c.re; this-\u003eim += c.im; return *this; }向上面的函数就是使用了引用返回。\n操作符重载-1：成员函数 操作符重载-2：非成员函数 假设现在要计算复数的加减，如下：\ncomplex com1(1,0); complex com2(2,9); complex com3; com3 = com1 + com2; com3 = com1 + 2; com3 = 0 + com2; ……对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。\n接下来在考虑一个问题，就是如果我们只是做cout\u003c\u003ccom1;那么对于«函数返回值可以是void类,但是如果我们做的是cout\u003c\u003ccom1\u003c\u003ccom2\u003c\u003cendl; 这样的操作返回类型为void类型，那么当运行cout\u003c\u003ccom1后就无法运行\u003c\u003ccom2\u003c\u003cendl的代码.\n很显然要让代码继续运行，我们还需要返回iostream类型，而且使用return by reference返回方法，也就是返回引用。如下图： 小结 通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：\n确定类的数据并写在private中; 对于构造函数要善于使用初始化数据方法； 对于函数要想一想，返回类型是否可以改变，要不要写const； 对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。 是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用\n接下来通过学习string.h库，进一步了解指针的使用 一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，\n有时候还需要用到new 和 delete。\nstack（栈）和heap（堆） 如下代码：\nclass String{……}; …… { String str(\"hello\"); String str1 = new String(); …… }上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；\nstack object 的生命周期 在{}内的代码执行结束后，自动调用析构函数将变量清理掉，如下代码，\nclass String{……}; …… { String str(\"hello\"); …… }static local object 的生命周期 添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉， 变量会存储直到程序结束。\nclass String{……}; …… { static String str(\"hello\"); …… }global objects 生命周期 全局变量在程序接收后才会被清理掉。\nclass String{……}; String str(\"hello\"); …… { …… }调用new和delete的过程 在使用new的地方需要使用delete清理内存，防止内存泄露。\n调用new过程：\n调用delete的过程：\n代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存\nnew与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：\nnew和delete的补充 对new和delete的重载，用于设计内存管理，如内存池等操作。\n重载::new,::delete 重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图； 如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。\n类中重载的new和delete //类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t); p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F(); operate delete(p); // main函数调用示例 { F* p = new F(); ... delete p; }类中重载的new[]和delete[] 代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：\n//类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t*N + 4);//指针占4个字节 p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F();//析构函数 operate delete(p); // main函数调用示例 { F* p = new F[N]; ... delete[] p; }new,delete使用示例 using namespace std; class Foo { private: int _id;//4个字节 long _data;//4个字节 string _str;//40个字节 public: Foo() :_id(0) { cout \u003c\u003c \"default ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; Foo(int i) :_id(i) { cout \u003c\u003c \"ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; ~Foo() { cout \u003c\u003c \"dtor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; static void* operator new(size_t size); static void operator delete(void* p, size_t size); static void* operator new[](size_t size); static void operator delete[](void* p, size_t size); }; void* Foo::operator new(size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete(void* p, size_t size) { cout \u003c\u003c \"delete size = \" \u003c\u003c size \u003c\u003c endl; free(p); } void* Foo::operator new[](size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new[] size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete[](void* p, size_t size) { cout \u003c\u003c \"delete[] size = \" \u003c\u003c size \u003c\u003c endl; free(p); }运行结果如下：\nnew size = 48 default ctor.this = 00000191EC67A460id: 0 dtor.this = 00000191EC67A460id: 0 delete size = 48 _____________________________________________ new[] size = 104 default ctor.this = 00000191EC673438id: 0 default ctor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673438id: 0 delete[] size = 104为什么new[]操作会多出8个字节呢？ 我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。\n对new的分配额外内存 假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码： 小结 对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码\n​ class String Destructor Constructor Copy Constructor Copy Assignment Operator class String { private: char* m_data; public: String(const char* cstr = 0); //构造函数 String(const String\u0026 str); //拷贝构造函数 String\u0026 operator= (const String\u0026 str); //拷贝赋值函数 ~String(); //析构函数 char* get_c_str() const {return m_data;} }; String::~String() { delete[] m_data; } inline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); }else{ m_data = new char[1]; strcpy(m_data,'\\0'); } } inline String::String(const String\u0026 cstr){ m_data = new char[strlen(cstr.m_data) + 1]; strcpy(m_data, cstr); } inline String\u0026 String::operator=(const String\u0026 str) { if(this == \u0026str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str); return *this; } 补充内容static static在private中的使用例子 class template function template member template 成员模板 类模板中，还有类模板，通常是对构造函数的操作，如下图： 如下图代码 用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。\nnamespace（命令空间） 使用示例：\nusing namespace std; { …… }使用方法：\n​ using direction using declaration #include \u003ciostream\u003e using namespace std; int main() { cout\u003c\u003c……; cin\u003c\u003c……; return 0; } #include \u003ciostream\u003e using std::cout; int main() { cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; }或者\n#include \u003ciostream\u003e int main() { std::cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; } 附件 complex.h (546 B) Foo.hpp (1 KB) String.h (1 KB) ",
    "description": "",
    "tags": [
      "C++"
    ],
    "title": "1.代码编写规范",
    "uri": "/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r在昏暗的办公室里，落长轻轻地推开门，他的脚步轻盈得几乎不发出任何声响。他的目光在办公室内扫视了一圈，最终落在了我身上。我依然坐在电脑前，手指在键盘上飞快地舞动，PPT的页面在屏幕上不断翻动。\r落长走到我的桌边，他的身影在电脑屏幕的反光中显得有些扭曲。他轻咳了一声，打破了办公室的宁静。\n“哟，还在这儿呢？不是吧，辞职名单不是都交了吗？”他的声音带着一丝戏谑，但眼神中却透露出一丝不解。\n我停下手中的工作，抬头看向他，然后又看了看一旁的明月学姐。学姐的目光也正从电脑屏幕上移开，投向了落长。她的眼神中带着一丝询问，似乎在等待一个解释。\n我避开了学姐的目光，转向落长，心中的不满已经达到了顶点。昨日的一幕幕在脑海中回放，我因为只收取了我们专业的优秀生材料而被落长指责，我试图解释，但聊天群上的混乱让我错失了机会。事后，我向负责人说明了自己的行为，但似乎并没有平息这场风波。\n这件事发生在两天前。“农商专业的同学走这边，农商专业的同学走这边……了解更多情况请关注我们公众号，谢谢！”我站在宣传海报旁，大声地引导着同学们。\n“喂喂喂！你们哪个专业部的？”落长的声音突然打断了我的引导，他扭头看了一眼宣传海报——企划部，然后皱起了眉头。\n“农业专业的……”一个宣传的学员生怯生生地回答。\n“没问你这个……你们懂不懂公司规定啊！”落长不耐烦地对学员说，我在一旁也感到了疑惑，上前解释道：“你好，我是宣传的负责人，不知道我们哪里做错了？”\n“公司有规定，现在进行的是统招，不能专业独招。”落长的语气中带着一丝命令，但似乎对我的道歉还算满意，语气稍微缓和了一些：“请下次注意。”\n他叫来了相关工作者，指着我们的宣传海报：“把这个撤了吧！别放这儿了。”\n我一听要撤掉，心里一紧，这意味着我一晚上剪辑的视频和两三天的工作计划都将付诸东流。我连忙上前，想要阻止，这时专业部秘书的电话打了进来。\n“你好，这是农商招聘站，请问……”\n“我是妮南秘书，”她打断了我的话，“王小贵，你看群没？”\n我一直在忙，怎么可能有时间看群，我回答没看后，快速点开群浏览了一遍，“慕容主任”三个大字差点让我喘不过气来，我简单看了会儿。\n慕容主任：谁给我捅娄子了，这种低级错误都犯？\n副主任：@暮主任 怎么了主任？\n接着主任的一张图映入我的双眼，真是一看不知道，一看吓一跳，公司上边误认为我们搞“独立”了！看来问题变得有些不乐观，不想痛心割爱也不行了，我急忙协助工作人员整理了站点，午餐后，群里还没停止讨论，于是我打算先和专业部门的说明情况，再向公司解释。\n一切处理好后已是下午，临近下班，我从椅子上站起，“小贵，”江姐——我们专业部的老前辈——叫住了我，“来趟办公室。”\n我喝了半杯水，心神不定地走进办公室，正坐着的是副主任，右边是秘书和江姐。我往左侧走坐下。\n“大家下午好，我们开个小会……你们应该都清楚。”副主任说道。\n“小贵啊！下次注意点，这种小事做就算了，还让公司上边的人查到了。”江姐苦笑道。\n秘书欲言又止，但最终还是说了几句：“小贵，也不是针对你，但来公司都三年了，这种错误下次注意些，视频还不错啦，上边也有认可的，但是……特别是你的宣传——搞得……”\n“你也是为公司好，我们知道，但下次行事要多想。”副主任打断，平和地说道。\n“我知道了，给你们添麻烦真是抱歉，下次……额额不，没下次了，”我低着头，认识到这次可能真的搞砸了，“副主任，江姐这次可能有什么误会，我也会好好向公司上面说明情况的。”\n“小贵啊！这件事呢……就到此为止，你也别放你身上，好了你先回去，我和你江姐她们还有事要谈。”\n我有说不上来的憋屈，但又不知道怎么才能一语中的。\n“唉！怎么还有人犯这种错……”秘书瘫坐在椅子上。\n“确实，公司也是第一次听说这样的事，差点被别的专业部认为我们开‘小灶’呢，”江姐顿了会儿，又说，“这次的指导工作真是不尽如意啊……”\n“行啦行啦，”副主任盯着文件说道，“把去年的工作议程发给余，就要是副主任了，该让他熟悉熟悉。”\n公司里有规定，每隔三年的专业毕业生招聘工作，要先对所有专业生进行统招，最后再进行特招，但这项规定，我并未在任何会议上听到负责人提及，所以当到我们招专业生那一天，我只安排部门的人做了我们专业生的招聘标语，以及只安排了相关的招聘接待所，而对于别的专业生，我想也会有相关的人负责吧！\n晚上，我拖着疲惫的身躯，懒散地瘫坐在睡椅上，像极了晚年的老奶奶，又似将逝的人享受着人生最后一缕阳光。但我无法平静，我深切地体会到自己的工作被否定的难受，无论今天所做的事是否对，是否错，我都无法从心底里接受。我决心做什么转移注意力，我听同事说在市西区的西河桥有“服务”的姑娘们，甚是泼辣，我摸了摸口袋——500元！想想这个月的工资已打回家，自己只留了点做生活费，要度过这个月这点生活费可还能撑到月底？我想了想决定还是算了，我伸了个懒腰，起身往冰箱走去，想喝点酒消消愁，不想对酒而言，冰箱空空如也，我当场“寄了”。\n想想这个月都在公司吃，酒什么的家里也很少买呢！今天因为这事，一是有些不好意思，二是心情实在糟糕透了。我提衣下了楼，妮南在工作群发了消息：请大家在下个五中午下班前提交月季工作总结，并制做PPT一并提交。\n我长叹一口气，热气在胸前回流，让我内心不由地想抓狂。我关掉了手机往超市走去，灯火通明的夜色充斥着一片死亡的气息，黑魆魆的楼房遮住了明月，唯独遮不住它的光亮。\n",
    "description": "",
    "tags": [
      ""
    ],
    "title": "职场短篇",
    "uri": "/textbook/%E8%81%8C%E5%9C%BA%E7%9F%AD%E7%AF%87/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "序章 在这个看似平凡的现代世界中，时间的秘密潜藏于暗处，由几个古老家族和秘密组织共同守护。几世纪以来，他们不断研究揭示时间的奥秘，但也深知滥用这种力量将导致无法挽回的后果。在表面平静的生活背后，却隐藏着无数阴谋与斗争。\n科技水平与现实相似，但掌握超越时代技术的人群各怀鬼胎。这些家族和组织之间既有合作也有竞争，他们在暗中争夺对时间之力的控制权。普通人对此一无所知，继续过着他们的日常生活，而那些被选中的人则在命运的牵引下逐渐觉醒。\n在一所普通的高中里，一群学生正在经历着青春期的烦恼与梦想。他们彼此之间的关系复杂而微妙，但没有人意识到，他们即将踏上一场改变世界的旅程。\n白唐瑶是一位聪明而内向的女孩，她一直对自己的家族历史感到好奇。她的外祖母临终前曾留下一本日记，里面记载了一些奇怪的符号和文字。尽管当时年幼的她并不理解其中的意义，但这本日记却像一颗种子，在她心中悄悄生根发芽。\n与此同时，李浩然是一个充满活力的体育健将，他的家族世代从事科学研究，但他本人却对科学不感兴趣，更喜欢运动和冒险。然而，一次偶然的机会让他接触到了家族的秘密实验室，并发现了关于时间旅行的研究资料。这让他开始重新审视自己的生活和未来。\n还有苏晴，一个外表冷漠、内心炽热的女孩。她的家族是其中一个古老的时间守护者之一，但她一直抗拒继承这份责任。直到有一天，她在图书馆的一次意外中发现了一份古老的文献，上面记载了一个名为“时光之钥”的神器。这个发现让她不得不面对自己逃避已久的宿命。\n随着一系列巧合的发生，白唐瑶、李浩然和苏晴逐渐发现彼此之间不仅仅是校园中的同学，而是被命运牵引走上了解开这一切谜团的重要旅程。他们开始面对来自家族、组织以及自身内心深处的问题，善恶交织，终究谁能洞悉真正的时间意义？\n在这场充满未知与危险的旅途中，他们不仅要对抗外部的敌人，还要克服内心的恐惧与疑惑。每个人都在探索自己对时间秘密的认知，试图揭开隐藏在时间背后的真相。而真正的挑战才刚刚开始……\n第一章\n午后温暖的阳光透过窗户，洒在白唐瑶的小房间里。空气中弥漫着淡淡的灰尘味，仿佛时间在这里停滞了片刻。她坐在地板上，周围堆满了外祖母留下的各种旧物——褪色的照片、泛黄的信件、还有那些年代久远的装饰品。每一件物品都承载着家族的记忆，而白唐瑶正小心翼翼地整理着这些珍贵的遗物。\n她的手指轻轻拂过一张张照片，思绪也随之飘回了童年。那时，外祖母总是坐在摇椅上，给她讲述家族的故事，那些故事中充满了神秘与传奇。然而，随着外祖母的离世，这些故事也逐渐淡出了她的记忆。\n突然，一个不起眼的木盒引起了她的注意。盒子表面覆盖着一层薄薄的灰尘，但依稀可以看到精美的雕花图案。白唐瑶心中涌起一种莫名的激动，她轻轻地打开盒子，里面躺着一块古老的手表和一本泛黄的日记。\n手表的表面已经有些磨损，指针静静地停在某个时刻，仿佛时间在这里凝固了。白唐瑶拿起手表，感受到一股微妙的震动，仿佛有什么力量正在苏醒。她的心跳不由得加快了几分。\n接着，她翻开那本泛黄的日记。纸页因岁月的侵蚀而变得脆弱，但字迹依然清晰可辨。日记中记载了家族成员曾经进行的一项关于时间的实验，以及实验带来的灾难性后果。每一页都记录着他们对时间奥秘的探索，以及由此引发的一系列事件。\n“1920年3月14日，我们终于完成了时间机器的初步设计。这是一次前所未有的尝试，我们都怀着激动与不安的心情……”\n“1921年6月5日，实验失败了。时间发生了扭曲，一些人永远消失了。我们意识到，这项技术的力量远远超出了我们的控制……”\n“1925年12月28日，我们必须停止一切研究，并将所有资料封存。这块手表是唯一幸存的实验成果，它拥有某种不可思议的力量……”\n白唐瑶读完这些文字，心中的震撼难以言表。这块手表不仅是一件珍贵的传家宝，似乎还隐藏着不可思议的力量。她对手表的起源和能力产生了浓厚的兴趣，决定揭开这个秘密。\n就在这时，手表的指针突然开始缓缓转动，发出细微的咔嚓声。白唐瑶惊讶地看着这一幕，仿佛时间在这一刻重新流动起来。她知道，自己的命运即将发生改变。\n她深吸一口气，坚定地合上了日记。从今天起，她将踏上一条充满未知与危险的道路，去探寻那个被尘封的时间之谜。而这只是一个开始……\n白唐瑶合上日记，心中充满了复杂的情绪。她感到既兴奋又不安，仿佛有一股无形的力量在牵引着她。她再次拿起那块古老的手表，仔细端详起来。手表的表面刻着一些奇怪的符号，这些符号似乎不属于任何已知的文字系统。她轻轻转动表冠，指针开始缓慢而有节奏地移动。\n突然，房间里的光线似乎变得有些诡异，空气中弥漫起一种淡淡的香气，像是某种古老的香料。白唐瑶感到一阵眩晕，眼前的景象也开始模糊起来。她急忙闭上眼睛，深呼吸几下，试图稳住自己的心神。\n当她再次睁开眼时，房间已经恢复了正常。手表的指针也停了下来，一切仿佛都没有发生过。白唐瑶摇了摇头，心想可能是自己太紧张了。她决定先将这块手表和日记收好，再慢慢研究。\n她站起身来，把木盒放在书桌上，然后继续整理外祖母的遗物。然而，心中的疑惑却挥之不去。那些关于时间实验的记载究竟是真的吗？这块手表到底隐藏着什么秘密？\n就在这时，她的手机响了起来。是闺蜜洛翠翠打来的电话。\n“唐瑶，你在家吗？”洛翠翠的声音听起来有些急切。\n“我在家呢，怎么了？”白唐瑶问道。\n“我刚刚在网上看到一个新闻，说是一些古董收藏家发现了一批非常珍贵的文物，其中有一些跟时间相关的神秘物品。我觉得这可能跟你外祖母留下的东西有关，你赶紧上网看看吧。”\n白唐瑶的心跳不由得加快了几分。她迅速打开电脑，找到了洛翠翠所说的新闻。新闻中提到的文物确实与她手中的手表有些相似之处，尤其是那些奇怪的符号。报道还提到了一些关于时间旅行的传说，这让白唐瑶更加确信，外祖母留下的这块手表绝非寻常之物。\n她关掉网页，陷入了沉思。如果这一切都是真的，那么这块手表可能会带来无法预料的后果。她需要找到更多的线索，揭开这个谜团。\n第二天，白唐瑶来到了图书馆，希望能找到更多关于时间实验和家族历史的资料。她在档案室里翻阅了大量的书籍和文献，终于在一个不起眼的角落里发现了一本尘封已久的家族史记。\n这本书详细记录了家族成员进行时间实验的过程，以及他们所经历的种种困难和挑战。书中还提到了一块被称为“时光之钥”的古老手表，据说它能够开启通往不同时空的大门。白唐瑶意识到，她手中的这块手表很可能就是那块传说中的“时光之钥”。\n她继续深入研究，发现了一些关键的信息。原来，外祖母曾经是一位杰出的时间学家，她在年轻时参与了那次时间实验，并且是唯一幸存下来的人。为了防止这项技术落入错误的手中，她一直保守着这个秘密，直到临终前才留下了这些线索。\n白唐瑶心中涌起一股责任感。她决定继承外祖母的遗志，揭开这个时间之谜，确保这项技术不会被滥用。她知道，这条路将会充满未知和危险，但她已经做好了准备。\n回到家后，白唐瑶再次拿出那块手表，轻轻抚摸着它的表面。她闭上眼睛，默默许下一个愿望：“外祖母，我会完成你的使命，保护好这块‘时光之钥’，不让它落入坏人之手。”\n随着夜幕降临，白唐瑶躺在床上，脑海中不断回想着今天的一切。她知道，从明天开始，她将踏上一段前所未有的旅程，去探寻那个被尘封的时间之谜。而这只是一个开始……\n第二章 几天后，白唐瑶决定去找好友敦庞庞商量一下下一步的计划。敦庞庞性格乐观，总是能带来正能量，她相信敦庞庞能给她提供一些有用的建议。\n白唐瑶来到敦庞庞的工作室，发现她正在忙碌地处理一些文件。敦庞庞看到她进来，立刻放下手中的工作，热情地招呼道：“唐瑶，你怎么来了？有什么事吗？”\n白唐瑶简单地讲述了外祖母留下的手表和她在外祖母的日记中发现的秘密。敦庞庞听得目瞪口呆，不敢相信这是真的。\n“哇，这简直像是一部科幻小说！”敦庞庞惊叹道，“不过，这真的很危险。你打算怎么做？”\n“我想先找找有没有其他线索，然后再决定下一步。”白唐瑶说道。\n敦庞庞点点头，提议道：“你可以先去问问你父亲，他可能知道一些家族的历史。还有，你可以找找你堂叔白正中，他事业成功，也许能给你一些帮助。”\n白唐瑶觉得敦庞庞的建议很有道理，决定按照她的建议去做。离开敦庞庞的工作室后，她先去了父亲白正恩的办公室。\n白正恩看到女儿走进来，显得有些惊讶。他放下手中的文件，严肃地看着她：“唐瑶，有什么事吗？”\n白唐瑶深吸一口气，将外祖母留下的手表和日记的事情告诉了父亲。白正恩听后，眉头紧锁，沉默了一会儿，然后缓缓开口：“这件事确实很复杂。你外祖母生前确实进行过一些非常规的研究，但具体的细节我也不清楚。不过，我可以帮你联系你堂叔白正中，他或许知道一些情况。”\n白唐瑶感激地点点头，离开了父亲的办公室。接下来，她拨通了堂叔白正中的电话。\n白正中听到白唐瑶的请求后，同意见她一面。两人约在一家咖啡馆见面。白正中是个事业有成的中年男子，他看着白唐瑶，认真地说道：“唐瑶，你外祖母的事情我知道一些，但具体的细节我也不是很清楚。不过，我可以帮你联系一些相关的人士，看看能不能找到更多线索。”\n白唐瑶感谢了堂叔的帮助，心中感到一丝安慰。她知道，有了父亲和堂叔的支持，她离揭开真相又近了一步。\n就在她准备离开咖啡馆的时候，她无意间看到了一个熟悉的身影——莫长逍。他坐在不远处的一张桌子旁，正低头看书。白唐瑶心中一动，走上前去打招呼。\n“长逍，好久不见！”白唐瑶微笑着说道。\n莫长逍抬起头，看到是白唐瑶，脸上露出一丝微笑：“唐瑶，你怎么在这里？”\n“我来找堂叔商量点事情。”白唐瑶解释道，“你呢？”\n“我在准备期末考试。”莫长逍回答道，“最近学习压力挺大的。”\n白唐瑶点了点头，关切地问道：“需要帮忙吗？”\n莫长逍笑了笑，摇摇头：“不用了，我自己可以应付。倒是你，看你神色凝重，是不是遇到什么麻烦了？”\n白唐瑶犹豫了一下，还是决定告诉他一部分实情：“其实，我外祖母留下了一些东西，我正在调查一些事情。有点复杂，但我会解决的。”\n莫长逍看着她，眼中闪过一丝关切：“如果有需要，随时告诉我。我能帮得上的一定会尽力。”\n白唐瑶感动地点点头，心中感到温暖。她知道，莫长逍虽然平时高冷，但在关键时刻总能给予她支持。\n两人聊了一会儿，白唐瑶告辞离去。她走在回家的路上，心情轻松了许多。有了朋友和家人的支持，她相信自己一定能解开这个时间之谜。\n附件 ",
    "description": "",
    "tags": [
      ""
    ],
    "title": "白唐时间录",
    "uri": "/textbook/%E7%99%BD%E5%94%90%E6%97%B6%E9%97%B4%E5%BD%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "一\r我的朋友你好啊，我已经太久没有写信给你了，兴许是最近看了些书，唤醒了自己写信的欲望，你知道吗？我已经毕业了，从一个大学生一瞬间变成一个步入社会的青年小伙子，我幻想着未来自己从事自己专业的工作，但我想这一定会事与愿违，我很清楚自己的实力，就像你很了解我一样，过了那我么久我不知道你是否还能像之前一样了解我，你给我写的信我几乎都看了，但是我没有认真的给予回复，对此我很感抱歉。\n兴许你已经发现我变了样，自从我进入大学后就没再与我联系，时隔四年之久，我有很多经历想要告诉你，与你倾诉，听听你的意见，但我觉得这一切都是我的幻想，我不知道你能不能收到这封信件，可我打心底希望你能收到，并给我回信。\n我的故事还是先从以为朋友说起吧，他是我的室友，我们是在入学那天在宿舍认识的，他与你样家乡都在白岭坡，我很高兴在这个人的身上看到你的影子，但也仅此而已，我记得那天我刚到宿舍自己忘记带了钥匙，他与以为那要是的舍友一同给我开了门，当时我还询问是不是昨晚加QQ好友的同学，因为在来之前我已开始在班级群里寻找家乡一带的人，很可惜没有一个人与我是胡冲的，但情况不算糟糕，我加了白岭坡的同学，人世间有些事就是很奇妙，白岭坡的同学与我们竟师出同门，这真的让我很意外，同时那种孤单的感觉也渐渐消散，有时候某些事将我们的注意力勾走后，我们就会忘记自己以前担心的，在意的东西，或把刚刚的人或事短暂的忘却，我觉得这又何尝不是一件好事呢。\n我把东西放宿舍后，他们就离开了，宿舍很宽敞，左右各有三个床位，都是上床下桌，我选了左手边最里面的，你知道的我幻想着可以看星星，看月亮，就像在高中那会自己那样，但直到现在我也从来没有从床头往外看那皓月满星，我知道我自己丢掉了一些东西。\n有关白岭坡的同学我很想和你聊聊，兴许你会感兴趣，我曾有许多事拜托他，他都毫无怨言的完成，而且有时候让我很不好意思再次请求他帮忙，这个原因不是他开始抱怨了，也不是他做的不好，反而是太好让我有点不适，自从发现自己有这样的想法后我再也没有请求他帮忙了，有时候觉得这样的人过于完美，但人无完人，我有时候想把他的缺点一一罗列，好让我看看他这个完整的人，但是大一大二一直没有机会，原因是在大二入学不久他和宿舍的另一位同学闹掰了，后面事态发展得很严重，他搬到了别的宿舍，后来听说他在那个新宿舍过得很好，但我总能听到关于他的事迹，以至于我想把这一切告诉你，我想把这一切关于他的事来告诉你，因为我发现欠缺某样法宝的人是无法在大学生活中完成猝炼的。\n大一那年，他是个忙活的人了，白天回宿舍几乎看不到他的踪影，晚上也不怎么见人，不过那时候晚间的习课还是挺多的，有一次我问他，平时都去干嘛了？他遮遮掩掩没有几句话，我知道他似乎不想说，后来我也没再问，再次被问起时另一位舍友说的，那时候的回答就清晰了许多，他周末要留在社团值班，平时他要忙学生会的事物，周三还要去打扫图书馆，合着他加入了那么多社团，我也很疑惑为什么要把自己置于忙碌之中呢？平时学习其实不见得能抽出空闲，大学的课业虽不比高中那般，但也并不少，要想把专业的知识筑牢其实要花很多时间。那后的一天我问他为什么要参加那么多社团，他说算是给自己圆梦，那会他正在看日本的校园番剧，具体是什么我不知道，但是我很清楚日本的校园番多少回提到社团，其实我们高中那会也有，能念出名字的只有学生会，相比日本的高中社团那确实少了，但这其中的原因我想你是知道的，我有时候想他是不是被这样的东西给影响了呢？但这也是纯纯的个人想法。\n到第二年他转出后就没再见到他忙前忙后了，有一次我去宿舍串门恰巧遇到他，看他正准备科目二的考试，便和她谈论了起来，我们调侃着科目二失败的种种，全然被这种失败后的调侃和找到彼此的共同点而感到满足，而忘记了败考后的种种失落，起初觉得这是一种有效的缓解痛苦的方式，但是后来=看着一个个拿到驾照的同学我才知道，这简直是一种不堪的逃避方式。有一次在食堂吃午饭，我的舍友又和他谈起了这件事，他两侧额头翻红，略带虚汗留下，他时不时擦拭自己的额头，盯着碗里的饭菜，回答了舍友的问题，他的回答充满着应付，似乎这样的话术是为这样的提问而准备的，我很疑惑他为什么放不下又没有勇气去尝试，这在小说中算是一种悲剧性的人物了。有一次我替学习委员收作业的时候发现作业少了基本，便在群里发消息叫没交的自己补上来，等我再次去检查时，发现还是少了一本，没有办法我只好当场询问是谁没交，没想到是他，当时我很惊讶，应为他的身份以及他的为人，在我看来不应该犯这样的小错，或许你觉得我这想法太偏激了，但我不这么认为，一件很小的事足以看出一个人办事能力。在后来与学习委员交谈中，我更肯定了这一点，学委说，有一次也是交作业，大家都交了，就他没交，当时写作业已经送去老师办公室的路上了，他才联系我，我说那我在宿舍楼门前等你……其实这样的事也不止这一两次。\n我想我写得够长的了，最后想以一段话结束这次写信，刚才说的同学，少了许多基本的东西，我不知道他为什么会缺失，但我可以肯定这样的东西完全可以规避，甚至养成避免这样事发生的习惯，但是他没有这么选择，在原来的道路上越走越远，我不知道他为什么坚信自己那样的做法是正确的，不知道为什么他明知故犯，在准备毕业设计的时候，班级的同学大多都已经完成了自己的毕业设计，无论是以什么样的方法完成，我都清楚的知道有些事情只看“完成”，就像学委收作业一样，只看你交还是没交，并不关心你写得怎么样，那是你自己和老师要关心的问题。那些天我时常去宿舍看看大家的都做的怎么样，也顺便交流彼此心得，每次都能看到他在为自己的毕设忙，但他们宿舍的朋友也有告诉过我，他有时候也是忙里偷闲，熬夜倒一两点也不为毕设论文动笔——那他在忙什么呢？或许这个答案只有他自己知道。他平时作息也不规律，但他们的舍友也没说他什么，我有时候也很惊诧——为什么？直到最近我们推荐了份工作，希望他也能参加，于是我们一同去面试，再回来的时候，一起去吃饭，我问他驾照考得怎么样了，他回答说，没考呢！我也不打算考了，安心找工作，后面走一步再看一步吧！他这次既没有两侧额头泛红，也没有吞吞吐吐，藏着掖着。\n我知道他还是当初认识的他，他被别人牵着往前走，这样的生活已经磨平了本该寻得法宝的他。这一切怪不得谁，他也坦然接受了这一切，\n二\r自福你好啊！\n今日的风儿不知怎的突然主持了一场盛会，校舍山上的榕树、柏松、榆树，山下的金菊、夜来香、玫瑰，还有那满山的绿草……它们无不为歌而舞，那一声声“呜呜呜”，兴许那就是风儿歌声了吧！安静的走廊里食品袋不知怎的被风儿捧在手心，又突然高高地抛到高空，似乎在为获胜欢庆；还有树儿们，它们似乎很久没有这么疯狂了，在参加前还不忘安顿了年迈的树叶，你会看到一片片枯叶飘落；还有满山的花草，随着歌声旋律左右摇摆，它们无不为这场盛会狂欢。\n我想自第一封后，我还会频频给你写信，今天依旧没有收到你的来信，说真的我有些担心你，我曾询问信使，他说他按照我给的地址送信了。我想我还需要进一步确认你的地址，昨天我询问故友打探你的消息，故友说，你已经离开了白岭坡去了很远的地方，与你最后一次见面是在四年前，四年来故友也没有你的消息，我想我可已询问你的亲友，于是今天早上与你的二妹取得了联系，至此终于是知道了你的具体地址，于是我第一时间把第一封信捎给了你。\n今天我想和你说说昨天遇到的一件事，昨天我收到了新工作人事部负责人的消息，他告诉我在国庆结束后的第二天报道，所以最近都在为此做准备，但是在收拾衣物的时候不知不觉想起自己的教资面试还未报考，查阅资料才知道我得在学校所在地报考才行，这对于我新工作无疑是重大的冲击，这意味着我在工作后还需要返回学校参加面试。其实返回学校也没有什么，主要是新工作的地方太远了，来回的时间和金钱都是问题，这让我对新工作有些犹豫。\n其实这一切的源头还要从我第一次参加教资考试开始，说道这还真的有些懊悔，但这都是无用的了，我去年下半年参加的笔试，笔试通过后，我就没有在留意面试的报考时间——所以不出乎意料的我错过了今年上半年的面试，于是我只好等今年12月份了，现在看来那时候我已经参加了实习工作。\n所以这是挺懊悔的事儿。\n有些事情总放着确实会出问题，这是第一次被拖延痛击的一次，这让我想起你白岭坡的同学，此刻我或许能体会他的感受，我的朋友你要是还有未做的事，希望你也趁行动起来，将这似乎早已安排的事做完。\n三\r亲爱的自福，\n收到你的来信，我心中涌起了一种难以言喻的喜悦。你的话语仿佛一股清新的春风，吹拂过我的心田，让我重新找回了久违的感觉。\n秋风掠过之后，天气逐渐转凉。今日阳光温和，微风不再那般狂躁，似乎在轻轻告别过去的时光，准备迎接新的一切。这风，就像是老朋友一般，在送别故人后悄然离去，留下一片宁静与祥和。\n自从上次给你寄出信件后，我已经离开了校园，踏入社会工作。其实，我对你有所隐瞒——准确地说，我只是出来实习而已，大约明年五月份左右才会重返校园。这段时间里，我对即将开始的新生活充满了期待。记得你曾对我说过，生活中不必过于期待或抱怨，但现在的我却很难做到这一点。对于这份新工作，我的内心既激动又忐忑；如果不幸被解雇，想必我还是会忍不住抱怨一番吧——当然，真心希望这样的事情不会发生在我身上。\n为了尽快适应这份工作，我提前几天来到了广宁。尽管已是十月，这里依旧炎热难耐。每当走在街上时，总感觉空气中弥漫着一种黏腻感，偶尔还会让皮肤感到不适。幸好住处有风扇，夜晚可以打开它，享受片刻凉爽。半夜醒来时，我喜欢走到阳台上感受夜风，本想仰望星空皓月，却发现四周高楼林立，遮挡了大半的天空。没有月亮的夜晚虽然明亮得让人好奇，甚至有人因此而流连忘返，但少了那轮明月，整个夜空便失去了几分韵味。\n某夜，我辗转反侧难以入眠，于是小心翼翼地推开了卧室门。即便动作再轻，老旧的铁门依然发出了轻微的响声，生怕吵醒了同住的同学。关上门后，我缓缓下楼，每一步都尽量放轻脚步，以免惊扰到沉睡中的尘埃。然而，这些细小的灰尘仿佛喝醉了一般，在我的裤脚边来回跳跃，但我无暇顾及，只顾加快步伐穿过厚重的大门，走向外面的世界。社区内的房子排列整齐，但巷子的小路却像迷宫一样，偶尔会遇到一条看消失在路灯下的笑道，我现在出了出租屋就是这样。广宁作为一座繁华都市，即便是深夜，也依旧充满生机与活力。沿着小巷前行，我不禁联想到了电视剧中那些间谍追逐的情景，只是此刻的我既非追捕者，亦非被追者。\n走出小巷后，我在一家烟酒店偶遇了一位来自家乡的老友。他正准备参加聚会，原本只是买了饮料就打算离开，但我们聊了几句后，他热情地邀请我一同前往，并介绍给我认识一些新朋友。不久后，我们乘车抵达目的地。周围环境十分安静，仅有几缕冷风迎面吹来，仿佛也在欢迎我们的到来。步入酒店内部，可以看到一幅巨大的画框悬挂在右侧墙壁上，里面装裱着一幅似出自徐悲鸿之手的《八骏图》仿制品。画面下方摆放着现代风格的木椅，用于招待客人，左侧则是服务台，穿过服务台向后走几步再左转便是通往二楼的楼梯。与一楼相比，二楼显得更加热闹，各个包厢内传来的歌声此起彼伏，走廊里也不时响起窃窃私语声。\n随后我随故友来到206号包厢，包厢内几位女生坐在最里面的位置，男生们则分布在中间和靠近门口的地方。他们正专注地看着屏幕唱歌。老友向大家介绍了我，我略显尴尬地点了点头，找了个靠门的角落坐下。旁边的人不断招呼我加入，说：“随便吃点东西，别客气，我们跟潭哥玩得很开心……”我点头表示感谢。随着歌曲一首接一首地播放，众人纷纷献唱。我也尝试着开口，但很快就意识到自己的嗓音并不适合，于是借口上厕所离开了包厢。\n厕所位于显示屏左侧不远处，需要拐个弯才能找到。看到厕所管着门我便止步直返，回来有是嗑瓜子，又是和邻人谈论彼此的故乡，接着碰杯把酒一饮而尽……在接下来的一段时间我似乎小睡了一会，我起来再次去厕所，转角迷迷糊糊的往里走了几步，突然听见厕所传来奇怪的人声音，似乎在窃窃私语，又似乎在准备着什么……我一时蒙在鼓里，但很快我又回到了座位上，音乐将那个角落与外界隔绝开来，使那里变得格外安全。喝了两杯啤酒后，又环顾了四周的男子与女子，我似乎明白了什么——我以有事为由离开了包厢。\n门外依旧如初来时那般寂静，只有冷风在夜色中徘徊，我站了很久似乎在等待冷风送客，但是终是徒劳，或许我喝太多了。\n回到住所所在的社区，再次穿行于小巷之中。抬头仰望，楼房似河岸，河岸中间流淌散发着柔和光芒的河流，细细看去倒影着几颗星星。眨了眨眼往前走去，路边飞舞的虫子围绕着路灯盘旋，宛如少女头上的发簪随风摇曳，此时被路灯白光点亮的小巷宛如一位身披银纱的女子，静静地坐在这条幽静的小径上聆听这座城市的故事……\n我轻轻地推开房门，带着满身疲惫扑倒在床铺上，很快便进入了梦乡。\n我想今天先到这，期待下次你的来信。\n四\r无论面对多大的打击，心里有多委屈，也绝不能摧毁人们活下去的勇气，依旧要在秋风中扫码洗个热水澡，依旧要躺下休息，迎接明天的太阳。 久在樊笼里，也是安逸，但终有一日要这种安逸会被打破，我们唯有迎接，然后继续生活。\n五\r今日有收到母亲的来电，我已经是第三次收到母亲的来电，他很担心我的工作情况，我只得把自己糟糕的情况一五一十的告诉她，但是这样似乎不是一个好的选择，我有时候在想是不是该说些善意的谎言……我不是道你是否有过和父母说过这些话，但是我却从不遮掩，我想这点你是了解我的。\n说现在自己的情况很糟糕是因为我面试失败了，这已经不是第一次了，我也离开了之前的房租，现在准备借宿在我姐姐哪里，在哪里我或许可以一遍找工作，一遍又睡觉的地方，这可能是目前比较好的选择，我希望你的情况没有我那么遭。\n来电时母亲也不忘警告专心对待一件事，特别是专业上，他说我的表姐、表哥们已经在自己的专业上有了一定成就，也赚到养活自己的钱，我想这样的例子对我是好的激励，但是专心于专业上对我来说无疑很矛盾，我现在似乎混到头了，似乎这辈子就即将这么度过。\n我乘了一天的车来到姐姐的住处，一番折腾终于是找到了他的住处，有时候觉得这也是一件麻烦事，我不知道为何小事情开始变得那么烦躁。\n请原谅问我这样的表述，希望能收到你的来信，很期待你最近的生活又是过得怎样的。\n六\r自福你好，\n在这个宁静的夜晚，我想和你分享一些好消息——我已经开始工作了，虽然这份工作与我的专业并不相关。或许我现在只能透露这么多，但我相信未来还有更多的可能性等待着我去探索。\n前几天，因为一些个人材料的事情，我回了一趟学校。我记得那天我乘坐了晚班火车，很幸运的是，出了车站后并没有等待太久。你知道，最近天气开始转冷，外面飘着细细的雨丝，仿佛眼前笼罩了一层望不到边的迷雾。我在车上小憩了一会儿，感觉自己已经很久没有好好休息了。当我回到宿舍时，已经是晚上11点了。我简单整理了行李，洗了个热水澡，便躺下了。\n宿舍里空无一人，进门处的灯也坏了，阿叔还没有来修。厕所里时不时传来“唰唰”的声音，远处偶尔传来雷鸣，但好在能听见隔壁宿舍打游戏的声音，以及楼上传来的推椅子声，这些熟悉的声音让我感到一丝安慰。\n第二天早上九点左右，我被走廊里的行李箱轮子声唤醒。不知为何，我有种奇怪的感觉，仿佛自己像无根的浮萍，让心里一阵阵发紧。我知道，最好的办法是刷会儿视频，逛逛朋友圈，然后忘记这件事。我一边这么做，一边起床洗漱，但当一切安静下来，那不安的心还是会马上浮现。\r我骑上自行车往南苑走去，楼下的打印机坏了，我只好去南苑的转盘打印材料。打印好后，在送去自强楼的路上，我遇到了肖可，他是我班级的同学。我上前向他打了声招呼。\n“你怎么回来了？”他问。\n“回来办点事！你这是准备去哪啊？”我回答。\n“去参加校招……是的，现在还有啊……不过也没多少了……看了很多家，都不是很如意或者他们看不上我……打算再碰碰运气。”他的声音里带着一丝无奈。\n他时而眼神闪躲，时而叹息语顿，我们彼此分享着不幸，试图安慰对方，或是缓解尴尬的气氛。我见状便与他告了别，继续送材料去了。\n回来后，我听到隔壁宿舍一直在谈论今天的校招。不出所料，肖可又错失了机会。其实，肖可是班里的优秀生，他曾是我们班的副班长，担任过学生会干部，参加过许多活动。但似乎他所做的一切努力，对现在找工作并没有起到任何作用。我吃完饭后找他谈了谈，问他接下来怎么打算。\n“决定再等几日，校招后面还有……”他边说边刷着视频，眼神很少停留在我身上，语气中透露出一丝不情愿，声音里带着轻微的沙哑。\n“今天没写完笔试题目……也没交……错过时间了……是的，挺可惜的，看看后面还有没有机会……”他的话语中透露出一丝遗憾。\n听到他的话，我顶着泛红的侧额，移开了视线，好在他一直没有留意我的眼神。\n“不是，有两个招聘会吗？”我问道。\n“第一个讲了一个半小时，结果后面又说我们专业的不要了……”\n他试图解释着什么，以让我知道得更清楚。\n“其实之前都参加了许多场，面试都是不通过……”\n“这样啊……今天的笔试他们说是不是闭卷啊，你没查的吗？”\n“查了，好多都不会呢，肯定查啊！”他犹豫了会儿，面容羞涩地哎呀了一声，接着补充道。\n有时候还是无法理解肖可……我想追问下去，但想想有失礼数，他或许真的有什么难以开口的，于是只留下一句“这样啊！那就奇怪了”。我想肖可得“生存之道”还有缺考量，在我看来，面对这样的我们他的做法是不可取的，这让他错失了很多好的机会。\n我带疑惑和惋惜回了宿舍。上床睡觉时还能听见，他和网友开黑的声音。这样的日子还要持续多久呢？我在内心发出这样的疑问，看着睡帘上的圆月图案，久久无法入睡。\n七\r自福你好啊，距离上次给你写信已经是前几个星期的事情了，进来由于工作上的事情，自己忙的不可开交，或许我先在可以告诉你我的工作了，兴许是自己过得比较好一点了，我对向来也是坦诚相待，上次不说还是因为自己当时签了了一个培训机构，但是那并非我的专业，也不是我所向往的，很快我从学校办好材料回到公司后就辞职了，你可能觉得我跟适合当一个教师，我以前也这样觉得，但是现在不一样了，当你步入社会以后你会发现一切与你所想的完全不一样，这方面的困难我打算后面在与你细说。\n那天我交完材料后，第二天我就去贺宁了，贺宁民族大学举办在第二天会有一场校招，到时候会有来自省内外的诸多公司到场招聘，学校也组织了这场活动，在校内报名的可以乘坐学校租的大巴往返，我自然没那么幸运，因为这个通知发出来的时候我还在广宁，当时已经出去了，所以这一次的形成我需要自掏腰包去贺宁了，与我同行的是2班的一位同学，我与他是在电子协会认识的，当时还参加过带你自设计大赛，他这次去贺宁一是找工作，二是顺便回家。\n在路上，我们很少聊天，各自玩着自己的手机，我们聊得最多的就是找工作，其他的我自己有意无意的也在避开，虽然我们还算熟络，但不知道为什么自踏上这趟行程，似乎其他的话题不再变得这么有趣，或经得起被我们谈论。又是后想谈论各自的家乡，各自大学生活的，各自的喜好都在喉间来回窜动，但不知不觉又被狠狠地咽下。\n我们乘坐动车，所以比学校的大巴快了两个小时，天也渐渐得也合上了眼，晚间我和同学出去吃东西，在酒店的楼下遇到了乘坐大巴的同学，我们彼此问候，一起走进了餐馆，我在餐馆里见到了同班同学——廖合，他告诉我肖可也来了，现在在酒店。\n“我记得你不是已经找到工作了吗？”\n“唉，那个公司简直他妈的就是坑人……你不知道，去前和我们说没有两班倒，周末双休……”\n廖合说着，接过老班端上来的面，边吃边说，面色有些难堪，言语却透着气愤。\n“接下来有什么打算呢？”\n“我已经想好了，明天去看看有没有合适的……没有就考公去了。”\n“这倒是一个好去处。”\n“考公也很难啊，大家都盯着一两个碗。”2班的同学说道。\n我们两也表示赞同。我问了廖合，为什么肖可没下来吃饭。廖合告诉我，肖可下楼没看见饭店就会酒店了。\n“说道酒店，学校也是大气啊！”\n“怎么，住上好酒店了吧！”我接话道。\n“何止！我们住的维也纳酒店，我和肖可住的房间挺宽敞的，房间整体呈棕色，房间开灯后，充斥着暖色调，进门左手边是厕所，厕所配有吹风机和旋转镜和一面大镜子在洗漱台前，洗漱台对应着沐浴间，说来房间也是情趣，沐浴间与两张床隔着一面透明玻璃……”说到这，停了会，吃着面侧脸也泛了红。\n“这么刺激吗！”2班的同学说道，我们也领会了其中之意，都笑了起来，气氛也随之上来，于是廖合接着说：\n“右手边还配了两瓶水，但我没看上，没喝，也就肖可拿了而已，那旁边过去就是电视屏，接着就是一张长桌和一张绿色圆椅，长桌旁边是圆桌和两张圆椅，接着过来就是两张床了，床并着横放，电视与床之间还可以仿一张床，所以我说这房间真的大。配置真的很顶！”\n我二人点了点头。\n“学校对你们真好，听说明天还可以吃酒店早餐。”\n“是的，挺期待。”\n我们吃完面又喝了饮料，聊了几句就各自回酒店了。\n第二天，我们在贺宁民族大学的食堂一楼，遇到了廖合，他们在打印简历，打印简历的人很多，打印店很小过道约莫一米，人从店里排到店外，店里嘈杂的声音盖过两个疯狂旋转的风扇，走进风扇能听见嗡嗡的声音，店内人多，也很热，我看到从里面走出来满头大汗的肖可，一遍从人群中左右侧着身子出来，生怕自己撞到身边的人，肖可手里拿着简历对着自己扇了扇，又垫着身子往里看了看。\n我们上前搭了话，得知他还在等廖合与重高的简历，我问道，重高也来了吗？他说，他帮重高投。他拿了一打简历，简历似乎寄托着什么，他紧紧攒在手里。\n“这么多简历吗，你打算投多少家啊？”我看着他的简历说道。\n“还不知道，以后可能也会用到。”肖可有些不好意思的回答道。\n见此状况，我也就你不在问，去招聘的路上，2班的同学文，你们是怎么知道打印店位置的？\n“你问这干嘛。”我有点纳闷。\n“我们一路问过来的，”廖合又补充道：“当然，都是肖可问的，我就跟着，跟着大佬就是好啊！”\n“是的。”我们一同说道，只留下肖可一人在前微微的笑着。\n校招的过程很难堪，我并没有找到合适的，到时在简历指导处听力一上午，校内的教师对简历的一一指导，我想这也算是收获，我绕了几圈，也没兴趣再去招聘里逛，便环绕了一圈，在支教等服务处停留了片刻，顷刻间自己也想，或许这也是一条好的道路，我再往前走，是贺宁人才网的周边，扫码参加活动领了周边便回了酒店，回来时已经是中午，我在贺宁民族大学校门口看见了学校的队伍，看大了肖可依旧攒着自己的手里的简历。\n我想结果无论如何，这一趟也算不错。\n今天就到这里了。\n2024.11.1\n八\r自福你好啊，今天休息，我想着给你写封信，早上的时候我去和室友去楼下吃了早餐，我们点了一份面10块钱，说实话我无法接受这样的价格，而且面条也不是很好吃。\n我们聊天的时候，室友告诉我自己最近遇到了很多事，感觉自己没有活下去的意义，我也是第一次听他这么说，但我想想也是因为找工作的事情，他从8月份到现在还没有找到工作，我也很纳闷为什么呢？\n“又是找工作的事情吧！会找到的。”\n“其实也有找工作这部分的内容，但是自己心烦还是因为自己今早看到了一篇杂谈，”他顿了顿，我似乎能感觉到他内心一丝丝痛苦感，他接着说：“关于人性善良的话题。”\n“说道你心里了吧。”我到了两杯水，把水递给了他，往面条里加了一勺辣椒。\n“里面说，人太善良只会害了自己，大概就是这样……”他示意把辣椒递给他，我顺便推了过去。\n“我有一个很好的哥哥，前几年毕业，当时疫情刚结束不久，工作的环境在疫情后都不怎么样，他跑了几个月也没有找到工作……说实话和我现在境况还真像。”他接着说：“我哥哥什么事都喜欢自己扛着，自己在忙也会帮别人，在初中的时候很多人对他的评价都是——老实人，很善良，心很好。但是我觉得他的心善与他的遭遇并不成正比，我想想也是这种事怎么会是正比呢？他告诉我他去广东找工作的时候，有一天房东叫他们搬房间，在那之前表哥已经告诉过他搬房间时房东提的，搬的时候你可以搬，也可以自己说有事自己先出一趟……结果？我哥他和房东忙了一下午把房间搬去了六楼，他们本来五楼的……对啊，还好不是一楼。”\n“后来怎么了？”我问道。\n“我哥没找到工作，回家和父母去工地打工，第二年就进厂了，现在过得还不错。”\n吃着吃着，留意到舍友抽着纸擦了擦眼角，又擦了擦嘴角。店里的面里的辣椒味很足，我也不得不抽着纸擦擦自己的眼角。吃完后舍友出去抽了烟，烟雾在他面前渐渐消失在公路上，他仰了仰头，眼前一座座高楼大厦，他有深深地吸了一口烟，吐了口唾沫，顺势丢掉烟头，一脚踩了灭。\n2024.11.6\n八\r自福你好啊，听说你因身体原因辞了工作回家调养，我很担心，望你早日康复！\n最近因工作原因，我出差去了桂林市，从深圳到桂林差不多四个小时，下了桂林北站，沿着只是标语找到公交车去了公司预先预定的民宿，民宿单人间十多平米，这座城市在迎来晚霞过后变得很热闹，及时在七楼也能听清他们在楼下的交谈——或许也是房间隔音差——我下楼想去感受一下这座城市，因为在我上学那会就早有耳闻，最多的得数那一句——桂林山水甲天下。走出民宿小区可以，一辆辆电车排成一条条线，在两侧的车道来回行驶，你需要停下注意看来往的车辆，就像等待红绿灯一样等待他们走过，但是这样的情况只有在上下班的时候会遇到，我穿过车道后，在地图上找了两公交站，往市中区我打算去哪尝一下当地的美食，在车上遇到的大部分是老人，大部分都已七八十岁，这么晚还出远门估计是为了去公园散步，我经常能在公园或广场看到他们在哪打牌、聊天、唱歌和跳广场舞，这大概是每一座城市都有的景象吧！\n我下车后，买了瓶水就去吃了晚饭，可惜我最终也没去找当地的美食，以来是我不太了解，而且也没在网上查，我太饿了随便找了一家店吃了饭，晚饭过后我去与公司的同时在公园里汇合，说着我们谈到了明天的工作，说真的我不太喜欢这种情况下谈论工作，我真想把所有的工作抛之脑后，但是很快微信群的一条条消息打破了我这样的幻想，我看着公园里的人们漫无目的的散步，不知为何我有些羡慕，这种羡慕让我不由自主的想起了在学校的生活，每天只有学习的烦恼，而现在却不一样，具体不一样在哪呢……同时的话打断了我的思绪，明天应该要去现场，可能到时候才能确定具体做什么。我示意明白，因为突然的会议让我们不得不停止这次的散步，我们两打车回了民宿，回民宿的第一时间就是把电脑开好，点击会议链接，正忙着，林质给我打了条微信，林质是我的大学同学，我们微信寒暄几句后，他请求我帮他的表弟在桂林这边找一下房租，其实我也是第一次来桂林，对于桂林这个地方也是很陌生。\n但很巧的是我的同事就是桂林的，或许他能帮我，我在询问好同事确定-可以帮助后，回了他消息，来来回回的消息沟通让我对刚才的会议内容一知半解，到现在还不知道明天的工作内容，说实话自己其实很在意——总算在人事部询问道了工作内容，自己这才定下心，写下这封信。\n今天就到这，我可能也是累了，很多趣事或许智能灯后续再告诉你了。\n2024.11.12\n八\r我的朋友你好啊！\r上一封信中我提到，自己去了桂林，或许你还记得吧！我想着自己可以好好的趁着这次机会好好的逛一下桂林这个地方，我和同同事鑫凯接到要开会，便不在公园停留，打了车回到公司安排的民宿，民宿两室一厅，进门左边是我的房间，进去往左一躺，柔软的被褥让我想马上拖鞋入梦，但是睁眼，天花板的环形灯的光线指引我往窗前，电脑就在窗前，我起身打开了电脑，试着在微信中千百条信息中找一找会议号，一番折腾总算进入了会议，会议似乎已经进行一段时间，之间画面中的两位领导合上了电脑，看上了大屏幕，接着说要抽查刚才的学习内容，我一时心惊胆战，当提到我们部门时，心跳变得更快，我忙着找找刚才都有说什么，一无所获只会让我更不安，但是不寻找我似乎会更不安，当部门同事回答完后，在群里发了——吓得只冒冷汗。我才知道结束了……\n我想以后就是这样的工作，忙碌了一天，到了晚上还要参加会议，写会议报告或工作报告，或对明天的工作做出计划，在睡觉前的时间在刷刷视频，这样一天就过去了。\n第二天，鑫凯早早叫醒我，说什么都想带我去尝尝桂林的米粉，桂林米粉早就名声在外，我在上初高中的时候，学校外的路边摊就有几家，我也试着吃过几次，说实话没有想象中的好吃，那时候的米粉又圆又粗，吃着吃着不是被拉倒劝退味蕾，就是吃到一半有些腻味，吃不下，所以在外面\n",
    "description": "",
    "tags": [
      "书信"
    ],
    "title": "7.致自福的一封信",
    "uri": "/textbook/7.%E8%87%B4%E8%87%AA%E7%A6%8F%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: X1-小说",
    "uri": "/categories/x1-%E5%B0%8F%E8%AF%B4/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 书信",
    "uri": "/tags/%E4%B9%A6%E4%BF%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B3-毕业设计",
    "uri": "/categories/b3-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: OneNet",
    "uri": "/tags/onenet/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目",
    "content": "目录\n运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 收藏的一些资料 最终的操作结果 ESP32\u0026\u0026ESP8266-12E连接ONeNet参考资料 ONeNet云平台报错： {“protocol”:“MQTT”,“offline_time”:“2024-07-15 16:01:49.977”,“offline_reason”:“CloseDueToProtoError”}怎么解决？ APP连接ONeNet json数据解析步骤 STM32+电脑(模拟ESP32)+ESP8266通信 设备热点配网技术——WIFIManager 报错：error: ‘wifi_country_t’ does not name a type const wifi_country_t WM_COUNTRY_US{“US”,1,11,WIFI_COUNTRY_POLICY_AUTO}; 通信过程中遇到的问题 这一部分所用到的资料下载地址 【实验】SPIFFS文件系统的使用 【实验】TCP/UDP通信实验 【STM32F4学习】摄像头 参考资料 STM32F4工程代码 【服务器】NGINX 在Linux中搭建NGINX服务器 TCP/IP协议 [知识储备] NGINX架构 NGINX中master的工作原理 nginx处理HTTP请求的过程 安装NGINX 【服务器】Tomcat 【服务器】ZLMedaikit流媒体服务器 【第三方库】FFmpeg媒体流转码工具 【深度学习】飞桨paddlepaddle实战 X-CUDE—AI在线课程 相关论文参考 【机器学习】HMM模型（隐马尔科夫列） 相关论文参考 导入库 【音视频学习】 H.264编码 安卓音视频实战编程 YUV RTMP协议所在所在的网络层结构 【第三方库】LIBRTMP 【工具】类似安卓虚拟机：Total Control 采集音频数据工具 视频采集工具—MediaProjection 【安卓APP制作】 安卓的两种登录方式 安卓中集成第三方库进行登录 安卓显示ONENet提供的可视化链接 硬件系统 运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 参考视频\n1.进入OneNet创建产品和设备（具体步骤待补充）\n2.复制产品和设备的详细信息（备份）\n目的是为了方便使用AT指令以及代码编写。\n设备名称(clientlD) : test 产品ID (username) : F1AVyfXw7l password: version=2018-10-31\u0026res=products%2FF1AVyfXw71%2Fdevices% 2Ftest\u0026et=2810313321\u0026method=md5\u0026sign=EfJtPPxHwMX6iWWf3YksbA%3D%3D.urI:mqtts.heclouds.com 端口号:1883 订阅: $sys/F1AVyfXw7I/test/thing/property/post/reply发布: $sys/F1AVyfXw7l/test/thing/property/post 设备密钥: cjFZSWRwUGNrazdRR2d6eTJ4Tm9YNXN5bTNuMGpMTIE=access key: vclTl19loOn7mcfdtT39l1eRfVffM6FfH8U/U3HhUQc= res:products/F1AVyfXw7l/devices/test et:时间戳收藏的一些资料 OneNet云平台 2.时间戳 OneNet文档中心 最终的操作结果 ESP32\u0026\u0026ESP8266-12E连接ONeNet参考资料 云平台调试错误码 设备之间数据交换实战项目 wifi.h库 SCND文章 代码部分唯一不同的是引用的库函数不同，\nESP8266使用的是\n#include \u003cESP8266WiFi.h\u003eESP32使用的是\n#include \u003cWiFi.h\u003e在使用时需要注意引用的库函数，如果库函数不匹配，可能会导致编译失败，这部分的代码以放在附件中。\nESP-12EConnectONenet是ESP8266-12E连接ONeNet的代码； ESP32ConnectONenet 是ESP8266-12E连接ONeNet的代码。 **注意：**我提供的代码是以onejson格式上传的，而不是数据流的格式。在云平台创建产品时需要注意这点，当然代码里博主写的就是以数据流格式上传，如果你用原来博主写的，那么创建产品时就选数据流。\n上面的代码只能实现数据上传，并不能实现命令控制，下面就介绍如何实现命令控制。 主要修改的地方是callback函数，当拿到topic的时候要解析拿到一段ID，具体可以看官方的资料,里面有提到命令下发的操作。 ONeNet云平台报错： {“protocol”:“MQTT”,“offline_time”:“2024-07-15 16:01:49.977”,“offline_reason”:“CloseDueToProtoError”}怎么解决？ 这个错误是协议格式不对，也就是用的topic不正确，通过下面的案例对这个作说明。\n当我们在云平台下发命令的时候，在callback函数里使用Serial.println(topic);会打印订阅的topic，格式为:\n$sys/584938/onenet_mqtt_dev1/cmd/request/c5a7e27e-05bb-41eb-972b-abce424ade8ecallback函数如下：\n/******************************************************************************** 函数：callback 功能：接收ONeNet传回的信息 返回值：无 参数： topic是消息的主题， payload是消息的有效载荷（数据部分）， length是payload的长度 *********************************************************************************/ void callback(char *topic, byte *payload, unsigned int length) { Serial.println(\"message rev:\"); Serial.println(topic); // 打印订阅的topic const char* lastSlash = strrchr(topic, '/'); if (lastSlash != NULL) { const char* cmdId = lastSlash + 1; // 命令ID位于最后一个'/'之后 msgid = String(cmdId); //将命令ID复制给msgid，msgid定义为全局变量 } Serial.println(msgid); // 打印拿到的ID if (strstr(topic, ONENET_GET_CAM_REQUEST)) //ONENET_GET_CAM_REQUEST=\"$sys/{产品ID}/{设备名}/cmd/request/\" { DynamicJsonDocument doc(100); DeserializationError error = deserializeJson(doc, payload); if (error) { Serial.println(\"parse json failed\"); return; } JsonObject setAlinkMsgObj = doc.as\u003cJsonObject\u003e(); serializeJsonPretty(setAlinkMsgObj, Serial); String cam = setAlinkMsgObj[\"cam\"].as\u003cString\u003e(); Serial.println(\"@\"+cam); //取出下发的命令并在前面加@ char RESPONSE_TOPIC[100]; sprintf(RESPONSE_TOPIC, \"$sys/{产品ID}/{设备名}/cmd/response/%s\",msgid.c_str()); client.publish(RESPONSE_TOPIC, \"OK\"); // 向平台响应OK }else { Serial.println(\"GET_CAM faile!\"); } }这份代码是根据一位博主的代码改的（博主文章链接），取出后面的ID用如下代码即可\nconst char* lastSlash = strrchr(topic, '/'); if (lastSlash != NULL) { const char* cmdId = lastSlash + 1; // 命令ID位于最后一个'/'之后 msgid = String(cmdId); //将命令ID复制给msgid，msgid定义为全局变量 } Serial.println(msgid); // 打印拿到的ID 而这个时候我们需要响应这个命令用的是\n$sys/584938/onenet_mqtt_dev1/cmd/response/c5a7e27e-05bb-41eb-972b-abce424ade8e一个是request，一个是response，所以在拿到下发命令的topic后要取出后面跟着的ID，然后再重新拼接在$sys/584938/onenet_mqtt_dev1/cmd/response/后面，然后用这个拼接的topic发送响应数据给云平台。\n这个时候就能在云平台那看到类似如下信息：\n一般格式错误返回的错误码是15，原因就是格式有问题。使用如下的格式上传响应都可能有问题：\n1.$sys/584938/onenet_mqtt_dev1/cmd/response/\n2.$sys/584938/onenet_mqtt_dev1/cmd/response/+\n3.$sys/584938/onenet_mqtt_dev1/cmd/response/+/+\n以上内容仅供参考，如果你有更好的方法，请在评论区告诉我。\nAPP连接ONeNet 1.内含demo 2.新版视频地址 3.json格式化网站 4.Android Okhttp3的使用（很全面，包含Post提交字符串、键值对、表单、上传文件、无参请求和Get有参无参请求，还有自动添加token） 从json中取出数据,结合第一点看 5.云平台调试错误码 在B站上学习OKHTTP3，我把主要的核心代码放在附件里，分别是get和post的同步和异步请求，返回的结果和视频地址2里讲的一样。\n视频地址1, 视频地址2 在编写HTTPS网络请求（post）时需要上传一些数据，这些数据有一定的上传格式，下面的网址汇总了上传格式content参数\nHTTP的content格式汇总网址 2024.8.19\njson数据解析步骤 方法一：\n方法二：\n使用第三方库Gson,在使用前需要创建一个Jsonbear，就是接收Jsons数据的格式。\n总结：\n在Android Studio中，如果你想要生成代码，例如getter和setter方法，可以使用快捷键Alt + Insert（Windows/Linux系统）或Command + N（Mac系统） 。这个快捷操作会引导你通过一个菜单来选择想要生成的代码类型，比如构造函数、toString方法、以及各种重写方法等。\n此外，如果你需要查看某个方法的参数信息，可以使用快捷键Ctrl + P（Windows/Linux系统）或Command + P（Mac系统），这将展示出当前方法的参数列表及其类型。\nSTM32+电脑(模拟ESP32)+ESP8266通信 STM32————电脑：串口1（PA 9 PA10）,手机连接指定热点，连接成功后等待一段时间把摄像头的网址发给单片机，单片机通过串口2发给ESP8266.ESP8266再传到OneNet上。\n注意：在用ESP8266最小系统通信的时，需要给板子单独供电，否则通信可能失败，原因我想可能是因为电压不够。\n设备热点配网技术——WIFIManager 这个配网技术是让开发板设置热点，然后让手机连接，连接好后配置要让开发板连接的WIFI和密码，这个技术叫设备热点技术。相比于以往的一键配网技术，我个人觉得这个设备热点配网技术成功率要要一些。\n缺点是这个技术不能用AT指令来实现，所以目前AT指令在不配合其他设备的情况下，通常都使用一键配网技术。\nESP32和ESP8266使用设备热点配网技术的区别\n区别一：使用的WiFi库不同，ESP32使用WiFi.h，而ESP8266使用ESP8266WiFi.h 区别二：使用的WiFiManager.h版本不同，ESP32使用2.0.17(目前这个版本是最新的)，而ESP8266使用0.16或0.15 在使用ESP32时，请使用目前最新版的wifimanage库，而使用ESP8266的话请使用0.15或0.16版本的WIFIManager，如果ESP8266使用最新版的可能会报错。报什么错呢？ 报错：error: ‘wifi_country_t’ does not name a type const wifi_country_t WM_COUNTRY_US{“US”,1,11,WIFI_COUNTRY_POLICY_AUTO}; 完整报错如下：\nd:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:162:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_US{\"US\",1,11,WIFI_COUNTRY_POLICY_AUTO}; ^ d:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:163:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,WIFI_COUNTRY_POLICY_AUTO}; ^ d:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:164:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,WIFI_COUNTRY_POLICY_AUTO}; ^这个错误我目前没有解决，如果你解决了还请评论区或邮件（3256149770@qq.con）告诉我。\n通信过程中遇到的问题 keil5中一点击下载就闪退或点击debug中的setting就闪退。参照文章\nKeil5编程之warning: #223-D: function “xxx“ declared implicitly.参考链接\n这一部分所用到的资料下载地址 正点原子AKT-ESP-Fwifi模块 2024.8.12(更新).\n【实验】SPIFFS文件系统的使用 参考地址\n【实验】TCP/UDP通信实验 参考地址\n【STM32F4学习】摄像头 参考资料 基于STM32F407的摄像头（不带FIFO的OV7670）图像采集及LCD显示实验-笔记整理 STM32F4驱动OV7670总结 基于stm32f407vgt6驱动ov7670的TFT实时视频显示 STM32F4工程代码 使用三个ADC通道要注意按顺序去初始化，否则可能会出现问题，运营我还不知道.\n【服务器】NGINX 在Linux中搭建NGINX服务器 TCP/IP协议 [知识储备] 在线自动生成nginx配置文件的网站\n可以自由选择所需的应用，生成nginx配置作为参考。 根据你的业务需求，自动生成复杂的nginx配置文件，提供你作为参考，非常好用 NGINX架构 NGINX中master的工作原理 nginx处理HTTP请求的过程 安装NGINX 安装路径：https://blog.csdn.net/u011715638/article/details/138670319\nserver { listen 80; listen [::]:80; server_name example.com www.example.com; root /var/www/html; index index.html index.htm; location / { try_files $uri $uri/ =404; } }上面是配置文件的内容，下面说明一下配置时的一些注意事项：\n把配置文件的example.com www.example.com换成172.0.0.1，这样方便在本地测试； 在Ubuntu中可以下载ifconfig来查看Ubuntu的IP地址（ip addr也可以） 每次修改配置文件记sudo systemctl reload nginx 【服务器】Tomcat 1.安装Tomcat要使用哪个版本的java？\n使用jdk8或更高版本，详细参考官方文档\n2.如何在Ubuntu安装Tomcat？\n安装jdk8或更高版本 安装 【服务器】ZLMedaikit流媒体服务器 需要掌握的知识点： 【第三方库】FFmpeg媒体流转码工具 Ubuntu上安装ffmpeg的方法 下载ffmpeg源代码地址 【深度学习】飞桨paddlepaddle实战 2024.8.18\n1.从入门到实际运用，请参考B站up主视频：点击链接\n2.学完上面的视频后学习paddlepaddle的语音识别课程：\n3.接着参考STM32cudeXM.AI的相关知识，把模型转换成onnx格式然后在但【单片机上运行：\n3.1先用一个项目练练手：https://shequ.stmicroelectronics.cn/thread-632736-1-1.html\n官网 入门手册文档 官网视频 B站视频 意外收获，这是一个学习论坛：https://www.waveshare.net/study/portal.php?mod=list\u0026catid=38\n2024.8.25\n参考文献：\n禹鑫鹏,贺庆,王世昕,.基于STM32CubeMX AI和NanoEdge AI的眼动信号分类效果对比研究【J】.传感器世界,2024,(04):6-10. 2024.8.26\nX-CUDE—AI在线课程 参考地址\n当模型验证结束后，需要修改以下内容： 相关论文参考 【github项目网址】婴儿哭声分类识别 【机器学习】HMM模型（隐马尔科夫列） 隐马尔科夫列模型定义： 相关论文参考 -【1.基于声学的婴儿哭声识别细分市场模型】(Baby Cry Recognition Based on Acoustic) -【2.使用隐马尔可夫模型自动分割婴儿哭闹信号】(Automatic segmentation of infant cry signals using hidden Markov models)\n导入库 【音视频学习】 H.264编码 所谓视频编码就是指通过特定的压缩技术，将某个视频格式文件转换成另一种视频格式文件的方式。\n视频流传输中最重要的编解码标准有国际电联(TU-T，国际电信联盟)的H.261、H.263、H.264等，运动静止图像专家组（由ISO国际标准化组织与IEC国际电子委员会于1988年联合成立)的MPEG系列标准MPEG1、MPEG2、MPEG4 AVC等。\n其中ITU-TH.264/MPEG-4 AVC是ITU-T与ISO/IEC连手合作制订的新标准。ITU-T方面称之为H.264。但ISOIEC的则将这个新标准归纳于MPEG系列,称为MPEG-4 AVC。\n而H.265则被视为是ITU-TH.264/MPEG-4AVC标准的继任者，又称为高效率视频编码(High Efficiency VideoCoding，简称HEVC)\n格式： 安卓音视频实战编程 构建预览布局-使用SurfaceView或者TextureView\n打开相机- Camera.open\n设置参数- Camera.Parameters\n设置预览数据回调- PreviewCallback\n设置预览画布并启动- setPreviewTexture/startPreview\n释放相机- stopPreview/release\nYUV YUV主要应用于优化彩色视频信号的传输，与RGB相比，YUV只需要占用极少的频宽(RGB需要三个独立的视频信号同时传输)。YUV中Y代表明亮度，也称灰阶值;U与V表示的则是色度（色调和饱和度)也可以记作:YCbCr。如果只有Y数据,那么表示的图像就是黑白的。\n使用YUV的原因：\n使用YUV格式才能极大地去除冗余信息，人眼对亮点信息更敏感，对色度敏感度不高。也就是说,可以压缩UV数据,而人眼难以发现。所以压缩算法的第一步，往往先把RGB数据转换成YUV数据。对Y少压缩一点，对UV多压缩一点，以平衡图像效果和压缩率。这也是为什么编码选择使用YUV而不是RGB。\n推算公式： YUV是一组数据的压缩格式，其下还有因为排列不同而衍生的不同格式名称\nNV21转I420 MediaCode组件： RTMP协议所在所在的网络层结构 【第三方库】LIBRTMP 【工具】类似安卓虚拟机：Total Control 采集音频数据工具 视频采集工具—MediaProjection 安卓P18\n2024.8.27\n方法一：\n安卓使用VLC库实内网播放ESPCam摄像头数据\n方法二：\nMediacode编解码\n【安卓APP制作】 1.安卓登录开发\n2024.8.21\n安卓的两种登录方式 登录可以进去就强登录，或进去后在某个页面触发登录。\n对于第一个只需要在第一个页面做登录处理即可，而第二种需要Hook AMS + APT框架实现，具体看这篇博文：文章连接\n安卓中集成第三方库进行登录 可以使用目前比较流行的第三方库实现：\nJustAuth开源组件：JustAuth是一个整合了国内外数十家知名平台的OAuth登录的开源组件，它提供了丰富的OAuth平台支持，自定义State、自定义OAuth、自定义Http接口和自定义Scope等功能，极大地简化了开发者在第三方登录功能上的工作量。\n2024.8.23\n2.数据显示\n安卓显示ONENet提供的可视化链接 参考链接\n2024.8.29\n硬件系统 一、设备选型\n1.空气质量模块设备选型：\n（1）MQ135测量空气质量和氨气PPM的计算\n附件 ESP-12ConnectOnenet.c (7 KB) ESP32ConnectOnenet .c (7 KB) https.java (2 KB) ",
    "description": "",
    "tags": [
      "OneNet"
    ],
    "title": "毕业设计",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 11.哲学",
    "content": "波若波多密的意思 波若：彼岸 波多：抵达（渡）\n意思是抵达彼岸\n波若波多密的方法 布施 财布施：用钱去帮助亲人或他人 法布施：如教师的职业，教授别人知识 无畏布施：例如医生的职业。救死扶伤；还有士兵。 持戒 律仪戒： 摄善法戒：行善戒。用权利与义务可以更好理解这个意思，权利告诉我们不可以做什么，做了就是侵犯别人的权利，义务就是告诉我们我们必须做什么。但也不要把这个意思理解死。 饶益有情戒：发现别人需要帮助并在自己力所能及的范围内去帮助别人。多方式帮助人或动物。 安忍 耐怨害忍：受到别人的伤害，诋毁等时要能忍。（这也是一种修行）需要辩证看待这件事 安受苦忍：人生是痛苦的，要能忍耐（又是一种修行） 谛察法忍：精研佛法 精进 勇猛精进，在佛学的修持上不畏惧、不退让、持之以恒\n禅定（一种状态） 进入禅定这个状态，也叫缘（）缘起，无漏智，断烦恼，证真如；\n",
    "description": "",
    "tags": [
      ""
    ],
    "title": "心经",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/%E5%BF%83%E7%BB%8F/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "设置自动保存 打开程序点击系统设置，如下图：\n按照下图步骤设置自动保存，每10分钟保存一次（你也可以设置成其他的，但不建议设置太小或太大比如1分钟或者30分钟）\n设置单一’'表示负信号 按照下图设置\n设置显示对话框 我设置前\n当把上面的打钩后\n[外链图片转存中…(img-ZngLHveL-1719559556141)]\n按住shift+h可以显示和关闭\n[外链图片转存中…(img-bxjUhYCS-1719559556142)]\n[外链图片转存中…(img-qKvH9IRn-1719559556142)] [外链图片转存中…(img-HAD9BmgV-1719559556142)]\n",
    "description": "",
    "tags": [
      ""
    ],
    "title": "14.初次安装AD需要做哪些设置？",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/14.%E5%88%9D%E6%AC%A1%E5%AE%89%E8%A3%85ad%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E8%AE%BE%E7%BD%AE/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r高考在即，在收到学校放假的通知后，我于第二日乘班车回了家。\r在隔壁县读书的我，每次回家都要乘上4-5小时的班车，回家的路上能见到一片又一片的砂糖橘，我的家乡被誉为“沙滩橘之乡”，最近几年村里也开始陆陆续续的种起砂糖橘。\n往常放假可以去捡板栗、可以和父母去工地、也可以在家护理果树……在闲暇的时光里给自己挣点零花钱，但这次则不同，放假时间短，最多被拉去护理果树，我已经做好这样的觉悟，虽然很不情愿。\n在外面读书久了，似乎做农活的性子也被磨平了。\n回家的第二天我陪同母亲去抽水，母亲说我回来的正是时候，可以去抽水给果树打药。我和母亲在外面折腾了半天，父亲才从房屋出来，慵懒地生了个懒腰，观望着我们母子，似乎等待谁发号施令，“你和你父亲把抽水机扛到山沟下的池塘。“母亲对着父亲说道。我和父亲一颠一拐地把抽水机扛到山沟下。随着启动抽水机一天的工作开始了。\n抽水需要用到的管子要提前铺好，我和母亲扛着一捆捆管子往山里去，在路上我们遇到了刘三，他是刘叔公的三儿子，\n待续……\n",
    "description": "",
    "tags": [
      "农村"
    ],
    "title": "刘丰三郎",
    "uri": "/textbook/6.%E5%88%98%E4%B8%B0%E4%B8%89%E9%83%8E/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 农村",
    "uri": "/tags/%E5%86%9C%E6%9D%91/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "物联网主要解决什么问题?- 主要解决物品到物品（T2T）、人到物品（H2T）、人到人（H2H）之间的互联，核心共性技术、网络与信息安全技术、以及关键技术是物联网当前主要的研究方向\n物联网的安全特性 从物联网的信息处理来看，数据信息要经过采集、汇聚、融合、传输、决策与控制等过程\n物联网的功能特点 全面感知能力 数据信息的可靠传输 智能化处理 可以根据各个行业、各种业务的具体特点形成各个不同的应用或系统的应用解决方案 数据加密中出现的攻击——旁路系统是什么 攻击者可能试图通过旁路系统，如物理地取走数据库，在通信线路上窃听，面对这样的威胁最有效的方式是对数据进行加密，以加密的格式存储和传输数据。\n数字签名的使用 鉴权：非对称秘钥加密系统允许每一位发送数据的用户使用公钥进行数据加密，数字签名能够让信息接受者确认信息发送者的身份 验证完整性：数据传输的双方都希望数据在传输的过程没有被修改 保证不可抵赖性： 在密文的背景下，抵赖这个词指的是不承认与消息有关的举动（即声称消息来自第三方）。消息接受方可以通过数字签名的方式来抵制后续的抵赖，因为接收方可以出示数字签名证明数据的来源。 节点认证机制中的PKI是什么？ KPI是遵循既定标准的秘钥管理平台，它能够为所有的网络应用提供加密和数字签名等密码服务，以及必要的秘钥和证书管理体系。 简单来说KPI是利用公钥的理论和技术建立的提供安全服务的基础设施。\n路由协议的安全威胁 路由协议 安全威胁 TyniOS信标 虚假路由攻击、选择性转发攻击、污水池攻击、女巫攻击、虫洞攻击、Hello泛红攻击 定向扩散 虚假路由攻击、选择性转发攻击、污水池攻击、女巫攻击、虫洞攻击、Hello泛红攻击 地理位置路由 虚假路由攻击、选择性转发攻击、污水池攻击、女巫攻击 最低成本转发 虚假路由攻击、选择性转发攻击、污水池攻击、女巫攻击、虫洞攻击、Hello泛红攻击 谣传路由 虚假路由攻击、选择性转发攻击、污水池攻击、女巫攻击、虫洞攻击 能量节约的拓扑维护（SPAN、GAF、CEC、AFECA） 虚假路由攻击、女巫攻击、Hello泛红攻击 聚簇路由协议（LEACH、TEEN） 选择性转发攻击、Hello泛红攻击 SPAN、GAF、CEC、AFECA 是网络拓扑维护中用于节约能量的几种不同策略或算法的缩写。它们主要用于无线传感器网络（WSN）或其他类型的网络中，以优化网络结构，减少冗余，延长网络寿命，从而节约能量消耗。下面是每个缩写的具体含义：\nSPAN (Sparse Topology Control):\n稀疏拓扑控制。SPAN 是一种拓扑控制算法，旨在通过创建一个稀疏的网络拓扑来减少节点间的消息传递，从而降低能量消耗。这种方法通过选择性地关闭一些节点或链接来减少网络的密集度，但同时保持网络的连通性。\nGAF (Geographic Adaptive Fidelity):\n地理自适应保真度。GAF 是一种基于地理位置信息的拓扑控制机制，它根据节点的地理位置和重要性来调整通信频率和范围。在 GAF 中，节点根据其地理位置和网络需求动态调整它们的通信行为，以减少不必要的通信和监听，从而节省能量。\nCEC (Critical Energy Consumption):\n关键能量消耗。CEC 可能指的是一种考虑网络中关键节点或链接的能量消耗的策略。这种策略旨在识别和优化那些对网络性能和稳定性至关重要的节点或链接的能量使用，以确保网络的关键部分能够在能量受限的情况下继续运作。\nAFECA (Adaptive Fault-tolerant Energy-efficient Clustering Algorithm):\n自适应容错节能聚类算法。AFECA 是一种聚类算法，它结合了容错机制和能量效率，以适应网络条件的变化。通过自适应地调整聚类结构和领导者选举，AFECA 旨在在保持网络稳定性的同时减少能量消耗，并提高网络的容错能力。\n撒凯加密 撒凯加密法的分明文和密文，密文计算公式如下：\n公式：F(a)=(a+K)mod26。\n加密技术分类 对称加密技术：是一种传统的加密体制，也称为私钥密码体制。在这一体制中加密和解密使用相同的秘钥。\n对于N个用户网络，需要n(n-1)/2个秘钥。\n对称加密算法 DES（Data Encryption Standard，数据加密标准）该算法速度快，适用于加密大量数据。\n3DES：是DES的变体，对同一块数据使用3个不同的秘钥进行3次加密，强度增强。\nAES（Advenced Encryption Standard，高级加密标准）：该算法基于排序和置换算法。它也是一种迭代的、对称加密分组的密码，它可以用128、192和256位秘钥，用128位的分组加密和解密。\n单向扩散列函数 在实际生活中，采用公钥对长文件进行加密耗时，为节省时间数字签名协议经常和单向扩散列函数一起使用。 Alice并不对整个文件进行签名，而是只对三设置签名。签名过程参照书籍61页\n零知识证明的基本协议 这里做一个比喻，假设P知道开一扇门的密码，现在想向验证者V证明自己知道这扇门的密码，但具体密码是多少不让V知道，那么验证方法就是去开这扇门，只要P开了门就可以证明P知道门的密码。\n下面是书本的证明步骤： V站在A点。 P进入洞中，到达C点或D点 P点进入洞中之后，V走到B点； V叫P信左边或右边出来 P按照V的要求从左边或有边出来； P和V重复执行上面的步骤N次 如果每次P走的都正确，则认为P知道咒语。\n标签和读写器的通信模式 标签分类及其特点\n分类 能量来源 发送器类型 最大距离/cm\r被动式标签\r被动式\r被动\r10 主动式标签\r内部电池\r主动\r1000 半主动式标签\r内部电池\r被动\r100 标签分类及其功能\n分类 能量来源 别名 存储\r特点\rclass0\r被动式\r防盗窃标签\r无 EAS功能\rclass1\r任意\rEPC（电子产品标签）\r只读 仅用于识别 class2\r任意\rEPC（电子产品标签）\r读写 数据日志记录 class3\r内部电池\r传感器标签\r读写 环境传感器 class4\r内部电池\r智能颗粒\r读写 自动组网 RFID病毒 2006年3月荷兰Vrije大学一组计算机研究员宣布，发现包括EPC标签在内的RFID标签可以携带病毒，并能攻击计算机。他们认为，可读写的电子标签存在着安全隐患。\nRFID系统通信模型 这一个模型的物理层主要关心的问题是什么？\n物理模型主要关心电气信号的问题，例如频道分配、物理载波等，其中最重要的问题是载波切割问题。 其他层关注的问题：\n通信层主要解决多个标签的访问问题。\n应用层主要解决与最上层应用直接相关的内容，包括认证、识别、以及应用层数据表示。\nRFID技术中EPC系统的安全问题 EPC（电子产品标签）\n标签本身的缺陷 用户都可以利用合法的读写器或自购的读写器对电子标签进行读写或修改里面的存储信息。 支持EPC global标准的无源标签大多数只允许写入一次，但是支持其他标准（ISO标准）的RFID标签可以写入多次； 电子标签可以写入多次带来便利的同时，也带来了很多安全隐患。 通信链路上的安全问题 黑客非法截取通信 拒绝服务器攻击（Dos） 利用假冒标签向读写器发送数据 RFID读写器与后台系统之间的通信信息安全 采用密码机制解决RFID安全问题 几种常用的密码机制协议：\nHash-Lock协议 随机化Hash-Lock协议 Hash链协议 基于散列的ID变化协议 数字图书馆RFID协议 分布式RFID询问-应答协议 LCAP协议：也是一种询问-应答协议，只是每次执行之后都要刷新ID 再次加密机制 传感器网络组网技术面临的安全问题 网络层次 受到的攻击 物理层 物理破坏、信道阻塞 链路层 制造冲突攻击、反馈伪造攻击、链路阻塞耗尽攻击 网络层 路由攻击、虫洞攻击、女巫攻击、HELLO泛红攻击 应用层 去同步攻击、拒绝服务攻击 传感器网络中的攻击和防疫手段 网络层次 攻击手段 防御手段\r物理层 阻塞攻击 调频、消息优先级、低占空比、区域映射、模式转换\r链路层 物理破坏 伪装和隐藏\r冲突攻击 纠错码 耗尽攻击 设计竞争门限 非公平竞争 短帧和非优先级策略 网络层 丢弃和贪婪破坏 冗余路径探测机制 汇聚节点攻击 加密和逐条认证机制 方向误导攻击 出口过滤、认证监视机制 黑洞攻击 认证、监视、冗余机制 应用层 泛红攻击 客户端谜题 去同步攻击 认证 入侵检测技术 由于在物联网中依靠密码机制不能完全抵御所有攻击，所以采用入侵检测技术作为信息安全的第二道防线。\n入侵检测技术是一种网络安全手段，旨在通过监控网络和系统的活动来发现违反安全策略的行为。这项技术能够识别未授权访问、攻击行为以及其他潜在的安全威胁。\n按照检测节点是否主动发送消息，可将入侵检测分为主动检测和被动检测。\n主动检测主要有四种：\n路径诊断的方法：源节点向故障路径上的检测节点发送消息，收到消息的检测消息要回复消息，如果某一路径上的检测节点没有回复，说明这一路径上出现故障，需要在这一路经上插入新的节点，重新检测； 邻居检测的方法： 通过向多个路径发送ping包的方式发现路径上的关键节点，从而部署攻击检测算法； 基于主动信息提供的检测。网络中部分节点定期广播邻居节点信息，其他节点通过分析累计一定时间后的信息发现重复节点。 ZigBee网络结构 星状结构 网状结构 簇状结构 数据链路层安全 注意： 这里指的是ZigBee中的数据链路。\nIEEE802.15.4 标准MAC子层使用的是CCM模式，CCM是一种通用的认证和加密模式，被定义使用在类似AES的128位数据块上，它由CTR模式和CBC-MAC模式组成。\nZigBee中确保安全的方法 加密技术:使用AES-128加密算法 鉴权技术：保证信息的原始性，使得信息不被第三方攻击； 完整性保护：对信息的完整性保护有四种选择，分别是0、32、64和128位，默认采用64位； 无线通信网络安全中安全连接的三要素 鉴权：在信息被允许传输前，无线网络节点必须被识别，而且必须提交能够被认为有效的信任书； 加密：在发送无线网络的数据包之前，无线网络节点必须对数据进行加密以确保数据的机密性； 数据的完整性：在发送数据包之前，无线网络节点必须确保数据包中包含有关的数据完整性的信息，这样接收者才能确认数据在传输的过程中没有被动过。 无线网络安全所面临的威胁——地址欺骗和会话拦截 由于IEEE802.11无线局网不对数据帧进行认证，\n攻击者可以通过欺骗帧重定向数据流； 攻击者可以使ARP（地址解析协议）表变得混乱； 攻击者可以通过简单的方法获取节点的MAC地址，恶意攻击时会使用到这些MAC地址。 无线局域网安全技术之WEP IEEE802.11.b标准规定了一种 有线等效加密 （WEP）的可选加密方案，目的是为WLAN提供与有线网络相同级别的安全保护。 WEP在数据传输上起到一定安全性和保密性作用，可以组织无线用户无意地查看AT和STA传输的信息。 这个方案也有其缺点，这里只说明其中一个\nICV算法不适合。ICV是一种基于RCR-32的用于检测传输噪音和普通错误的算法。CRC-32是信息的线性函数，意味着攻击者可以篡改加密信息，并很容易修改IVC，使信息表面上看起来可信。 无线网络主流技术安全解决方案——WPA 主流解决方案有很多，这里只介绍WPA。\nWPA是下一代无线局域网标准IEEE802.11i之前的过渡方案，WPA也是IEEE802.11i的一部分。WPA率先使用IEEE802.11i中的加密技术——TKIP，这项技术可以大幅度解决IEEE802.11i使用WEP时隐藏的安全问题。\n互联网网络安全——防火墙的作用 阻止：阻止某种类型的通信量通过防火墙； 允许：允许与阻止相反。 防火墙的结构——屏蔽子网模式 简单而言就是在外网与内网之间建一个子网屏蔽网络，及时这个子网被攻陷，外网还是要经过内网路由。\nVPN在中国使用要解决哪些问题？ IPSec通过包封装的方法 建立隧道 IPSec VPN的类型 怎样找到VPN节点类型 如何建立隧道 UDP和TCP都可以穿过防火墙，即可以使用这两协议封装信息建立隧道，但是TCP有握手挥手过程，这一过程会占用时间，选择UDP更为合适。 选择好封装协议后，为避免两个节点VPN可能在防火墙之后的情形，需要通过第三方建立隧道传输信息，即两个设备都可以与第三个设备进行通信。 如何找到与本VPN相关的节点 中间件的体系结构和核心模块 附件 #\n",
    "description": "",
    "tags": [
      ""
    ],
    "title": "13.物联网网络安全论",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/13.%E7%89%A9%E8%81%94%E7%BD%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BA/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "基于Cortex-A9微处理器的硬件平台 RISC和CISC RISC是精简指令集计算机，CISC是复杂指令集计算机\nRISC（精简指令集计算机，Reduced Instruction Set Computer）和CISC（复杂指令集计算机，Complex Instruction Set Computer）是两种不同的计算机架构设计理念，它们在指令集的复杂性、指令执行方式、硬件实现等方面有所区别。以下是RISC和CISC的主要特点及其区别：\nRISC（精简指令集计算机） 指令集简单：RISC架构拥有较少的指令，通常每个指令执行一个简单的操作。 指令执行快速：由于指令简单，大多数RISC指令可以在单个时钟周期内完成。 寄存器丰富：RISC架构通常具有更多的寄存器，以减少对内存的访问次数。 流水线执行：RISC处理器设计易于实现流水线技术，提高指令吞吐率。 编译器优化：RISC架构依赖编译器将复杂操作转换为一系列简单的指令。 CISC（复杂指令集计算机） 指令集复杂：CISC架构拥有大量的指令，包括一些执行复杂操作的指令。 指令执行较慢：CISC指令可能需要多个时钟周期来完成。 寄存器较少：CISC架构通常具有较少的寄存器，更多依赖内存访问。 微指令执行：CISC处理器可能使用微指令（microcode）来实现复杂指令。 硬件复杂性：CISC处理器的硬件设计相对复杂，以支持广泛的指令集。 区别\n指令集大小：RISC的指令集较小，CISC的指令集较大。 指令复杂性：RISC指令简单，CISC指令复杂。 执行速度：RISC指令通常执行更快，CISC指令执行可能较慢。 硬件设计：RISC处理器设计相对简单，CISC处理器设计复杂。 内存访问：RISC架构倾向于减少内存访问，CISC架构可能更频繁地访问内存。 依赖编译器：RISC架构更依赖编译器优化，CISC架构则在硬件层面提供复杂操作。 ARM处理器支持的基本数据类型 数据类型：字、半字、字节。\n说明：\n一个字节占8位，半个字节占16位，一个字占32位； 在存储数据时，字要按照4个字节来存储，所以每一次存时地址都加4，地址末位是00，例如0x13FFFFF8,0x13FFFFFC， 在存储数据时，半字要按照2个字节来存，所以每一次存时地址都加2，地址末位是0，例如0x13FFFFF4,0x13FFFFF6，； ARM处理器的工作状态 主要有两种状态，主要区别就是执行的指令集位数不同；\nThumb状态，微处理器执行16位的半字对齐的Thumb指令集，Thumb指令集是从ARM微处理的第四个版本开始增加（v4T）； ARM状态，微处理器执行32位的字对齐的ARM指令集。 ARM存储格式 大端格式：高字节存储在低地址，低字节存储在低地址；\n小端格式:高字节存在高地址，低字节存储在低地址； 说明：\n对高字节和低字节可以这样理解，假设有一个32位的地址为0x13FFFFF1，它的高字节是31，也可以理解成最高那一位的下标，31这一位存了0，低字节是0存了1。把这个理解带入上面的大端格式，小端格式。\nARM处理器寄存器 共有40个32位的寄存器，其中33个通用寄存器，7个状态寄存器； 通用寄存器 未分组寄存器（R0-R7）； 分组寄存器（R8-R14）； ARM处理器的程序状态寄存器包括：CPSR（当前程序状态寄存器）和SPSR（程序状态备份寄存器） 中断 ARM工作模式 用户模式（usr）:应用程序执行状态。\n快速中断模式（fiq）：用于高速数据传输或通道处理。\n外部中断模式（irq）：用于通用的外部中断。\n特权模式（svc）：操作系统使用的保护模式。\n数据访问中止模式（abt）：当数据或指令预取终止时进入该模式，可以用于虚拟存储及存储保护。\n未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。\n系统模式（sys）：运行具有特权的操作系统任务。\n监控模式（mon）：可在安全模式与非安全模式之间转换。\n执行程序什么模式？\n读指令并执行，读取未定义指令什么模式？\n遇到特权任务什么模式？\n遇到中断什么模式?\n指令执行结束什么模式？\n3级、5级流水线 3级流水线指令可以分解成取指令、编译、执行； 5级流水线指令可以分解成取指令、编译、执行、缓冲、写回。 程序状态寄存器 CPSR中的[31:27]为条件标志位，具体含义如下：\nN：符号标志位。当用两个补码表示的带符号数进行运算时，N=1表示运算的结果为负数；N=0表示运算的结果为正数或零。 Z：结果是否为0的标志。Z=1，表示运算结果为0；Z=0，表示运算结果为非0。 C：进位或借位标志位。加法运算结果产生了借位时C=1，减法运算产生了借位时C=1，否则为0；包含移位操作的非加/减运算指令，C为移出值的最后一位；其他运算指令，C的值通常不变。 V：溢出标志位。对于加减法运算指令，V=1表示符号位溢出，其它指令的影响V位。 CPSR中的[7:0]为控制位，具体含义如下：\nI：IRQ中断使能位； F：FIQ中断使能位； T：处理器运行状态控制位； M[4:0]：运行模式位。 其它标志位。\nARM指令集条件域 EQ：相等，（CPSR）Z=1； GT：大于，Z=0\u0026\u0026N=Z; TF：小于等于，Z=1||N=Z； 寻址指令 数据处理指令 RSB 逆向减法，例如： RSB Rd Rn op2 ;op2-Rn赋值给Rd MUL 32位乘法，\nCMP 比较，例如\nCMP Rn op2 ;Rn-op2 MOV指令:它的传送指令只能是把一个寄存器的值(要能用立即数表示)赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量\nADD指令:ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。\nSUB指令:SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中\nSUB r0, r1, r2 ; r0 = r1 - r2 SUB r0, r1, #256 SUB r0, r2, r3, LSL#1 ; r0 = r2 - (r3 \u003c\u003c 1) LDR指令:LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中. 用法1： LDR r0, =0x20000000 用法2： LDR r0, =0x30000000\nSTR指令:STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。即：将前边的量赋值给后边的量。 STR r0，[r1] ; 将r0中的字数据写入以r1为地址的存储器中 STR r0，[r1], ＃8 ; 将r0中的字数据写入以r1为地址的存储器中，并将新地址r1＋8写入r1。 STR r0，[r1, ＃8] ; 将r0中的字数据写入以r1＋8为地址的存储器中。跳转指令 案例1 CMP R0， #0 MOVEQ R1， #0 MOVGT R1， #1 解：CMP R0， #0 ; 将R0的值减去0，并根据结果设置CPSR的标志位 MOVEQ R1， #0 ; 若R0等于0，Z=1，则将立即数0装入到R1 MOVGT R1， #1 ; 若R0大于0，Z=0，N=V，则将立即数1装入到R1程序实现的功能是判断R0的值与0的关系，将结果装入R1，若R0=0则R1=0，若R0\u003e0则R1=1.用C语言描述如下。 设R0对应变量a，R1对应变量b，\nif(a==0) b=0; else if(a\u003e0) b=1; 案例2 对程序各条指令进行注释，最后分析整个程序的功能。\nAREA\tExample1,CODE,READONLY\t; 声明代码段Example1 ENTRY\t; 标识程序入口 CODE32\t; 声明32位ARM指令 START ; 标号/标签 MOV R0, #0\t; 设置参数，R0=0 MOV R1, #10 ; 设置参数，R1=10 LOOP ; 标号/标签 BL ADD_SUB\t; 调用子程序ADD_SUB B\tLOOP\t; 跳转到LOOP ADD_SUB\t; 标号/标签 ADDS R0, R0, R1\t; R0 = R0 + R1，并根据结果设置CPSR的标志位 MOV\tPC, LR\t; 子程序返回，PC=LR END\t; 声明文件结束整个程序的功能：程序实现了一个死循环，每次循环R0都增加10。\nLInux编程基础 GCC编译的4个过程的主要功能 预编译：主要功能是读取源文件，并对头文件预编译语句和一些特殊符号进行分析和处理； 编译：主要包括检查代码语法和将预编译后的文件转换成汇编语言； 汇编：主要的功能是将汇编语言的代码编程目标文件；（机器代码，0和1） 连接：主要功能是连接代码，生成可执行文件。 简述Make工具和Makefile的基本结构 Make又叫工程管理工具，即管理较多的工程文件。\n主要的功能:\n通过Makefile文件来描述源程序之间相互依赖的关系，并自动完成维护编译工作； 能够根据文件的时间戳发现更新的文件，可以减少编译工作； 基本结构：\ntarget ： dependency \u003ctab 键\u003e commandtarget:目标； dependency：依赖关系 command：命令\nMakefile变量 用户自定义变量 预定义变量 自动变量 后两个是系统的变量，是Makefile文件常用的变量，其中有部分变量用户可以修改。\n预定义变量 需要记住两个比较重要且常用的预定义变量，即\nCC：C编译器名称，默认cc CFLAGS：C编译器的选项，无默认值 自动变量（又叫系统变量） $@ :规则的目标所对应的文件； $\u003c：规则中的第一个依赖文件； $^:规则中所有依赖的列表，以空格为间隔符。 文件操作编程 C语言库中的fopen、fclose、fwrite、fread等函数。\n其实是由操作系统的API函数封装而来，如\nfopen内部其实调用的是open函数， fwrite内部调用的是write函数。 用户也可以直接利用Linux系统的API函数来完成文件操作编程\n在Linux操作系统下，用C语言实现文件操作可以采用哪两种方法？ 在LInux操作系统中，实现文件操作有两种方法，第一种是调用C语言标准库，第二种是通过Linux系统调用实现。前者独立于操作系统，在任何操作系统下使用C语言标准库函数操作文件，而后者以来于操作系统。\n时间编程 time函数 返回1970.1.1 0时到现在所经历的时间，操作失败返回((time_t)-1)\ngmtime函数 将日历转化为格林威治标准时间，结果存在结构体tm中。 在课堂上老师叫我们使用的并非上面这个函数，而是用localtime(const time_t *timep)这个函数,这个函数可以将日历转为本地时间，具体用法请看综合案例\ngettimeofday函数 获取从今日凌晨到现在的时差并存储在tv中，tz存放当地时区差；\n综合案例 （4）编写一个程序，将系统时间以“year-month-day hour:minute:second”格式保存在time.txt文件中。\n#include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003cfcntl.h\u003e #include\u003ctime.h\u003e #define MAX 40 int main() { int fd,n,ret; char writebuf[MAX]; struct tm *t; time_t lt; lt=time(NULL); t=localtime(\u0026lt); //将日历时间转化为本地时间 sprintf(writebuf,\"%d-%d-%d %d:%d:%d\\n\",t-\u003etm_year+1900,t-\u003etm_mon+1,t-\u003etm_mday,t-\u003etm_hour,t-\u003etm_min,t-\u003etm_sec); //按指定格式保存时间 /*打开文件，如果文件不存在，则会创建文件*/ fd = open(\"time.txt\", O_RDWR | O_CREAT); /*向文件写入字符串*/ ret = write(fd, writebuf, strlen(writebuf)); if (ret \u003c 0){ perror(\"Write Error!\"); return 1; } else { printf(\"write %d characters!\\n\", ret); } /*关闭时，会自动保存文件*/ close(fd); }多线程编程 基本用法 使用到pthread_createh头文件，以及libpthread.so和libpthread.a库文件；\npthread_create函数：创建线程 pthread_exit函数：退出线程 pthread_join函数：阻塞线程 互斥锁线程 解决多个线程在一起执行的时候共享数据、资源的问题。在POSIX中有两种线程同步机制，分别为互斥锁和信号量\npthread_mutex_init:初始化互斥锁 pthread_mutex_lock：互斥锁上锁 pthread_mutex_unlock：互斥锁释放 嵌入式开发交叉编译与系统移植 嵌入式软件调试方法 实时在线仿真 模拟调试 软件调试 片上调试 引导程序移植 操作系统运行前的一个程序，也就是启动程序。\nBoolLoader工作模式 启动加载模式 下载模式 BoolLoader启动过程 第一阶段 主要依赖CPU的体系结构硬件初始化的代码，通常使用汇编语言编写。 这个阶段的功能主要有： 基本硬件设备初始化； 为第二阶段准备ARM空间； 复制BootLoader的第二阶段代码到RAM； 设置栈堆； 跳转到第二阶段的入口点； 第二阶段 通常使用C语言完成，以便实现更复杂的功能，使程序具有更好的可读性和可移植性。 这一阶段的主要任务是： 初始化这一阶段要使用的硬件设备; 检测系统内存映射； 将内核文件和根目录系统映像文件从Flash读到RAM； 为内核设置启动参数， 调用内核。 常用的启动文件有很多，这里介绍Uboot。\nUboot是一个开源项目，最早是由德国登克斯（DENX）小组的开发，然后发布在网上，许多对这款软件感兴趣的开发人员共同来维护。\nBootLoader的核心任务是什么？ 启动内核，向内核提供启动参数，完成系统软件的部署功能。\n系统加电后执行的第一段代码是什么？ BootLoader(引导程序)是系统上电后运行的第一段代码。\nU-Boot命令和环境变量 U-Boot通常支持几十个常用命令，通过这些命令，可以对目标机进行调试，也可以引导Linux内核，还可以擦写Flash完成系统部署等功能。\n常用命令： print: 通常用于打印信息或变量的值到控制台或终端。 setenv: 设置环境变量。环境变量是在操作系统中存储的配置信息，可以影响程序的行为。\nsaveenv: 保存环境变量。这个命令通常用于将当前的环境变量设置保存到非易失性存储器，以便在系统重启后保持这些设置。\nping: 网络诊断工具，用于测试主机之间的网络连接是否可达。\ntftp: Trivial File Transfer Protocol（简单文件传输协议）的缩写，用于在设备之间传输文件。\nboot: 启动系统或加载执行程序。\n组合命令 movi read:用来读取iNand到DDR上 movi write:用来将DDR写到到iNand上 注释：\n非易失性存储器 iNand 动态数据随机存取存储器 DDR linux内核简介 Linux内核主要功能有：\n进程管理 内存管理 文件管理 设备管理 网络管理 Linux内核源代码非常庞大，它使用目录树结构，内核源码的顶层有许多子目录,分别组织存放各种内核子系统或者文件,如下表： Linux内核移植 Linux内核支持多种处理器，如果目标机使用的是ARM处理器核，使用的交叉编译工具链是arm-linux-，内核移植时要指定处理器的类型以及使用的交叉编译工具链，简述具体操作方法。\n具体操作如下。 打开内核顶层目录下的Makefile文件，在文件中找到如下内容。 ARCH？=$(SUBARCH) CROSS_COMPILE?=$(CONFIG_CROSS_COMPILE:“%”=%) 将找到的以上代码修改为如下内容。 ARCH？=arm CROSS_COMPILE?=arm-none-linux-gnueabi- 其中，ARCH是CPU架构变量；CROSS_COMPILE是交叉编译工具链变量。修改完成后，保存文件退出。\n驱动程序 驱动程序的功能 对设备初始化和释放 数据传输:把数据从内核传送到硬件和从硬件读取数据,读取应用程序传送给设备文件的数据和回送应用程序请求的数据. 检测和处理设备出现的错误 Open入口点 对象：字符设备文件； 特点：字符设备文件都需要经过open入口点调用 open子程序功能：为I/O口作必要的准备工作 同一时刻只能有一个程序访问此设备（即设备是独占的）,则 open子程序必须设置一些标志以表示设备处于忙碌状态。open子程序的调用格式如下。 int open(char * filename,int acess)\n第一个功能中 打开设备是由调用定义在incliude/linux/fs.h中的file_operations结构体中的 open()函数完成的。open()函数主要完成的主要工作：\n1.若是首次打开，先初始化 2.增加设备的使用计数 3.检测设备是否异常，及时发现设备相关错误 4.读取设备次设备号。\n驱动程序的主要组成部分 自动配置和初始化子程序：检测驱动的硬件设备是否正常，能否正常工作 服务子程序和中断服务程序:这两者分别是驱动程序的上下两部分。 驱动上部分，即设备服务子程序，它是系统调用的结果，并且伴随着用户态向核心态的演变，在此过程中还可以调用与进程运行环境有关的函数，比如 sleep()函数。 驱动程序的下半部分，即中断服务子程序 Linux设备分类 （用C表示设备） 字符设备 块设备 网络设备 应用程序操作设备框图 简述驱动程序和应用程序的区别 第一，应用程序一般有一个main函数，并从头到尾执行一个任务；驱动程序没有main函数，它在加载时，通过调用module_init宏，完成驱动设备的初始化和注册工作之后便停止工作，并等待被应用程序调用。\n第二，应用程序可以和GLIBC库连接，因此可以包含标准的头文件；驱动程序不能使用标准的C库，因此不能调用所有的C库函数，比如输出函数不能使用printf，只能用内核的printk，包含的头文件只能是内核的头文件，比如Linux/module.h。\n第三，驱动程序运行在内核空间（又称内核态）比应用程序执行的优先级要高很多。应用程序则运行在最低级别的用户空间（又称用户态），在这一级别禁止对硬件的直接访问和对内存的未授权访问。\n应用程序一般有一个main函数,并从头到尾执行一个任务； 应用程序可以和 GLIBC 库连接,因此可以包含标准的头文件； 驱动程序运行在内核空间(又称内核态),比应用程序执行的优先级要高很多。\n附件 嵌入式复习PPT.pptx (659 KB) 嵌入式作业.docx (52 KB) ",
    "description": "",
    "tags": [
      "嵌入式",
      "Cortex-A9微处理器",
      "Linux操作系统"
    ],
    "title": "12.嵌入式系统设计知识点",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: Cortex-A9微处理器",
    "uri": "/tags/cortex-a9%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: F1-复习",
    "uri": "/categories/f1-%E5%A4%8D%E4%B9%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: Linux操作系统",
    "uri": "/tags/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 嵌入式",
    "uri": "/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: ESP8266",
    "uri": "/tags/esp8266/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: STM32",
    "uri": "/tags/stm32/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 物联网",
    "uri": "/tags/%E7%89%A9%E8%81%94%E7%BD%91/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 物联网应用系统设计",
    "uri": "/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "物联网结构系统与传统网路系统的区别\n前者由三个部分构成\n信息物品 自主网络 智能应用 需求分析 基本概念 需求规格说明：开发、测试、质量保证、项目管理以及相关的项目功能等地方都有重要的作用\n需求：功能、性能 、行为、设计约束等方面的期望\n需求分析：对要解决的问题的详细分析说明，弄清问题的需求\n需求分析过程 获取用户需求——分析用户需求——编写需求文档——评审需求分析\n需求管理 一、需求管理开发与需求管理的界限\n需求开发中编写的需求文档数据来自于市场、用户、管理，以基准需求说明为界限，需求管理从这个文档中获取开发信息，通过市场等变动修改这个文档。\n需求分析任务 1。确定系统运行环境\n硬件环境的要求：外存种类、数据的输入方式、数据通信接口；\n软件环境的需求：哪一种操作系统、数据库系统；\n2。系统性能需求\n数据输入系统后系统多久可以可以做出反应；\n3。系统功能\n确定目标系统的所有功能\n设计概要 任务 根据需求文档确定系统的整体结构，设计其中硬件结构、软件结构和数据结构\n硬件结构：确定系统功能对应的硬件环境，以及硬件之间的关系； 软件结构：将一个复杂系统按照功能进行模块划分，建立模块的层次结构以及调用关系，确定模块之间的接口以及人机界面 数据结构：数据特征描述、确定数据结构特点何人数据库的设计 概要设计原则 抽象： 抽象就是抽出事物的本质特征，而暂时不考虑细节。它允许我们定义一个操作的步骤，而不需要立即知道这些步骤是如何执行的。\n抽样方法：\n（1）过程抽象 过程抽象关注的是操作的序列，而不是具体实现的细节。它允许我们定义一个操作的步骤，而不需要立即知道这些步骤是如何执行的。\n举例： 假设我们要设计一个软件来管理图书馆的借书和还书过程。过程抽象可能包括以下步骤：\n用户登录 查询书籍 借书 还书 用户登出 在这个抽象级别，我们不需要知道用户如何登录（比如是通过用户名和密码，还是通过社交媒体账号），也不需要知道查询书籍的具体算法。我们只是定义了需要执行的操作序列。\n（2）数据抽象 数据抽象关注的是数据的结构和行为，而不是数据的具体表示。它允许我们定义数据类型和操作，而隐藏了数据的内部细节。\n举例： 考虑一个银行账户系统。数据抽象可能包括以下定义：\n账户类型（如储蓄账户、支票账户） 账户操作（如存款、取款、转账） 账户属性（如账户号码、账户余额、账户持有人） 在这个抽象级别，我们定义了账户是什么以及可以对账户执行哪些操作，但我们不需要知道账户数据是如何存储的（比如是在数据库中，还是在内存中）。\n（3）控制抽象 控制抽象关注的是程序的控制流，而不是具体的控制机制。它允许我们定义程序的执行路径，而不需要立即知道控制流的具体实现。\n举例： 假设我们正在设计一个交通信号灯控制系统。控制抽象可能包括以下逻辑：\n红灯亮起 等待一定时间 黄灯闪烁 绿灯亮起 等待一定时间后返回到红灯 在这个抽象级别，我们定义了信号灯变化的顺序，但我们不需要知道具体的计时机制或者信号灯是如何被激活的。控制抽象允许我们专注于信号灯变化的逻辑，而不是实现细节。\n网络结构的基本拓扑结构 拓扑结构的类型和使用选择 按照组网方式和组网形态：\n集中式 分布式 混合式 网状式 按照节点和结构层次\n平面网络结构 分级网络结构 混合网络结构 Mesh网络结构 表示工具 流程图 基本成分\n处理； 判断条件； 控制流。 基本的控制结构\n顺序型； 选择型； 先判断（While）型循环； 后判断（Until）型循环； 多情况（Case）选择型。 优点 对控制流程的描绘直观、清晰，易于学习掌握。\n缺点\n诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构； 用箭头代表控制流，可以完全不顾结构程序设计的思想，随意转移控制； 不易表示数据结构； 修改麻烦。 问题分析图 合图 优点\n功能明确，可以一眼看出来； 没有箭头，无法随意转移控制； 很容易确定局部和全局的作用域； 很容易表示嵌套关系，也可以表示模块的参差结构 强制让设计人员按照结程序设计描述方案； 图形直观。容易理解设计意图 缺点\n当分支嵌套较多时较麻烦，有时候在一页纸上很难画下来； 画图麻烦修改麻烦 层次图 概要设计与详细设计的区别 概要设计通常得到软件结构图 详细设计常用的描述方式（常用的图）： 流程图、 N-S图、 PAD图、 过程设计语言（PLD），又称伪代码。 注：伪代码——伪代码是一种非正式的、类似编程语言的描述方式，它用于描述算法的逻辑流程而不涉及具体的编程语言细节。伪代码使得设计者可以在不编写实际代码的情况下表达算法和程序结构。\n接口设计 外部接口：外部用户、软/硬环境与软件系统的接口； 内部系统：已划分出的模块间接口。\n工厂方法模式 为创建对象提供过度接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的\n工厂模式在《java与模式》中分为：\n简单工厂模式 工厂方法模式 抽象工厂模式 拓扑控制中考虑的设计目标和相关概念-覆盖 覆盖可以理解为对传感器网络质量的度量 覆盖可以分为：\n区域覆盖：研究对目标区域的覆盖（监测）问题； 点覆盖：研究离散的目标覆盖问题； 栅栏覆盖：研究运动穿过网络部署区域被发现的概率问题。 MANET路由协议——按需路由协议（也是一种算法） TORA(temporally ordered routing alorithm)协议是临时按需路由协议，是一种有向环基础上提出的基于路由反转的自适应分布式路由算法。\n作为一个有源端发起的按需路由，它可以找到从源头到目的节点的多条路由，当网络拓扑发生改变时，控制消息在改变的拓扑结构范围内传播，节点只需要维护相邻节点的路由信息；\n协议由路由建立、路由维护、路由拆除三部分组成。\n无线传感网络选择 选择有线还是无线 选择专利还是标准化无线方案 无线标准 GPRS Wi-Fi 蓝牙 ZigBee 无线网络拓扑结构 无线体域网 WBAN由三部分组成：\n植入或佩戴于人体的网络神经， 作为通信枢纽的汇聚节点， 负责信息处理和控制整个网络的上位机监控系统。 WBAN采集人体生理信息的过程 某一种生理信号传感器和无线收发装置能够构成一个网络节点，各个节点分布式的分布在人体上，构成局域网。 网络节点在上位机电脑和汇聚节点的指令下收集人体生理信息，将收集到的信息通过汇聚节点传输到上位机电脑。 系统集成 系统集成式指综合分布先系统和计算机网络技术，将各个分离的设备、功能和信息等集成到相互关联、统一和协调的系统之中，以达到资源充分共享，实现集中、高效、便利的管理。\n系统集成采用功能集成、网络集成、软件界面集成等多种集成技术；\n系统集成的关键在于解决系统之间互联和互操作性的问题，它是一个对厂商、多协议和面向各种应用的结构系统\n简而言之，就是把分散的东西集成到一起，使得它们之间可以相互通信共享数据的一种技术。\n软件测试的方法 黑盒测试， 白盒测试 灰盒测试。 静态测试 不执行代码。主要对编程格式、结构等方面进行评估并发现存在的错误。\n优点：\n不必动态地运行代码，不必设计测试用例，不用判断测试结果； 可以由人工进行，充分发挥人的逻辑思维优势，检查出错误的水平很高； 不需要特别条件，容易开展。 具体步骤：\n代码审查 代码走查 桌面检查 其他步骤（查看PPT）\n动态测试 通过运行软件来检查软件的动态行为和运行结果是否正确的方法。\n特点：\n运行被测程序，取得程序运行的真实情况和动态情况，在进行打分； 必须生成测试数据来运行程序，测试质量依赖于测试数据； 生成测试数据、分析测试结果的工作量大，展开测试费时、费力； 动态测试中涉及多方面的工作，人员多、设备多、数据多、要求有较好的管理和工程规划； （1） 功能确认与接口测试 （2） 覆盖率分析 （3） 性能分析 （4） 内存分析\n集成测试 集成测试也称为组装测试或综合测试，在单元测试的基础上，将模块按照设计要求组装成子系统或系统，进行集成测试。\n制定集成测试计划——设计集成测试——实施集成测试——评估集成模块\n集成测试完成标准：\n成功执行了测试计划中规定的所有集成测试； 修整了发现的错误； 测试结果通过了专门小组的评审。 MQTT和HTTP的底层都是TCP/IP，也就是物联网装置可以沿用既有的网路架构和设备，只是在网路上流通的「讯息格式」以及应用程式的处理机制不同.\nMQTT协议概述 MQTT不同于HTTP标头采用文字描述，而是采用数字编码，整个长度只占2位元组，等同两个字元，后面跟着讯息的主题（topic）和内容（payload），格式如下：\n讯息类型 DUP(是否为副本) QoP(传输品质) R(是否保留)\r0 0 1 1\r0 0 0 0\r剩余资料长度 传输品质QoS 传输品质QoS表示发布者与代理人（订阅者）之间数据传输的品质。\n传输品质 QoS 说明 阿里云IOT QoS=0 最多传输一次，可能收不到 支持 QoS=1 最少传输一次可能会重传 支持 QoS=2 有且仅有一次传输 不支持 注：MosQuito全都支持\nMQTTLens订阅以及发布消息 订阅者可以透过下列三个叙述订阅多个主题： 结合上面这张图来理解\n1.假设订阅者要订阅温度，温度可以来自主题A（yard），主题B(soil)，主题C（Tool）。\n订阅某个属性的信息\nhome/+/DHT11 +号内容可以是yard，soil可以写为 home/yard/DHT11 home/soil/DHT11 但不可以写为： home/yard/pond/DHT11 home/soil/DHT11/Temp订阅三个主题\nhome/+/+ 包含三个主题，具体如下 home/yard/DHT11 home/soil/DHT11 home/Tool/RID订阅某个主题的所有属性\nhome/yard/# 包含三个主题，具体如下 home/yard/DHT11 home/yard/pond/DHT11 home/yard/DHT11/temp home/yard/DHT11/humi在上面的代码中所写的#号表示订阅所有的主题，在使用时注意下面的写法是无效的：\nhome/#/DHT11 //无效 home/yard# //无效 综合实验——局域网内手机通信 创建AP接入点、TCP服务器，通过手机连接ESP8266模块控制STM32开发板上的LED和蜂鸣器；\n实现的功能 (1)STM32控制ESP8266模块创建AP接入点。\n(2)STM32控制ESP8266创建TCP服务器。\n(3)通过手机的软件连接ESP8266模块的TCP服务器。\n(4)手机上可以通过WIFI模块控制STM32开发板的LED1、LED2、LED3和蜂鸣器。\n(5)手机上可以看到STM32上传的温度和湿度。\n//ESP8266初始化 //Esp8266Mode:WIFI模块的工作模式，STA和AP //ssid:要生成或者接入的SSID名字，如果已经一键配网，要写NULL //password:对应SSID的密码，如果已经一键配网，要写NULL //ip:如果要设置静态IP，要写对应的IP，否则写NULL。 u8 ESP8266_init(u8 Esp8266Mode, char *ssid,char *password, char *ip) { u8 i=0; memset(esp8266.sta_ip,0,20); memset(esp8266.ap_ip,0,20); if(Esp8266Mode==ESP8266_MODE_STA) { esp8266.mode=ESP8266_MODE_STA; //STA模式有可能通过了一键配网模式得到了SSID和PSW if(ssid!=NULL) sprintf(esp8266.sta_ssid, \"%s\", ssid); if(password!=NULL) sprintf(esp8266.sta_password, \"%s\", password); if(ip!=NULL) sprintf(esp8266.sta_ip, \"%s\", ip);//设置STA模式静态IP ESP8266_Printf(\"\\r\\nSTA ssid:%s, psw:%s\\r\\n\", esp8266.sta_ssid, esp8266.sta_password); } else { esp8266.ap_chl=5;//通道号 esp8266.ap_ecn=ESP8266_ECN_WPA_PSK;//加密方式 esp8266.mode=ESP8266_MODE_AP; sprintf(esp8266.ap_ssid, \"%s\", ssid); sprintf(esp8266.ap_password, \"%s\", password); if(ip!=NULL) sprintf(esp8266.ap_ip, \"%s\", ip);//设置AP模式静态IP ESP8266_Printf(\"\\r\\nAP ssid:%s, psw:%s\\r\\n\", esp8266.ap_ssid, esp8266.ap_password); } esp8266.smartconfig=0; ESP8266_reset(); ESP8266_SendAT(\"ATE0\\r\\n\",1);//关回显 //AP模式 if(esp8266.mode==ESP8266_MODE_AP||esp8266.mode==ESP8266_MODE_AP_STA) { ESP8266_SetWiFiWorkMode(esp8266.mode); ESP8266_SoftAp(esp8266.ap_ssid, esp8266.ap_password, esp8266.ap_chl, esp8266.ap_ecn); ESP8266_SoftAp_staticIp(esp8266.ap_ip); } //STA模式 if(esp8266.mode==ESP8266_MODE_STA||esp8266.mode==ESP8266_MODE_AP_STA) { ESP8266_SetWiFiWorkMode(esp8266.mode); ESP8266_ConnectAp(esp8266.sta_ssid, esp8266.sta_password, NULL); ESP8266_Station_staticIp(esp8266.sta_ip); } //启动DHCP ESP8266_SetDhcp(esp8266.mode, 1); ESP8266_SendAT(\"AT+CWLAPOPT=1,2047\\r\\n\",1); return 0; } //设置WIFI工作的传输模式 //transportProtocol：UDP，TCPservice,tcp_client //localPort:本地端口号 //remoteIp：远端的IP，如果是TCPservice模式，请写NULL或者\"\" //remotePort：远端端口号的PORT u8 ESP8266_SetWorkMode(u8 transportProtocol, u16 localPort, char *remoteIp, u16 remotePort) { u8 i=0; esp8266.localPort=localPort; esp8266.isConnect=0;//连接是否创建　1：已经创建 //ID为无效的ID esp8266.clientId[0]=-1; esp8266.clientId[1]=-1; esp8266.clientId[2]=-1; esp8266.clientId[3]=-1; memset(esp8266.sta_mac,0,30); esp8266.curLen=0; esp8266.data_len=0;// memset(esp8266.remoteIp,0,20); if(ESP8266_TCP_SERVICE==transportProtocol) { esp8266.connectMode=1;//1：TCP service 2:TCP client 3:UDP if(remoteIp!=NULL) sprintf(esp8266.remoteIp, \"%s\", remoteIp); esp8266.remotePort=remotePort; } else if(ESP8266_TCP_CLIENT==transportProtocol) { esp8266.connectMode=2;//1：TCP service 2:TCP client 3:UDP if(remoteIp!=NULL) sprintf(esp8266.remoteIp, \"%s\", remoteIp); esp8266.remotePort=remotePort; } else if(ESP8266_UDP==transportProtocol) { esp8266.connectMode=3;//1：TCP service 2:TCP client 3:UDP if(remoteIp!=NULL) sprintf(esp8266.remoteIp, \"%s\", remoteIp); esp8266.remotePort=remotePort; } ESP8266_Printf(\"\\r\\nconnectMode:%d, ip:%s, port:%d\\r\\n\", esp8266.connectMode, esp8266.remoteIp,esp8266.remotePort); return 0; } //收到数据 ptr = (char*)strstr((const char*)cmd,(const char*)\"+IPD,\"); //接收到+IPD开头，说明接收到数据 if(ptr!=NULL) { int i=0; u8 id=0; //+IPD, ptr+=5; if(ptr==NULL) return 0; //如果是TCP服务器 //格式会多一个id if(esp8266.connectMode==1)//如果是TCP服务器，找出\u003clink ID \u003e { //TCP服务的处理 id=atoi(ptr); while(ptr!=NULL \u0026\u0026 *ptr!=',') ptr++; ptr++; } esp8266.data_len=atoi(ptr);//读出接收到的数据长度 while(ptr!=NULL \u0026\u0026 *ptr!=':') ptr++; ptr++; memset(esp8266.data, 0, MAX_WIFI_RX_LEN); esp8266.curLen=0; //读出收到的数据 while(esp8266.curLen\u003cMAX_WIFI_RX_LEN \u0026\u0026 esp8266.curLen\u003cesp8266.data_len \u0026\u0026 ptr!=NULL \u0026\u0026 ((ptr-cmd)\u003c=len)) { esp8266.data[esp8266.curLen]=*ptr;//数据存储 ptr++; esp8266.curLen++; } //一次性把数据接收全 if(esp8266.curLen\u003e=esp8266.data_len) { //对接收到的数据进行处理 ESP8266_RxData(esp8266.data, esp8266.curLen); esp8266.curLen=0; esp8266.data_len=0; } re=1; }实验三 //以下是启动AP模式 ESP8266_init(ESP8266_MODE_AP, WIFI_SSID, WIFI_PASSWORD, WIFI_IP); //配置协议模式：TCP服务器、TCP客户端或者UDP //配置要连接的IP和端口号 //注意！！注意！！注意！！以下二个配置参数只能打开其中一个。 //配置TCP服务器参数 //ESP8266_SetWorkMode(ESP8266_TCP_SERVICE, WIFI_PORT, NULL, 10000); //ESP8266_SetWorkMode(ESP8266_TCP_CLIENT, WIFI_PORT, ROMOTE_IP, ROMOTE_PORT); //配置UDP的参数 //这里的IP\"192.168.1.90\"为UDP服务器所在的电脑IP，根据实际情况修改 ESP8266_SetWorkMode(ESP8266_UDP, WIFI_PORT, \"192.168.1.2\", 10000); while(1) { if((count%20)==0) { ESP8266_run(); } //3秒采集温湿度一次 if((count%300)==0)//300次累加 { DHT11(\u0026t, \u0026h);//采集温湿度 sprintf(buff, \"温度:%02d,湿度:%02d.\\r\\n\", t,h); Gui_DrawFont_GBK16_line(HAL_LCD_LINE_8,RED,WHITE,buff);//发送温度值 ESP8266_SendData(buff, strlen(buff)); } delay_ms(10); //闪灯表示程序活着 if((count%20)==0) LED1=!LED1; count++; }实验十 关于STM32工程代码的几点说明 Define 是C语言中的宏定义，可以提高代码的可读性为编程提供方便。\nSTM32开发板的下载方式是串口；\n函数定义的静态变量可以不赋初值，因为程序会分配存储空间；\n温度读取流程 判断传感器相应是否正确； 安慰读取数值； 判断检验和是否正确； 提取温度值 在智慧大棚中采集温度值或者是光照值应该 在STM32开发板上搭建TCP服务器； 在不同区域放置若干WiFi模块，采集DHT11温湿度传感器； WiFi模块和STM32模块连到同一个无线路由 WIFI模块通过TCP协议将传感器温湿度值传到服务器 传感器将接收到的数据存储在数据库中。 根据土壤情况进行自动灌溉 在STM32板子上搭建TCP服务器； 在大棚的不同区域放置若干WIFI模块，采集土壤湿度信息； WiFi模块和STM32板子连接到同一个路由器； WiFi模块通过TCP通信协议将土壤湿度信息传到服务器； 服务器更具当前的温湿度信息和阈值，启动和停止水泵。 附件 ",
    "description": "",
    "tags": [
      "物联网应用系统设计",
      "物联网",
      "STM32",
      "ESP8266"
    ],
    "title": "物联网应用系统设计",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/11.%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B5-比赛",
    "uri": "/categories/b5-%E6%AF%94%E8%B5%9B/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: STM32学习",
    "uri": "/tags/stm32%E5%AD%A6%E4%B9%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: X1-项目",
    "uri": "/categories/x1-%E9%A1%B9%E7%9B%AE/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目",
    "content": " 以下笔记皆基于HAL库。\n新建STM32CubeMX工程步骤 创建工程中如果勾选MCO表示向外部输出时钟， 输出的是哪一个引脚可以查看，如下图。 外部时钟设置 工程设置 如果Application Structure设置为Basic，那么会把下面的两个文件分开放 否则项目会把两个文件放在一个文件夹里，如Core\n最后还需要设置Code Generator，如下： 时钟 1.初识时钟周期\n2.时钟树 3.时钟配置步骤 4.外设时钟使能和失能\n5.sys_stm32_cloc_init()函数\nHAL_RCC_OscConfig()\nHSE高速外设振荡器 LSE RC振荡器，随着电压的变化而变化，所以需要一个检验值 PLL锁相环 HAL_RCC_ClockConfig() 第一个参数 结构体中的第一个参数里的HCLK是指AHB总线、PCLK1是指APB1总线、PCLK2是指APB2总线，这个配置表示要配那条总线的时钟。 第二个形参 F1系统时钟72MHz,如果使用72MHz访问闪存（Flash）那么是需要等待的，因为闪存的允许最大时钟频率是42MHz,所以需要等待，等待多少个周期需要下图 6.SYSTEN文件夹\nsys文件夹 NVIC介绍 中断基本概念 中断向量表 文件里的中断在哪里呢？ 在文件startup_stm32f10x_hd.s中这里列出内部中断，外部中断就在内部中断之下，这里不再列出。\n__Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD SVC_Handler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD PendSV_Handler ; PendSV Handler DCD SysTick_Handler ; SysTick Handler中断寄存器 中断原理 中断优先级 响应优先级又叫子优先级\n中断的抢占优先级由AICR寄存器的后三位控制，而响应优先级由IPRx寄存器的后四位控制，最终分配结果参考下面的表格 中断一般只设置一次，设置多次可能会导致中断紊乱，一般以最后一次的中断设置为准，详细说明参考手册4.4.5\n中断执行的顺序：抢占优先级（先执行数值小的）————响应优先级（先执行数值小的）————自然优先级（先执行数值大的）\nNVIC 的使用 以下笔记皆基于标准库。\n标准库中额中断 EXTI（Extern Interrupt）外部中断 EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序\n简而言之，gpio电平发生变化时，申请外部中断。\n支持的触发方式：上升沿/下降沿/双边沿/软件触发（引脚没有发生变化，执行一段代码就申请中断） 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断（如PA1，PB1，PC1不能同时触发中断） 通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒 触发响应方式：中断响应/事件响应（事件响应不会触发中断。而是触发别的外设操作。属于外设之间的联合工作） AFIO复用IO口 主要用于引脚复用功能的选择和重定义\n在STM32中，AFIO主要完成两个任务：\n复用功能引脚重映射 中断引脚选择 EXTI实现代码 这段代码的中断端口是GPIOB_Pin14，所以需要将相关的传感器接到PB14这个端口\nvoid CountSensor_Init(){ //配置RCC RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); //AFIO、 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //EXTI、一直打开着不用配置打开时钟 //NVIC 一直打开着不用配置打开时钟 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14); //EXTI EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line=EXTI_Line14; EXTI_InitStructure.EXTI_LineCmd=ENABLE; EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling; EXTI_Init(\u0026EXTI_InitStructure); //NVIC NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2; NVIC_InitStructure.NVIC_IRQChannelSubPriority=0; NVIC_Init(\u0026NVIC_InitStructure); } void EXTI15_10_IRQHandler(void){//中断函数 if(EXTI_GetITStatus(EXTI_Line14)== SET){ EXTI_ClearITPendingBit(EXTI_Line14); } }定时器 TIM（Timer）定时器 定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断\n16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时 不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能 根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型\n使用内部时钟源实现中断（标准库中） 在编写代码前先看看定时器的实现原理图\n基本定时器 通用定时器 高级定时器（红色框出来的部分是高级定时器独有的） 此处主要参考通用计时器的结构图，下面是基于内部时钟RCC的定时器。\n在 stm32f103xxx_rcc.c 文件对 RCC_APB1PeriphClockCmd 这样的介绍：\n/** * @brief Enables or disables the High Speed APB (APB2) peripheral clock. * @param RCC_APB2Periph: specifies the APB2 peripheral to gates its clock. * This parameter can be any combination of the following values: * @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, …… …… ……+ */specifies the APB2 peripheral to gates its clock.即：指定APB 2外围设备到其时钟门。而这里的时钟门代码里选择了TIM2。\nvoid Timer_Init(void){ //1.RCC RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE); //2.选择时基单元时钟源， TIM_InternalClockConfig(TIM2); //3.时基单元 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;\t//时钟分频，这里是1分频 TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;\t//计数方式 TIM_TimeBaseInitStructure.TIM_Period=10000-1;\t//自动重装值，计数达到这个值后触发中断，然后重新开始计数 TIM_TimeBaseInitStructure.TIM_Prescaler=7200 -1;\t//预分频，计数频率， //假设计数为1s则自动重装值可设置为10000，预分频可设置为7200，公式为秒数=27MHz/PSC/ARR TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;\t//重复计数数器高级定时器才有，这里设置为0 TIM_TimeBaseInit(TIM2,\u0026TIM_TimeBaseInitStructure);\t//时基单元设置 TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE); //4.中断输出控制 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//抢占优先级,0-3， 响应优先级0-3，一个工程只设置一次 //5.NVIC NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1; NVIC_InitStructure.NVIC_IRQChannelSubPriority=1; NVIC_Init(\u0026NVIC_InitStructure); TIM_Cmd(TIM2,ENABLE); } void TIM2_IRQHandler(void){ if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET){ Num++; TIM_ClearITPendingBit(TIM2,TIM_IT_Update); } }实现输出比较 OC（Output Compare）输出比较 输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形\n每个高级定时器和通用定时器都拥有4个输出比较通道\n高级定时器的前3个通道额外拥有死区生成和互补输出的功能\nOC：输出比较\nIC：输入比较\nCC：输入/输出比较\nPWM波形 PWM（Pulse Width Modulation）脉冲宽度调制，广泛应用于各种电子和电气系统中，用于控制功率转换、电机速度、信号传输等 在具有^1中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域 ^1 PWM参数： 频率 = 1 / TS 占空比 = TON / TS 分辨率 = 占空比变化步距 一些电平变化图可以等效为图中的虚线。 上图框出来的部分具体如下图： 在信号通过比较后输出到CC1P，然后再输出到输出使用电路，输出使用电路的OC1可以查看引脚定义表\n在上图中需要注意的一些引文缩写：\nREF 是reference的缩写。意思是 参考信号 输出比较的设置 设置的函数为\nPWM基本结构 配置PWM的时候可以参考下面的图， 图中的参考坐标系图红色线表示CCR的值，蓝色线表示CNT的值，黄色线表示自动重装载值即ARR。 了解了这点后我们再看看PWM的是如何计算的，如下公式\nPWM频率： [ \\text{Freq} = \\frac{CKPSC}{(PSC + 1) \\times (ARR + 1)} ] 可以看出PWM的频率等于CNT的更新频率\nPWM占空比： [ \\text{Duty} = \\frac{CCR}{(ARR + 1)} ]\nPWM分辨率： [ \\text{Reso} = \\frac{1}{(ARR + 1)} ]\n代码编写 附件 ",
    "description": "",
    "tags": [
      "STM32学习"
    ],
    "title": "电赛",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E7%94%B5%E8%B5%9B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "参数context 与环境变量有关，不管是系统还是用户自定义的都用这个来获取，获取方式：context.env\n先部署云函数到远端，然后在去远端添加环境变量，然后在本地运行虚拟机查看。 负载均衡的四种方式\n随机 轮询 最少连接数 最短响应时间 延迟时长的重试策略\nzero:一旦云函数调用失败，则调用，中间不等待 constant：调用失败等一段时间 jittered:调用失败等一段时间，再次调用，如果失败等待时间以指数增长 熔断\n设置一定的条件，满足条件后会执行熔断。熔断后云函数不在提供服务。\n附件 ",
    "description": "",
    "tags": [
      "ArkTS",
      "OpenHarmony",
      "HarmonyOS",
      "云端一体化"
    ],
    "title": "10.云端一体化的环境变量问题",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/10.%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: ArkTS",
    "uri": "/tags/arkts/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: HarmonyOS",
    "uri": "/tags/harmonyos/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: OpenHarmony",
    "uri": "/tags/openharmony/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: 应用开发",
    "uri": "/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 云端一体化",
    "uri": "/tags/%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "调用云函数的时候我们总有输入输出结果不符合自己预期的时候，这个时候查看日志很重要！！在云端一体化开发过程中，我们可以通过下面的方式解决这一问题：\n首先参数event的输出以JSON格式输出，这样方便阅读，下面有一段代码，\n云函数代码如下：\nimport { stringify } from \"querystring\"; let myHandler = async function (event, context, callback, logger) { logger.info(JSON.stringify(event)); const name = event.body.name callback({ code: 200, message: `Hello ${name}.` }); }; export { myHandler };获取信息的ets文件如下：\nimport cloud from '@hw-agconnect/cloud'; @Entry @Component struct MyIndex { @State message: string = '' @State name:string = '' build() { Row() { Column() { TextInput({placeholder:'请输入姓名'}) .onChange(value =\u003e { this.name = value }) Button('使用云端一体化') .fontSize(20) .onClick(async ()=\u003e{ const result = await cloud.callFunction({ name:'login',//云函数的名字 version:'$latest', params:{name:this.name} }) this.message=result.getValue().message }) Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) } .width('100%') } .height('100%') } }function函数的说明：\n触发条件： HTTP请求， 云数据库插入， 云存储 参数含义： 输入信息（）， 执行时上下文信息（环境变量）， 输出（返回结果给调用者）， 记录日志（） 此处做了这样的处理使得日志输出以JSON格式输出：\nlogger.info(JSON.stringify(event))\r当遇到问题时，去官方的开发论坛搜索相关内容， 此处我想实现输入一个名字，然后让云端函数以不同的方式输出，比如：\n你好，张三\n你好，李四\n但是现在输出的是：你好，%\u0026*%%\n解决办法：\n查看event参数说明\n再去CAG官网选择云监控—\u003e日志服务\n然后复制右边的内容,放到一个json文件夹，用编译器（比如VScode）打开，并调整格式(如果用的是VScode，请使用shift+alt+F调整json格式)如下：\n{\r\"path\": \"login-$latest\",\r\"httpMethod\": \"POST\",\r\"headers\": {\r\"user-agent\": \"libcurl-agent/1.0\",\r\"x-forwarded-for\": \"115.46.239.151, 10.135.135.154, 10.134.64.11\",\r\"x-forwarded-port\": \"443\",\r\"accept\": \"*/*\",\r\"accept-encoding\": \"gzip\",\r\"agcgw-trigger-authtype\": \"apigw-client\",\r\"host\": \"10.14.4.31\",\r\"content-type\": \"application/json;charset=UTF-8\",\r\"packagename\": \"com.itwcx.test\",\r\"appid\": \"5765880207853994135\",\r\"authorization\": \"SDK-HMAC-SHA256 containPath=false,containBody=false,containQuery=false,accessId=m7rTGQ2uNvyq1AGfJFLo,timestamp=1711175951586,signedHeaders=appid;productid,signature=44fe3b4da7d80ec9dfee07ca3747c448e94254b5454fef87f468150089f38623\",\r\"x-forwarded-host\": \"10.14.4.31\",\r\"appversion\": \"1.0.0\",\r\"sdkplatformversion\": \"3.2.0.0\",\r\"sdktype\": \"TS\",\r\"content-length\": \"19\",\r\"x-real-ip\": \"10.134.64.11\",\r\"sdkversion\": \"1.0.0\",\r\"x-forwarded-proto\": \"https\",\r\"sdkservicename\": \"agconnect-cloud\",\r\"x-trace-id\": \"f09f1070-6d7b-46a9-875d-bfb2bc4bfdb9\",\r\"productid\": \"388421841222044287\",\r\"sdkplatform\": \"OpenHarmony\"\r},\r\"queryStringParameters\": \"\",\r\"queryParameters\": null,\r\"body\": \"{\\\"name\\\":\\\"zhangsan\\\"}\",\r\"isBase64Encoded\": false,\r\"pathVariable\": null\r}此处我们只查看参数event的HTTP请求的相关说明：\n比较官网的event参数格式与自己日志打印的格式，看看有什么不同\n观察可知问题出在body这个参数，参数是json格式，而日志打印的是字符格式，我们需要把字符格式转换成json格式，做如下操作：\nimport { stringify } from \"querystring\"; let myHandler = async function (event, context, callback, logger) { logger.info(JSON.stringify(event)); const obj = JSON.parse(event.body) const name = obj.name callback({ code: 200, message: `Hello ${name}.` }); }; export { myHandler };上面的代码中\nconst obj = JSON.parse(event.body)\rconst name = obj.name\r就是转换操作。\n认证服务 登录页面的实现 登录验证代码：\nimport { AuthMode,Login } from '@hw-agconnect/auth-component' import { AuthUser } from '@hw-agconnect/cloud' import router from '@ohos.router' @Entry @Component struct MyLogin { @State message: string = 'Hello World' build() { Row() { Column() { Login({ modes:[AuthMode.PHONE_VERIFY_CODE], onSuccess:(usr:AuthUser) =\u003e{ router.pushUrl({url:'page/MyWelcome'}) } }){ Button('登录') } } .width('100%') } .height('100%') } } 页面登录获取验证码 import { Auth, VerifyCodeAction } from '@hw-agconnect/cloud'; import cloud from '@hw-agconnect/cloud' import hilog from '@ohos.hilog' import router from '@ohos.router'; @Entry @Component struct MyLogin { @State countDown: number = 10 //用一个变量来获取setinterval的ID intervalId:number = 0 //因为这个变量与页面显示无关所以不用@State注释 @State verifyCodeButtonEnable:boolean = false @State verifyCodeButtonText:string ='获取验证码' @State phoneNumber: string = '' @State verifyCode:string = '输入验证码' //定时器代码 waiting(){ this.verifyCodeButtonEnable = false this.verifyCodeButtonText = `${this.countDown}s`//在一点击时，就显示10S this.intervalId = setInterval(() =\u003e { //要知道定时器结束没有需要知道它的返回结果，这个结果可以通过setinterval的ID获取。 this.verifyCodeButtonText = `${this.countDown}s`//将倒计时显示出来 if(this.countDown \u003c 0){ //如果减到0，清楚定时器 clearInterval(this.intervalId)//得到返回结果后清楚定时器 this.countDown = 10 this.intervalId = 0 this.verifyCodeButtonText = '获取验证码'//倒计时结束时回复 this.verifyCodeButtonEnable = true //当点击时按键不可用 return //不需要再往下继续执行了，所以return } this.countDown-- },1000)//每隔1秒减一次 } judgement(){ if(this.phoneNumber.length === 11){ this.verifyCodeButtonEnable=true }else { this.verifyCodeButtonEnable=false } } async sending_verifyCode(){ try { //调用方式异步调用 await cloud.auth().requestVerifyCode({ verifyCodeType: { kind: 'phone', phoneNumber: this.phoneNumber, countryCode: '86' }, action: VerifyCodeAction.REGISTER_LOGIN, //验证的方式 lang: 'zh_CN', sendInterval: 10 }) hilog.info(0,'VerifCode','Success') } catch (e) { AlertDialog.show({ title: '错误', message: '验证码失败' })//弹窗内容 hilog.info(0,'VerifCode',JSON.stringify(e)) } } async login_verify(){ try { const result = await cloud.auth().signIn({ //定义一个变量来接收它的返回结果,返回的是result，在通过result.gitUsr获取用户信息 credentialInfo: { kind: 'phone', countryCode: '86', phoneNumber: this.phoneNumber, verifyCode: this.verifyCode } }) const user = result.getUser() AppStorage.SetOrCreate('user',user)//存储用户到 AppStorage hilog.info(0,'Login','Success') router.replaceUrl({ url: 'pages/MyLoginLignOut' }) } catch (e) { AlertDialog.show({title:'错误',message:'登陆失败'}) hilog.info(0,'Login',JSON.stringify(e)) } } build() { Row() { Column() { TextInput({placeholder:'请输入手机号'}) .type(InputType.Number) .onChange(values =\u003e{ this.phoneNumber = values this.judgement()//点击获取验证码时，判断按键是否可用 }) Row(){ TextInput({placeholder:'验证码'}) .width('70%') .onChange(value =\u003e{ this.verifyCode=value }) Button(this.verifyCodeButtonText) .width('30%') .enabled(this.verifyCodeButtonEnable)//该属性是控制按键是否可用 .onClick(async () =\u003e{ //所在方法加async this.waiting() this.sending_verifyCode() }) } .width('100%') Button('登录') .enabled(this.phoneNumber.length === 11 \u0026\u0026 this.verifyCode.length === 6)//手机号11位，且验证码六位时点击登录才有效 .onClick(async ()=\u003e{ this.login_verify() }) } .width('100%') } .height('100%') } }登录后跳转到的页面：\nimport cloud ,{AuthUser}from \"@hw-agconnect/cloud\" import hilog from '@ohos.hilog' import router from '@ohos.router' @Entry @Component struct MyLoginLignOut { @State photoUrl:string = '' //存储头像路径 @State displayName:string = '' //存储用户昵称 @StorageLink('user') user:AuthUser = null //定义一个AuthUser的类型来获取用户存的值，('user')叫存储对象名，是在另一个页面定义的名字 aboutToAppear(){//build渲染前就运行 //1.cloud.auth().getCurrentUser() //2.appStorage this.displayName = this.user.getDisplayName()//获取用户，间接通过用户拿到用户头像等数据。 this.photoUrl = this.user.getPhotoUrl() } build() { Row() { Column() { Row(){ Image(this.photoUrl?this.photoUrl:$r('app.media.app_icon')) .width(80) .height(80) .onClick(()=\u003e{ this.photoUrl= 'https://img.btstu.cn/api/images/5a2a5d5560223.jpg' }) }.width('100%') .justifyContent(FlexAlign.Center) .padding({bottom:70}) TextInput({placeholder:'设置昵称',text:this.displayName}) .fontSize(25) .fontWeight(FontWeight.Bold) .onChange(value =\u003e{ this.displayName = value }) Button('保存') .margin({top:10,bottom:10}) .width(90) .onClick(async ()=\u003e{//保存图片与用户名 try { await this.user.updateProfile({//保存头像、用户名 displayName: this.displayName, photoUrl: this.photoUrl }) hilog.info(0,'updateProfile','Success') } catch (e) { hilog.info(0,'updateProfile',JSON.stringify(e)) } }) Button('登出') .margin({top:10,bottom:10}) .width(90) .onClick(async ()=\u003e{ try { await cloud.auth().signOut() hilog.info(0,'SignOut','Success') router.replaceUrl({url:'pages/MyLogin'}) } catch (e) { hilog.info(0,'SignOut',JSON.stringify(e)) } }) } .width('100%') } .height('100%') } }个人设置中心 import cloud, { AuthUser } from '@hw-agconnect/cloud' import router from '@ohos.router' import hilog from '@ohos.hilog' import picker from '@ohos.file.picker' @Entry @Component struct MyIndex { @State photoUrl: string = '' //存储头像路径 @State displayName: string = '' //存储用户昵称 @StorageLink('user') user: AuthUser = null //定义一个AuthUser的类型来获取用户存的值，('user')叫存储对象名，是在另一个页面定义的名字 @State uploading: boolean = false//用户控制图片是否可以点击，上传时不可以点击 @State uploadingText: string = '0%'//上传进度 aboutToAppear() { //build渲染前就运行 // 1. cloud.auth().getCurrentUser() // 2. AppStorage this.displayName = this.user?.getDisplayName()//获取用户，间接通过用户拿到用户头像等数据。加问号是因为在aboutToAppear运行时是无法获取用户名或图片等信息的 this.photoUrl = this.user?.getPhotoUrl() } build() { Row() { Column({ space: 10 }) { Stack() {//Stack该属性让它所包含的组件重叠 Image(this.photoUrl ? this.photoUrl : $r('app.media.user_dark')) .width(70) .height(70) .borderRadius(70) .enabled(!this.uploading) .onComplete(()=\u003e{ this.uploading = false }) .onClick(async () =\u003e { // this.photoUrl = '网络图片的地址' try { // 1. 从相簿中选照片 const options = new picker.PhotoSelectOptions() options.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE//媒体类型：视频还是图片 options.maxSelectNumber = 1//最大选择个数 const result = await new picker.PhotoViewPicker().select(options)//把参数传给下面的方法，把结果传给result hilog.info(0, 'Upload', `Picker Success ${result.photoUris[0]}`) this.uploading = true // 2. 调云存储 api 上传照片 await cloud.storage().upload({ localPath: result.photoUris[0],//本地图片路径 cloudPath: `test/${this.user.getUid()}.jpg`,//云存储那边存储的路径 onUploadProgress: event =\u003e { const percent = Math.floor(100 * event.loaded / event.total)//获取上传的百分比，event.loaded：已上传的自己数，event.total：总的自己数，Math.floor：舍弃小数点 this.uploadingText = `${percent}%` //数值更新到uploadingText } }) hilog.info(0, 'Upload', 'Upload Success') // 3. 获取上传照片的网络地址 const url = await cloud.storage().getDownloadURL(`test/${this.user.getUid()}.jpg`)//获取公网地址，拿到图片在网络上的地址 this.photoUrl = `${url}\u0026ts=${new Date().getTime()}`//这个里做这个处理是因为，图片被缓存起来了，上传的时候如果只是给云存储的地址，那么在传第二张图片到云存储后，photoUrl再获取时，因为图片地址不变照片也不会改变，它会缓存起来，而在图片后面加上一个时间图片就不在被缓存。 // this.uploading = false hilog.info(0, 'Upload', `url: ${url}`) } catch (e) { hilog.error(0, 'Upload', JSON.stringify(e)) } }) if (this.uploading) { // 显示上传进度 Text(this.uploadingText) .width(70) .height(70) .borderRadius(70) .fontColor('white') .backgroundColor('black') .opacity(0.6) .fontSize(24) .fontWeight(FontWeight.Bolder) .textAlign(TextAlign.Center)//文字对齐方式 } } TextInput({ placeholder: '请设置昵称', text: this.displayName }) .width('50%') .onChange(value =\u003e { this.displayName = value }) Button(`保存`) .onClick(async () =\u003e { try { await this.user.updateProfile({ displayName: this.displayName, photoUrl: this.photoUrl }) hilog.info(0, 'updateProfile', 'Success') } catch (e) { hilog.error(0, 'updateProfile', JSON.stringify(e)) } }) Button(`登出`) .onClick(async () =\u003e { try { await cloud.auth().signOut() hilog.info(0, 'SignOut', 'Success') router.replaceUrl({ url: 'pages/MyLoginCustom' }) } catch (e) { hilog.error(0, 'SignOut', JSON.stringify(e)) } }) } .width('100%') } .height('100%') } }登录页面 import { Auth, VerifyCodeAction } from '@hw-agconnect/cloud'; import cloud from '@hw-agconnect/cloud' import hilog from '@ohos.hilog' import router from '@ohos.router'; @Entry @Component struct MyLogin { @State countDown: number = 10 //用一个变量来获取setinterval的ID intervalId:number = 0 //因为这个变量与页面显示无关所以不用@State注释 @State verifyCodeButtonEnable:boolean = false @State verifyCodeButtonText:string ='获取验证码' @State phoneNumber: string = '' @State verifyCode:string = '输入验证码' private mainPage = `pages/StudentPage` async aboutToAppear() { try { const user = await cloud.auth().getCurrentUser()//获取当前认证用户 if (user != null) {//获取用户是否为空，如果用户已经断开会话，则下一次进入时间走时登录流程 AppStorage.SetOrCreate('user', user) // 如果会话未断开，不走登录流程，而是吧用户数据存到AppStorage router.replaceUrl({ url: this.mainPage }) } } catch (e) { hilog.error(0, 'Login', JSON.stringify(e)) } } //定时器代码 waiting(){ this.verifyCodeButtonEnable = false this.verifyCodeButtonText = `${this.countDown}s`//在一点击时，就显示10S this.intervalId = setInterval(() =\u003e { //要知道定时器结束没有需要知道它的返回结果，这个结果可以通过setinterval的ID获取。 this.verifyCodeButtonText = `${this.countDown}s`//将倒计时显示出来 if(this.countDown \u003c 0){ //如果减到0，清楚定时器 clearInterval(this.intervalId)//得到返回结果后清楚定时器 this.countDown = 10 this.intervalId = 0 this.verifyCodeButtonText = '获取验证码'//倒计时结束时回复 this.verifyCodeButtonEnable = true //当点击时按键不可用 return //不需要再往下继续执行了，所以return } this.countDown-- },1000)//每隔1秒减一次 } judgement(){ if(this.phoneNumber.length === 11){ this.verifyCodeButtonEnable=true }else { this.verifyCodeButtonEnable=false } } async sending_verifyCode(){ try { //调用方式异步调用 await cloud.auth().requestVerifyCode({ verifyCodeType: { kind: 'phone', phoneNumber: this.phoneNumber, countryCode: '86' }, action: VerifyCodeAction.REGISTER_LOGIN, //验证的方式 lang: 'zh_CN', sendInterval: 10 }) hilog.info(0,'VerifCode','Success') } catch (e) { AlertDialog.show({ title: '错误', message: '验证码失败' })//弹窗内容 hilog.info(0,'VerifCode',JSON.stringify(e)) } } async login_verify(){ try { const result = await cloud.auth().signIn({ //定义一个变量来接收它的返回结果,返回的是result，在通过result.gitUsr获取用户信息 credentialInfo: { kind: 'phone', countryCode: '86', phoneNumber: this.phoneNumber, verifyCode: this.verifyCode } }) const user = result.getUser() AppStorage.SetOrCreate('user',user)//存储用户到 AppStorage hilog.info(0,'Login','Success') router.replaceUrl({ url: 'pages/MyLoginLignOut' }) } catch (e) { AlertDialog.show({title:'错误',message:'登陆失败'}) hilog.info(0,'Login',JSON.stringify(e)) } } build() { Row() { Column() { TextInput({placeholder:'请输入手机号'}) .type(InputType.Number) .onChange(values =\u003e{ this.phoneNumber = values this.judgement()//点击获取验证码时，判断按键是否可用 }) Row(){ TextInput({placeholder:'验证码'}) .width('70%') .onChange(value =\u003e{ this.verifyCode=value }) Button(this.verifyCodeButtonText) .width('30%') .enabled(this.verifyCodeButtonEnable)//该属性是控制按键是否可用 .onClick(async () =\u003e{ //所在方法加async this.waiting() this.sending_verifyCode() }) } .width('100%') Button('登录') .enabled(this.phoneNumber.length === 11 \u0026\u0026 this.verifyCode.length === 6)//手机号11位，且验证码六位时点击登录才有效 .onClick(async ()=\u003e{ this.login_verify() }) } .width('100%') } .height('100%') } }希望文档对你有所帮助。\n附件 ",
    "description": "",
    "tags": [
      "ArkTS",
      "OpenHarmony",
      "HarmonyOS",
      "云端一体化"
    ],
    "title": "9.云端一体化如何查看云函数日志？",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/9.%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BA%91%E5%87%BD%E6%95%B0%E6%97%A5%E5%BF%97/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "数据类型 练习网址：\n条件语句 拓展：for in与for of的使用\nfor in ：遍历得到数组的角标， for of ：直接得到元素。 函数 使用function关键字声明函数，\nfunction outname(name:string):void{ console.log('你好'+name+\"!\") } //第二种写法： let outname = (name:string)=\u003e{ console.log('你好'+name+\"!\") } outname('lucy')ts还提供了一种可传参数和不传参数也执行的函数的操作，写法如下：\nlet outname = (name:string='张三')=\u003e{ console.log('你好'+name+\"!\") } outname()面向对象 模块的导入导出 提高代码的重复使用 组件的使用 image组件 textinput组件 TextInput({text:this.imagewidth.toFixed(0)}) .width(150) .backgroundColor('#36D00A') .type(InputType.Number) .onChange( values =\u003e{ this.imagewidth = parseInt(values) }) TextInput({placeholder:'nihao'}) .width(150) .backgroundColor('#4399')效果如下图： 文本框内输入的值是什么类型的数据呢？\n从上面的代码可知是字符型的，此处我们用parseInt将一个变量转换成number类型，又用方法.toFixed()将一个number类型的变量转换成字符串型。\n按键组件 滑动条组件（slider） 页面布局 线性布局 Row布局与Column布局类似，只是主轴方向不同 循环控制ForEach 使用router进行页面跳转时用replaceUrl与pushUrl的区别 后者会保留前一页信息，就是跳转后会返回上一页面，而后面的不会跳回上一页\n11–t\nf–!=11,运行时 附件 ",
    "description": "",
    "tags": [
      "ArkTS语言",
      "OpenHarmony",
      "HarmonyOS"
    ],
    "title": "8.速通ArkTS语言",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/8.%E9%80%9F%E9%80%9Aarkts%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: ArkTS语言",
    "uri": "/tags/arkts%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B5-编程",
    "uri": "/categories/b5-%E7%BC%96%E7%A8%8B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "一台电脑如何使用多个远程仓库？ 下载好git，并做好相关的配置 关联github仓库 创建github仓库 克隆仓库到本地 git clone \u003c你的远程仓库URL\u003e创建多个 SSH 密钥对涉及到在本地生成多个公钥和私钥文件，并将公钥添加到你想要访问的远程服务器上。以下是详细步骤：\n打开终端： 打开你的终端（在 macOS 或 Linux 上）或 Git Bash（在 Windows 上）。\n导航到 SSH 目录： 使用 cd 命令切换到你的 SSH 目录，通常是 ~/.ssh。\ncd ~/.ssh 生成新的 SSH 密钥对： 使用 ssh-keygen 命令生成新的密钥对。每次运行此命令时，你都可以指定不同的文件名，以便区分不同的密钥对。例如，为 GitHub 生成的密钥对可能命名为 id_rsa_github，为 GitLab 生成的密钥对可能命名为 id_rsa_gitlab。\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" -f id_rsa_github 重复上述步骤，为其他服务生成密钥对，只需更改文件名即可。例如：\nssh-keygen -t rsa -b 4096 -C \"another_email@example.com\" -f id_rsa_gitlab\n-b是指密码的长度是4096，与加密有关，-f表示要创建的ssh有关文件名\n在生成密钥时，系统会提示你输入一个文件名来保存新的密钥对。如果你直接按回车键，它将使用默认的文件名（如 id_rsa）。如果你想要为每个服务使用不同的文件名，确保在命令中指定 -f 选项后跟你想要的文件名。\n将公钥添加到远程服务器： 生成密钥对后，你需要将公钥（文件名后缀为 .pub）添加到远程服务器的 SSH 密钥管理界面。例如，在 GitHub 上，你可以在 Settings \u003e SSH and GPG keys 部分添加新的公钥。\n配置 SSH 配置文件： 为了确保 SSH 使用正确的密钥对连接到正确的服务器，你可以在 .ssh 目录下创建一个名为 config 的文件（如果该文件不存在的话），并为每个服务配置不同的设置。\ntouch ~/.ssh/config\n然后编辑这个文件，添加以下内容：\nHost github.com User git IdentityFile ~/.ssh/id_rsa_github IdentitiesOnly yes Host gitlab.com User git IdentityFile ~/.ssh/id_rsa_gitlab IdentitiesOnly yes这里的 Host 是你为每个服务设置的别名，User 是 Git 服务的默认用户名（通常是 git），IdentityFile 是你的私钥文件的路径。\n测试 SSH 连接： 使用 ssh -T 命令测试与远程服务器的连接。例如：\nssh -T git@github.com ssh -T git@gitlab.com如果一切设置正确，你应该会看到一条欢迎消息，表明你已经成功通过 SSH 密钥验证。\n当我有连个github账户时，当我用同一台电脑推送的时候如何区分是那个推送的 推荐文章\n答案：\n首先是克隆下来两个项目一个为test_A,一个为test_B，假设有一个账户是A，另一个是B，而且A账户的邮箱是设置为全局的，即用了这条命令：\ngit config --global user.name \"A\" git config --global user.email A@qq.com #假设这里的邮箱是QQ那么在在text_A中不作任何修改，在text_B中添加如下命令即可：\ngit config user.name \"B\" git config user.email B@qq.com #假设这里的邮箱是QQ遇到的一些问题 问题一\n解决Git上传代码error: failed to push some refs to ‘xxx‘hint:(e.g., ‘git pull …‘) before pushing again错误\n推荐文章\n问题二\n【Git】错误：权限被拒绝（公钥）(Permission denied (publickey).)\n推荐文章2)\n问题三\n解决Git上传代码error: failed to push some refs to ‘xxx‘hint:(e.g., ‘git pull …‘) before pushing again错误\n推荐文章 附件 ",
    "description": "",
    "tags": [
      "gihub",
      "atomgit"
    ],
    "title": "6.github和atomgit的混合使用，哪些是值得注意的？",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/6.github%E5%92%8Catomgit%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E9%82%A3%E4%BA%9B%E6%98%AF%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: atomgit",
    "uri": "/tags/atomgit/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B1-博客文章",
    "uri": "/categories/b1-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: gihub",
    "uri": "/tags/gihub/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: J1-教师资格考试",
    "uri": "/categories/j1-%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%80%83%E8%AF%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 教资",
    "uri": "/tags/%E6%95%99%E8%B5%84/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 16.考试类",
    "content": "科目一：\n教育观与职业道德\n教育与社会的发展 点击查看流程图\n考题 简述教育对生产力的关系（制约作用）？\n教育与人的发展 点击查看流程图\n教育制度 理解记住教育制度的概念，尤其是狭义教育制度； 理解并记住建立学制的依据 理解教育制度的发展 理解我国教育制度的沿革 理解并记住现代教育的改革和发展 理解并记住义务教育的特性 教育制度概念 1.教育制度的概念\n2.教育学制的依据\n可能需要考虑的因素可能有哪些呢？请思考思考。\n城乡地域因素 经济因素 国家性质因素—社会主义 文化因素 人口因素 3.教育学制的形式发展\n点击查看流程图\n科目二 ： 教育观与职业道德\n测试文字\n",
    "description": "",
    "tags": "教资",
    "title": "教资 小学",
    "uri": "/branch-bundle-1/16.%E8%80%83%E8%AF%95%E7%B1%BB/%E6%95%99%E8%B5%84-%E5%B0%8F%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: W1-博客文章",
    "uri": "/categories/w1-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: Z1-哲学",
    "uri": "/categories/z1-%E5%93%B2%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 脑洞",
    "uri": "/tags/%E8%84%91%E6%B4%9E/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 11.哲学",
    "content": "序言 我前几天看见篇文章说现在的一些科学是建立几句假设之上的，这几句假设就像悬空寺下的几个柱子，撑起了几百年的悬空寺，甚至在以后更长的时间里起立不到。这是让我比较惊讶的地方。科学是需要建立在假设之上并被证实的学科，一说到科学我们能想到严谨，严密等等，但在哲学上我认为不需要向科学那样的严谨，哲学对于我这样水平的人而言是天马行空的乐园，在一开始我觉得讲出来的东西是给人理解的，那么你讲的首先就要符合常识，违背基本常识的东西很难让人有兴趣或去理解，但假设往往不被我们常识说束缚，正是假设不被常识所束缚，它有了更多的可能，所以我在建立自己的“悬空寺”的时候，也需要这种不被束缚的假设，为此我会尽量讲人话，其实我也没有不讲人话的能力。\n解释世界还是改造世界？ “哲学家们只是以不同的方式解释世界，问题在于改变世界。”马克思在1842年加入莱茵报，最初作为撰稿人，后来在同年10月成为主编。在马克思的领导下，莱茵报开始关注政治和思想问题，尤其是言论自由和审查制度。\n马克思曾在莱茵报上发表《关于林木盗窃法的辩论》一文，这篇文章反映了马克思对当时普鲁士法律和社会现实的深刻批判。文章的背景是普鲁士政府为了保护林木所有者的私人财产，提出了一项新的林木盗窃法案，该法案将捡拾枯枝的行为定性为盗窃，并规定了严厉的惩罚措施。\n在当时的普鲁士，由于资本主义的发展，公共资源被私有化，普通民众的生活变得更加困难。捡拾枯枝对于许多贫苦农民来说是一种生存手段，但新法案的通过使得这一行为成为了犯罪。马克思在文章中强烈抨击了这种立法，他认为法律应该代表公众利益，而不是仅仅维护少数林木所有者的私人利益。\n马克思在文章中指出，捡拾枯枝与盗窃林木在本质上是不同的行为。捡拾枯枝是自然赋予贫苦农民的权利，而盗窃林木则是对林木所有者财产的侵犯。他批评立法者忽视了这一区别，将两者混为一谈，从而使得法律成为了维护私人利益的工具。马克思进一步指出，法律的公正性和合理性被私人利益所侵蚀，这不仅损害了贫苦大众的利益，也违背了法律应有的公正精神。\n马克思还在莱茵报上发表了如《评普鲁士最近的书报检查令》等文章，展示了他对言论自由的坚定支持。然而，莱茵报的激进立场引起了普鲁士政府的不满。政府认为莱茵报的文章威胁到了国家的稳定，特别是马克思对政府政策的批评和对民主自由的呼声。1843年3月31日，普鲁士政府最终决定查封莱茵报。\n理论不能只停留在书本上，而是因该走到实践中去实现理论的价值，检验理论的真理性。即使马克思当时的理由在充分，也很难得到普鲁士政府的认同，因为他面对的是资本一方，在资本面前生产资料私有化，在这件事上普鲁士资本家们就像在经济危机中资本家一样，他们宁愿把牛奶导入河流，也不会把牛奶分给贫苦的人们，莱茵报的查封对马克思产生了深远的影响。它不仅标志着他与普鲁士政府的直接冲突，也促使他进一步深化了对资本主义社会和政治制度的批判。这一时期的经历，为马克思后来发展历史唯物主义和马克思主义理论奠定了基础。\n解释世界为我们的言论提供了可靠的依据，然而仅仅有解释权似乎是远远不够的，因为世界是人的世界，社会是由人所主导的，由于人的活动而发展的，有人构建起来的社会影响着生活在这个时代的人的行为，他们的解释权也可能会被构建的社会说淹没，然而改变这一局面却也不是不可能，这为向马克思这样的伟人留下了通往改变世界的道路。\n哥白尼的日心说起始于16世纪，这一理论的提出标志着天文学和科学史上的一个重大转折点。他在1543年出版的《天体运行论》（De revolutionibus orbium coelestium）中提出了日心说。在这本书中，哥白尼提出太阳是宇宙的中心，而地球和其他行星围绕太阳运行。这一理论挑战了当时普遍接受的地心说，即认为地球是宇宙的中心，其他天体围绕地球旋转。哥白尼解决了太阳和地球的是如何运动的问题，也得出太阳绕着地球转，这里在解释太阳实际运行的状况，解释这个太阳与地球运动是什么样子的，这就是解释世界。\n哥白尼的日心说不但解释了世界，同时也在实践中实现了他的价值，但这或许与他的科学属性秘密相关，因为科学总要在实践中得到证实。但是我们生活在现实世界中往往不会像科学家那么做。\n出自中国古典文学《列子》的《两小儿辩日》中讲述了有两个小孩争辩太阳大小、远近的故事，一个小孩认为早晨的太阳看起来更大，所以应该是更近的；另一个小孩则认为中午的太阳更热，所以应该是更近的。两个小孩各自通过视觉观察到的和自身感觉到的，做出了自己对不同时间段太阳大小、远近的理解，其实本质上是解释世界，但这部分没有改变世界的部分吗，答案是否定的，这样的经验主义在当时的社会或对现在的一部分的人而言是指导生活的方式。\n两小儿辩日是一种经验主义，这种理解与改造世界的例子更贴近生活，在生活中我们不必追究太阳移向南回归线，还是移向北回归线，地球在自传，且还在绕着太阳公转等等问题，我们只凭借自己所能感觉到的，所能看到的理解世界，这是更为真实而更被大众所接收，并用来指导生活的一种行为。但是这种理解与改变世界的方式正在被慢慢的拆解与重构，这不意味着我们失去真实，反而是到达另一个高度。解释世界与改造世界的关系不是用“还是”来连接并把问题抛出，而是用“与”来连接，让你去理解与在这中理解下做出改变。\n如何破除前进道路山的弥瘴 众生皆有相，把这个相拿到掉你才能看众生的真面目，举一个简单的例子，你走在马路上，看到地上有一部iPhone的手机，在你面前它是一部手机，还是别的东西？你可能会回答就是一部手机啊，或者你会加一个条件它是比别的手机高一档的苹果手机，那么接下来你会捡起来占为己有（虽然对大部分人来说捡到占为己有也没有），还是寻找失主呢？iPhone手机的相就是——同样是手机他却有着别的手机所没有的诱惑力，把这个东西拿掉他与别的手机是一样的，甚至你可以说就是一部会发亮的电子产品。\n前几天我在准备教资考试的时候，在图书馆学了一天，结果晚上回答宿舍的时候因为迷上B站上以为UP讲解的西游记视频，而看了一整晚，第二天没有精神所以就没有再去准备教资的考试，而是荒废了一天，那么我本是可以不看，按时睡觉然后第二天正常去学习的，那为什么们能实现呢？有人会说这不是你自律的问题嘛！这不是你自我约束力不够导致的嘛！我想也是，也不是，因为导致我们约束力不够的原因绝不是自己本身就先天决定的，而是后天造成的，基于这一点可以认为是所接受的事物引起的，那么这件事就必定有它的相，那么在这里的相是什么呢？在我看来相往往不是对比得出来的，因为我们遇到的事情大多都太复杂了，这相我们只能靠悟去了解，悟这种方式我也讲不了，但在前天这件事事上，我能悟的是视频是我前往教资上的弥瘴，而弥瘴的相是他的内容有我能get到的，有我一直想了解的，那怎么破除弥瘴呢？关键就在拿掉这个相，把内容拿掉，把感兴趣的拿掉，这视频还有，但是我却没有了，视频的内容它吸引我的点这些东西我肯定是没办法左右的，我能左右的只有视频映射到我内心的相。\n附件 ",
    "description": "",
    "tags": "脑洞",
    "title": "思想的边界",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/%E8%AF%AD%E8%A8%80%E6%98%AF%E6%B2%A1%E6%9C%89%E8%BE%B9%E7%95%8C%E7%9A%84/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 费尔巴哈提纲",
    "uri": "/tags/%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E6%8F%90%E7%BA%B2/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 11.哲学 \u003e 费尔巴哈提纲",
    "content": "费尔巴哈的唯物主义： 费尔巴哈试图将宗教世界归结于其世俗基础，但他没有意识到世俗基础本身也存在问题。他试图通过直观的感性来理解世界，但没有将人的感性活动理解为实践的活动。费尔巴哈的唯物主义停留在了对感性客体的直观理解上，没有深入到人的实践活动和社会关系中去。\n马克思的批判： 马克思在《关于费尔巴哈的提纲》中批判了费尔巴哈的唯物主义，指出其主要缺点在于没有从人的感性活动、即实践的角度去理解世界。马克思强调，人的本质不是抽象的、孤立的个体，而是一切社会关系的总和。他提出了历史唯物主义的观点，认为社会存在决定社会意识，物质生产方式是社会发展的基础。\n实践的观点： 王德峰教授强调，马克思的实践观是其哲学的核心。实践不仅仅是物质生产活动，而是包括了人与人的社会关系建立和改变的活动。实践是社会生活的本质，是人与自然、人与社会相互作用的过程。通过实践，人们不仅创造物质财富，也在创造和改变社会关系。\n真理的标准： 马克思认为，真理的标准不是理论的抽象推导，而是实践。人的思维是否具有客观的真理性，需要在实践中得到证明。实践是检验真理的唯一标准，这与旧唯物主义和唯心主义的观点形成了鲜明对比。\n哲学的使命： 马克思提出，哲学家们不应该只是解释世界，而应该致力于改变世界。这表明，哲学不仅仅是理论的探讨，更重要的是要指导实践，推动社会的进步和变革\n附件 ",
    "description": "",
    "tags": "费尔巴哈提纲",
    "title": "如何理解费尔巴哈提纲的主要含义？",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E6%8F%90%E7%BA%B2/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E6%8F%90%E7%BA%B2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%90%AB%E4%B9%89/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: Y1-外语",
    "uri": "/categories/y1-%E5%A4%96%E8%AF%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 英语",
    "uri": "/tags/%E8%8B%B1%E8%AF%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 15.外语类",
    "content": "听力相关 ：\nCues 这里是关键词和提示。 Notes 有声书。\n视频学习： ted， comedy，stand up. 1.看原文； 2.看中英； 3.看原文； 4.记笔记； 5.关闭字母。\npodcast：\n音频链接\n音频链接2\nSummary 这里是笔记的摘要。 阅读相关 ：\nCues1 单词、词汇。 英语阅读 阅读方法 Notes1 make time for reading.坚持每天都花一点时间阅读10分钟也可以； 使用浏览器搜索自己感兴趣的话题，推bing.com国际版; ask questions as you read.试着带着问题去阅读； read it again. read a variety of texts.阅读丰富的文章。 Don’t worry about looking words up as you’re reading. 在查词的过程中把陌生词添加到自己的单词本中； 上面是一些阅读方法，下面介绍如何找到自己的水平，找到适合自己水平的题材。\n如何阅读，如果自己的四六级英语水平是三百多及一下，推荐这个网站\nThe news ：breaking news english Articles :Lingua and the British Stories :English for Students 如果还是看不懂上面的文章推荐去这个网站：English for Kids。\n四级过了但六级没过推荐下面的网站:\nbritish council magazine and Smithsonian Twen Tribune,the Mental Floss\nLeonardo English Blog\nReading:\nManyBooks\nLibrivox\nAuthorama\nProject Gutenberg\nInternatonal Children’s Digital Library\nRead Print\nArchive.org\nSummary1 renre:题材，体裁。 linguists:语言学家 名词解释 ：\nCues3 名词解释 英文术语 Notes3 College VS. university.\nSummary3 这里是笔记的摘要。 附件 ",
    "description": "",
    "tags": [
      "英语词汇",
      "英语"
    ],
    "title": "英语",
    "uri": "/branch-bundle-1/15.%E5%A4%96%E8%AF%AD%E7%B1%BB/%E8%8B%B1%E8%AF%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 英语词汇",
    "uri": "/tags/%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": " Cues Cues Notes 创建css文件 在hugo配置中设置 在markdown文档中引用 Summary 标签/提示 ：静态网页，康奈尔笔记，hugo，自定义页面输出格式。\nNotes 创建css文件 康奈尔笔记的布局，其中左侧是 “Cues”，右侧是 “Notes”，底部是 “Summary”，您可以使用 Flexbox 的 row 和 column 布局来实现。这里是一个 CSS 示例，它将创建一个两列的布局，左侧为 “Cues”，右侧为 “Notes”，然后在这两列下方是 “Summary”。\n首先，创建一个名为 cornell-notes.css 的 CSS 文件，并添加以下样式代码：\n.cornell-notes { border: 1px solid #ccc; padding: 20px; margin: 20px; display: flex; flex-wrap: wrap; } .cues { background-image: url('icon2.svg'); border-right: 1px solid #080808; flex: 1; padding-right: 20px; } .notes { background-image: url('icon1.svg'); border-left: 1px solid #080808; flex: 2; padding-left: 20px; } .summary { width: 100%; clear: both; /* 清除浮动，确保摘要部分在下方 */ padding-top: 20px; background-image:url('wwwatercolor.jpg'); margin-top: 20px; }在这个样式中，.cornell-notes 是整个康奈尔笔记的容器，我们使用 display: flex; 和 flex-wrap: wrap; 来创建一个 Flex 容器，允许子元素根据需要换行。.cues 和 .notes 分别设置为容器的子项，并通过 flex 属性来分配空间。.summary 部分使用 width: 100%; 来确保它在 .cues 和 .notes 下方显示，并使用 clear: both; 来清除之前的浮动。\n此处分享一个免费的svg网站，bbburst： 在这个网站或许你可以找到适合你的背景图，用以装饰自己的康奈尔容器，此处的svg是放在css文件夹下的，所以是直接引用，如果你放在别的的放那么还请使用正确的的路径。\n在hugo配置中设置 接下来，确保将 cornell-notes.css 文件放置在 Hugo 站点的 static/css 目录下。然后，在 Hugo 的配置文件 config.toml 中添加对 CSS 文件的引用：\n# config.toml [Params] # 其他参数... [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true # 允许在 Markdown 中使用 HTML 和 CSS如果使用的是code打开的项目，那么可以先在code内搜索上面的配置是否已添加，因为部分hugo主题原来就添加了这一配置。\n在markdown文档中引用 在 Markdown 文件中，你可以这样使用这些类：\n--- title: \"康奈尔笔记示例\" --- \u003clink rel=\"stylesheet\" href=\"/css/cornell-notes.css\"\u003e \u003cdiv class=\"cornell-notes\"\u003e \u003cdiv class=\"cues\"\u003e ## Cues - 这里是关键词和提示。 \u003c/div\u003e \u003cdiv class=\"notes\"\u003e ## Notes - 这里是详细的笔记内容。 \u003c/div\u003e \u003cdiv class=\"summary\"\u003e ## Summary - 这里是笔记的摘要。 \u003c/div\u003e \u003c/div\u003e确保在 Markdown 文件中添加 标签来引入 CSS 文件，并为每个部分使用相应的类。这样，当你构建并查看 Hugo 站点时，康奈尔笔记将以正确的样式显示，其中 “Cues” 在左侧，“Notes” 在右侧，“Summary” 在底部。\nSummary 在上面我们学习了如何自定义hugo中页面的输出格式，在引用hugo主题情况下，自定义自己的页面输出格式只需要三点，即创建css文件，在config配置文件中配置相关信息，在markdown中引用。其实我们可以拓展，如果你想创建属于自己的笔记你可以参照上面的方法自制简单的笔记，希望本期内容对你有所帮助。\n",
    "description": "",
    "tags": [
      "文章"
    ],
    "title": "5.自定义页面以康奈尔笔记格式输出",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/5.%E5%BA%B7%E5%A5%88%E5%B0%94%E7%AC%94%E8%AE%B0%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%88%9B%E5%BB%BA/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 文章",
    "uri": "/tags/%E6%96%87%E7%AB%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "原文章链接\n附件 ",
    "description": "",
    "tags": [
      "github",
      "高级搜索"
    ],
    "title": "4.如何在github上使用高级搜索搜出自己想要的项目？",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/4.%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E4%BD%BF%E7%94%A8%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%90%9C%E5%87%BA%E8%87%AA%E5%B7%B1%E6%83%B3%E8%A6%81%E7%9A%84%E9%A1%B9%E7%9B%AE/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: github",
    "uri": "/tags/github/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 高级搜索",
    "uri": "/tags/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B1-拓展笔记",
    "uri": "/categories/b1-%E6%8B%93%E5%B1%95%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 模电",
    "uri": "/tags/%E6%A8%A1%E7%94%B5/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 14.电子电路",
    "content": "常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的\n本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4 复合：与本真激发相反的过程\n本征半导体的导电能力与载流子的浓度有关：此时处于动态平衡，本证激发与复合的速度一样。\n从工程的角度看，只加热温度让导电能力增加不实际，还好它具有掺杂别的东西让导电能力增加。\n杂质半导体 概念 掺杂少量 的杂志元素。\nN型半导体 掺杂P元素（5价元素），本征半导体的导电能力增加，自由电子是多子，空穴是少子；\n温度对多子影响小，因为多子本身就多，但对少子浓度的影响大，因为少子的量少；\nP型半导体 掺杂硼元素（3价元素），本征半导体的导电能力增加，自由电子是少子，空穴是多子；\nPN结半导体 1.扩散运动：在浓度梯度的作用下，浓度高的地方向浓度低的地方扩散；\n2.空间电荷区（耗尽层、PN结），这里举个例子，就右边空间电荷区的正电荷而言，从电场线出发，两边平衡我们可以理为正电荷发出的电场阻止了左边的空穴移动，而对于负电荷他也有这样的特性，所以两边达到平衡的状态。\n虽然中间有空间电荷区形成势垒（由电压形成）组织了两遍的多子运动，但是这样的势垒能百分之百阻止多子向两边运动吗？\n答案是不完全，还是有一小部分的多子冲破避雷向两边运动。下面是一张简单的图。\n3.漂移运动：两边少子的运动称之为漂移运动\n4.对称结与不对称结：由上面的图可以看出两边宽度一样，原因是掺杂的浓度一样，如果不一样？那么两边就不对称了，这时候称之为不对称结。\n加外电压的PN结半导体 加正电压（P流向N，空间电荷区被削弱） 加反向电压（，空间电荷区增加） 这个时候的漂移运动是增加的，但漂移运动是由少子形成的所以他的影响是很小的，值得注意的是漂移运动对 温度 是很敏感的。\nPN结的电流方程 $i=I_s(e^{U/U{_T}}-1),其中V_T=26V$\n锗：0.2-0.3V 硅：0.6-0.7V\n特性 正向特性 反向特性 2.1雪崩击穿（掺杂浓度低，温度越高，击穿电压越高，因为粒子需要加速） 2.2齐纳击穿（掺杂浓度高，温度越高，击穿电压越低，因为） PN结的电容效应 当正负极两边的电压变化时，中间的电量发生改变；\n1.势垒电容 2.扩散电容：非平衡少子形成 电压增高为2线，浓度增高，电压减小为3，浓度降低；\n半导体二极管 常见结构 伏安特性 体电阻的存在，电流的PN结小； 反向电流大一些； 温度的影响 正向电流：温度升高，本证激发，粒子热运动增加，所以电压固定的时候，温度高的电流可定大，所以曲线往上走；\n反向电流：温度升高，对少子影响大，饱和电流增加，所以曲线往下走；\n二极管作用 单向导电性，规定电流流向，做整流器件；也可以稳压，但一般用反向的稳压 反向的饱和电流，简单的温度传感器； 反向截止电流，稳压二极管； 问：为什么稳压电路不用正向的电压稳压？\n二极管的主要参数 IF：工作的时候电流的最大流过电流， UR：最高反向电压， IR：反向电流（未击穿时）， FM：最高频率（选高频电路的时候需要参考）， 二极管的等效电路 1.上图a为理想的等效电路\n2.b图为常用的等效模型\n上面三张图的 中间没有一杠，这是与普通二极管的区别。\n下面我们看二级管的几个应用：\n整流电路 在上面的这个电路中我们假设交流电10mV，要想在 $u_R$中测量出变化的电流那么需要加一个直流电压，将交流电抬高，曲线图如下：\n上图B点的电压10mV升到A点，它们的关系是： $U_A=U_B+V$,那么此时就可以测量出 $u_R$两端的变化的电流了。具体电路图如下：\n最后得到的波形图是去掉Y轴的负半轴的正弦三角函数图像，也就是整流电路。\n限幅电路 在分析这个电路时，要先判断正向导通和反向截止。\n当 $U_S-U_1\u003c=Uon$的时候截止 当 $U_S-U_1\u003e=Uon$的时候导通 这时候的三角函数上半边会被割掉如下图：\n附件 ",
    "description": "",
    "tags": "模电",
    "title": "模拟电子技术基础笔记",
    "uri": "/branch-bundle-1/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 网站",
    "uri": "/tags/%E7%BD%91%E7%AB%99/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "在标题前面显示图标：\n+++ menuPre = \"\u003ci class='fab fa-github'\u003e\u003c/i\u003e \" +++添加这个后的效果如下：\n附件 ",
    "description": "",
    "tags": "网站",
    "title": "文章标题的多样设计",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/3.%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E7%9A%84%E5%A4%9A%E6%A0%B7%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r第一章 胡冲村被一条蜿蜒曲折的河流环抱着，河水悠悠向东流去，在不远处与几条支流汇聚，形成了一个被称为三岔口的地方。从三岔口向西，沿着泥泞的小路走几十分钟，便能抵达胡冲村。村口有一片灰白色的石斜坡，宛如一块巨大的布匹覆盖在山的一侧，自山顶直泻而下。在这片斜坡上，延伸出一条条绳索，紧紧地将斜坡与江河相连。江河的另一端也有同样的绳索，当这些绳索被拉起时，一张绿色的渔网便会浮出水面，将鱼儿团团围住。\n再往村里走，两侧是一些历经风雨、摇摇欲坠的旧木瓦房，废弃后更添了几分凄凉。穿过这片废墟，映入眼帘的是一排排新建的洋房，它们整齐地排列在公路旁。继续前行，会看到一个T字形的路口，左转处飘扬着一面鲜艳的五星红旗。前方的小学坐落在山脊靠江的位置，地形犹如一个小半岛。学校除了校门口有高墙和杉木围栏外，其余地方都未设防，仿佛大自然的屏障已足够保护这里的一切。\n弥嘟很小的时候就在这所学校读书，那时他和他的姐姐一同住在学校的宿舍里。平日里，他不是在宿舍里等待姐姐放学，就是在校园内玩耍。有一次，姐姐担心他会乱跑，便把他锁在了宿舍中。那天，一对身穿黑色衣服的夫妇在校长的带领下前来视察宿舍，他们发现了被锁在里面的弥嘟。众人皆疑惑不解，为何一个男孩子会被关在女生宿舍里。经过询问宿管阿姨，才得知是弥嘟的姐姐偷偷带弟弟来上学。校长为此事向黑衣夫妇表示歉意，但他们并不介意。那位黑衣女子半蹲下来，试图抚摸弥嘟，但小男孩迅速躲到了赶来的姐姐身后。黑衣女子看着不断吸着鼻涕的弥嘟，嘴角露出一抹温柔的笑容。她从包里抽出几张纸巾，递给了弥嘟的姐姐。姐姐一边帮弥嘟擦干净鼻涕，一边目送那两位神秘的访客远去。在弥嘟眼中，他们是既令人好奇又有些害怕的存在。\n不久之后，在学校背后隔江的山林中出现了一座草房子，四面围墙由杉木搭建而成，周围种植着高大的杉树，后来放在搬到了离学校更远的地方，人们称那个地方为木巴。每当雾气缭绕时，行人只需转过一个弯就能远远望见这座小屋。原来，这座草房子正是之前到访胡冲村的那对黑衣夫妇所建。他们当天来到学校是为了商谈购买事宜，但由于未能与当地政府达成一致，最终选择在山中购置了一块土地，建造了这座居所。草房子附近住着一位名叫卜勇娃的老人，他是胡冲村的村民，负责放养一群黑山羊。村里人普遍认为他是个怪人，甚至有人传言他患有精神疾病。如果你在村子里行走，经常会看到他穿着破烂的衣服，边走边自言自语，偶尔还会对着路人露出诡异的笑容。夜晚，有时还能听到他家中传来的咒骂声。因此，许多人对他避之不及。至于他的名字，许多人都已经遗忘，或许是因为他的第一个孩子叫勇娃，而在胡冲村一带，人们习惯以家庭首个孩子的名字来称呼其父母，有时还会在第一个孩子前加上“卜”字。\n卜勇娃的妻子和孩子们商量后决定让他到山里放羊，以期能够平息他那古怪的脾气。于是，卜勇娃来到了胡冲村江河源头上的木巴，开始了他的牧羊生活。木巴这个地方除了茂密的杉木林外，还生长着满山遍野的梧桐树。每当梧桐花盛开的季节，白的、粉红的花朵如云似霞，铺满了整座山头，花瓣随风飘扬，仿佛给通往黑衣夫妇草房子的小径披上了一层绚丽的地毯。远远望去，这番景象宛如一幅美丽的画卷，令人心旷神怡。\n两位黑衣夫妇来到木巴的第一天，便怀着好奇和友善的心情去拜访了卜勇娃。然而，卜勇娃对他们的到来并不感兴趣，只是默默地赶着自己的山羊，继续向山里走去。尽管如此，这对夫妇并未因此放弃，而是每隔一段时间都会尝试与这位沉默寡言的中年男人交流。然而，三四年过去了，他们始终难以与卜勇娃建立起真正的对话。\n又到了山石榴成熟的季节，在黑衣夫妇的草屋旁，几棵山石榴树结满了硬绿的果实。每到星期五放学时，孩子们总会兴奋地跑到这里摘取这些诱人的果子。这一天，弥嘟的姐姐安排了弟弟们去打水，自己则负责摘山石榴。其他家庭的孩子们也各自分工，有的打水，有的摘果子。吩咐好一切后，他们便各自往木巴山下走去，只留下几个低年级的孩子在原地嬉戏。\n就在这时，弥嘟突然感到肚子一阵剧痛，急忙跑向同龄的伙伴，低声说道：“我肚子疼。”那个孩子指了指学校的方向，说：“往那边走吧，那里有树遮挡，你可以去那里解决。”弥嘟点了点头，强忍着疼痛，朝着那个方向蹒跚而去。\n弥嘟沿着山路往下走，肚子的疼痛渐渐缓解，但他却被眼前的一座草屋吸引住了。不知不觉中，他走到了草屋旁边。突然，左侧出现了一个身穿白色衣服的女子。她的柔长黑发直直地披在两肩，穿着荷花色的上衣和雪白的长裙。弥嘟年纪尚小，并不知道这形象很像电视里的女鬼。他呆呆地看着这位女子，只见她正在梳理自己的细发。\n时间仿佛静止了许久，直到女子终于注意到弥嘟的存在。她微微一笑，白皙的脸颊衬托出端正的五官，那双灵动的眼睛似乎是为了吸引人而生。但在弥嘟的眼里，女子面容苍白，看起来像是快要死去的人，纤细的身体也显得骨瘦如柴。女子的笑容勾起了弥嘟的回忆，他似乎在哪里见过这位女子。\n“小弟弟，你是从哪里来的啊？”女子温柔地问道。弥嘟依然站在原地，沉默不语。女子缓缓朝他走了过来，从身后拿出了一本小册子和一根棒棒糖。“别人的东西不能乱拿。”弥嘟心里想着，后退了几步，准备离开。这时，姐姐的声音从背后传来：“叫你在上面等，你乱跑什么？真是的！”\n白衣女子收起了手中的东西，微笑着对弥嘟的姐姐说：“小妹妹，你也别怪他。”弥嘟的姐姐点了点头，拽着弥嘟离开了。\n“你们去哪了？”二人回来后有一个女孩问。\n“去找弥嘟了！”姐姐回答道。\n“哦哦，回来了就快点走吧，他们都上前走了。”\n“嗯嗯——弥嘟快点，还慢慢吞吞的！”\n弥嘟的姐姐和其他孩子们收拾好书包，迅速离开了木巴。当人多的时候，他们并不觉得有什么可怕的，但此时只有两个女孩子和一个男孩子，还是不由自主地感到害怕。毕竟，这个地方偶尔会传出一些奇怪的声音。弥嘟的姐姐想到这里，背脊一阵凉意，一边拽着弥嘟，一边加快了脚步。\n“也不用这么快吧，你也慢点。”弥嘟抱怨道。\n姐姐笑了笑，转而说道：“你知道几年前要买学校的那对黑衣夫妇吗？”\n“知道啊……”\n“是啊，但是……我刚才去找弥嘟的时候，在下面遇到了一个人，长得特别像几年前的那个女人。当时她还递给我纸巾呢。”\n“会不会是你看错了，人家怎么会来这里呢？”\n“我也希望不是她，不过刚刚那个女人真的好年轻，还穿着一身白色的衣服。”\n“啊？不会是有人死了吧？”\n“不是，就是普通的白色衣服。你也别这么说呀，还在路上呢。”\n同龄的女孩呸呸呸几声，又骂了自己的嘴。本来还没那么害怕，现在被这么一说，弥嘟的姐姐更加心惊胆战。突然，前面传来几声怪异的尖叫，吓得两个女孩尖叫起来，紧紧抱住了弥嘟。几个男孩子从路边的灌木丛中跑了出来，原来他们在玩躲猫猫的游戏，负责找人的孩子找不到这几个男孩，于是他们决定吓唬一下弥嘟一行人。同龄的女孩边走边责骂这些男孩，差点把她们吓死。\n走着走着，弥嘟的姐姐发现弥嘟嘴里塞着一根棒棒糖。“哪儿来的糖？”姐姐问道。\n“我在口袋里摸到的。”弥嘟乖乖地回答。\n姐姐想了想，回家的路上好像确实买了糖，但没有买棒棒糖。难道是其他孩子给的？她也没再多想。\n夜幕降临，夕阳的余晖渐渐消失在天际，森林里也变得越来越昏暗。卜勇娃正赶着羊群回家，尽管四周逐渐被黑暗吞噬，他心中却异常平静。因为他知道，即使是在这样的夜晚，这些温顺的动物也能找到归家之路。而对他来说，迷路从来都不是什么值得担忧的事情。在村里，他经常一个人深夜前往几公里外的地方，即便偶尔迷失方向，他总能凭借一种莫名的直觉重新找回正确的道路。\n当走到山沟附近时，潺潺流水声与阵阵蛙鸣交织在一起，给这寂静的夜晚增添了几分生机。溪水表面反射出微弱的光芒，那是家中炉火映照的结果——每当有客人来访时，母亲总会特意将火堆烧得更旺一些。果然，熟悉的光影再次出现在眼前，这意味着家里又迎来了新的访客。不过对于卜勇娃而言，这种场景早已司空见惯了。\n他熟练地将羊群赶入圈中，随后点燃了一支烟，深深地吸了一口，仿佛想借此驱散旅途中的疲惫。走进屋内，妻子与两个儿子正围坐在桌旁等候着他。“回来了啊，快过来吃饭吧，菜刚热好。”妻子温柔地说道。看着这一幕温馨的画面，卜勇娃内心涌起一股暖流，但同时也不禁陷入沉思：这次家人突然造访，恐怕还是为了那件事……\n“吃饭啦，别发呆了！”妻子的声音打断了他的思绪，也将他拉回现实之中。\n突然，妻子打破了沉默：“明天和我们回家一趟吧。”\n“你们要回去自己回去。”卜勇娃冷冷地回应。\n妻子叹了口气，语气变得沉重：“小六去世了，你作为哥哥，不回去怎么行？”\n“你们要回去自己回去。”卜勇娃依旧冷淡，仿佛这件事与他无关。\n妻子终于按捺不住，怒火中烧：“你是不是被旁边的婆娘给迷惑了？现在想在这里终年不归？”她原本只是劝说，没想到却激起了更大的怒气。\n然而，卜勇娃依然无动于衷，只是冷冷地重复道：“你们要回去自己回去。”\n妻子见状更是气愤不已，两个儿子连忙拉住她，试图缓和气氛。“妈，别生气了，让一步吧。”老大无奈地劝说道，然后无意间调侃了一句，“爸这样疯疯癫癫的，别人也看不上。”\n话一出口，老大便意识到自己说错了话，以为父亲会因此大发雷霆。但出乎意料的是，卜勇娃不仅没有生气，反而慢悠悠地盛了一碗饭，一屁股坐下吃了起来。他边吃边自言自语，显得异常冷漠。\n母子三人见此情景，只好暂时放弃让他回家的念头。\n几天前，张家的小六在床上突然去世。郎中检查后惊讶地发现，小六并非因重病而死，而是因为阳衰过度。这个结果让家人怀疑郎中的判断是否正确。\n小六是卜勇娃的弟弟，早年两人上学时就不好好读书，整天想着赚钱。当时他们的父亲是胡冲的大户，养活六个孩子绰绰有余。但后来父亲病逝，家庭逐渐没落。兄弟俩决定在三岔口建立渔场，并在各个县之间贩卖鱼。几年下来，他们赚了不少钱。卜勇娃用攒下的钱继续上学，那时他已经20多岁，虽然母亲反对，但他还是坚持读完初中，并自学了一些功夫。由于没钱交学费，他的武艺只能止步于此。尽管母亲表面上反对，私下里还是给他送了钱。直到初中毕业那年，母亲因劳累过世，卜勇娃不得不回家料理家事，考高中的梦想也就此搁置。\n后来，卜勇娃娶妻生子，生活似乎步入正轨。然而，一次下井事故中，一块石头砸中了他的脑袋，从此他变得疯疯癫癫，失去了往日的理智。\n听到弟弟去世的消息，卜勇娃毫无反应。两个儿子对他多少有些失望，觉得父亲连最基本的情亲都丢了。而妻子则一直怀疑他是否与旁边的白衣女子有染，才不肯回家。\n第二天清晨，母子三人早早离开了木巴。临走时，老大还帮卜勇娃把山羊赶上了山。或许他觉得自己昨晚的话太过分了，虽然父亲没有说什么，但他心里还是过意不去。\n卜勇娃醒来后，发现自己的羊已经被赶上了山。他独自站在门口，目光呆滞地望着远方。突然，他开始自言自语，时而对着眼前的树木骂骂咧咧。“哗哗”的水声打断了他的咒骂，他循声向屋后走去。\n一位穿着白色上衣的中年男子正在草屋前倾倒污水。男子正好看到出门的卜勇娃，便友好地打招呼：“起早嘛！”\n卜勇娃点了点头，然后问出了一个一直想问的问题：“为啥子要搬到这座里呢？”\n男子显得有些惊讶，因为这次卜勇娃竟然主动搭话了。以前，卜勇娃只是点头后就转身离开。\n“再不出来，家里面的孩子就要没饭吃了。”男子解释道。\n“出门在外不容易，你们是哪里的人呢？”卜勇娃继续问道。\n“外地过来的……”男子简短回答。这时，从屋子里走出一位身穿白衣的女子，大约二十多岁。卜勇娃第一次见到这样的女子，她的一举一动都吸引着他的目光。女子看着卜勇娃那副痴痴的模样，似乎有些得意，笑了笑便又回到了屋里。\n男子见状，脸色变得有些不悦。卜勇娃却依旧沉浸在对女子的迷恋中，完全没有察觉到男子的情绪变化。\n“这是你的女儿吗？生得很好。”卜勇娃赞叹道。\n男子有些不情愿地回答：“是的。”\n卜勇娃继续说道：“真是个好姑娘，长得这么漂亮。”\n男子皱了皱眉，似乎想争辩什么，但最终还是接受了卜勇娃的说法。他叹了口气，说：“是啊，她是我们唯一的希望。”\n卜勇娃点了点头，心中暗自感叹。他转身回到自己的小屋，脑海中依然浮现出那位白衣女子的身影。\n卜勇娃回到屋里，闲着没事在床上找来了烟丝，又从口袋里抽出了一张揉皱了的纸，正准备卷成烟。然而，纸上的字迹让他停了下来。换作以往，他一定会马上卷成烟，然后抽出火柴点起来，但这次他没有这么做。他慢慢地把纸展开，上面写着“在天愿作比翼鸟，在地愿”——后面的字看不清了。\n不知为什么，他突然很想知道后面的内容。回忆起初中时暗恋隔壁班女同学的事，为了追到那位女同学，他好好的学了一年的古诗词。那时的他觉得最美的爱情、最好的告白应该从诗词开始……想着想着，他突然骂了起来，旁边也传来争吵的声音。\n卜勇娃跑到外面，只见白衣女子突然跑到了他身后，嘴里喊着：“帮帮我，帮帮我，我家那个疯了！”\n卜勇娃被这突如其来的状况吓了一跳，但他还是立刻冲上前去。两个男人说着说着便扭打了起来。女子一时间也没办法，只能在一旁焦急地看着。打着打着，卜勇娃从羊圈里抽出一把铲子，一铲子往男子的身上重重地砸去。男子身体扭动了一会儿，顺势倒在了地上。\n女子吓坏了，急忙跑过来一把抱住了男子。卜勇娃见到男子倒在地上，意识也清醒了过来，似乎他的正常状态能通过这种方式唤醒一样。\n两人把男子抬进了屋子，卜勇娃为自己刚才的失误道了歉。女子说没关系，要不是他自己可能已经死在这男人的手里了。说着，女子给卜勇娃倒了一杯水。卜勇娃谢过后接过水杯，一饮而尽。\n接着，他从兜里拿出刚才准备卷的烟，正好抽出了写有“在天愿作比翼鸟，在地愿”字样的纸。他愣了一会，女子看见后问他怎么了。女子的眼力很好，竟看到了上面的字样。\n“这是……”女子问道。\n“哦！这是用来卷烟抽的。”卜勇娃答道。\n“你知道我问的不是这个。”\n“初中那时候写的了。”卜勇娃不知道为什么总感觉眼前的女子与自己很熟，或许是因为她是一个快熟性格的女子？卜勇娃笑着说，接着又谈到了自己以前是怎么追隔壁班女孩子的事情。似乎这是风尘已久的心事，说出来后卜勇娃气色好了许多。\n“写的时候一定很用心吧！”女子边照顾男子，边回答道。\n“或许吧！”卜勇娃迟疑了一会，支支吾吾地回答后，问了一句，“你知道后面的一句是什么吗？”\n“不知道唉！”女子答道。\n“看你是个读书的娃，这个不懂？”\n女子微微一笑，卜勇娃看着她的笑容，有点渗人，顿时感到后背凉凉的。说到底，女子的家真的很凉。\n“‘在天愿作比翼鸟’，后一句是‘在地愿为连理枝’。”卜勇娃嗯了一声，不再说什么。女子回答后便出去倒掉地上的血水，留下卜勇娃一人。\n他看着那张纸，一手拿出烟丝卷成了纸烟，抽出火柴，轻轻滑动火柴，点燃了烟，深深吸了一口。走出去与女子寒暄几句后，他说自己该上山了。\n女子心想，他问自己那句古诗，却不问问它的意思吗？在卜勇娃心里，他早已离开那个世界。\n——–续写\n卜勇娃吸完最后一口烟，将烟蒂在地上碾灭。他抬头望向天空，夜色已经悄然降临，星星在天际闪烁着微弱的光芒。女子从屋内走出来，手里拿着一个手电筒，递给了卜勇娃。\n“山上路不好走，这个你用得上。”她轻声说道，声音中带着一丝关切。\n卜勇娃接过手电筒，点了点头。“谢谢你，真的帮了大忙。”\n女子微微一笑，眼中闪过一丝不易察觉的温柔。“你也救了我，我们算是互相帮助吧。”\n卜勇娃沉默了一会儿，似乎在思考什么。他突然开口问道：“你知道那句诗的意思吗？‘在地愿为连理枝’。”\n女子愣了一下，随即答道：“这句诗出自白居易的《长恨歌》，是形容唐玄宗和杨贵妃的爱情故事。意思是希望在人间也能像树枝一样紧紧相连，永不分离。”\n卜勇娃若有所思地点了点头。“原来如此，挺美的。”\n女子看着他，眼神中多了一丝复杂的情感。“你曾经也这么想过吗？”\n卜勇娃笑了笑，有些自嘲地说：“那时候年少无知，总以为爱情就是一切。现在想想，真是幼稚。”\n女子轻轻叹了口气，仿佛理解了他的心情。“每个人都有过那样的时候，那是青春的一部分。”\n卜勇娃点了点头，心中涌起一股莫名的感慨。他转身准备离开，但又停下了脚步，回头看向女子。“你叫什么名字？”\n女子微微一愣，随后笑了起来。“我叫林婉儿。”\n“林婉儿，”卜勇娃重复了一遍这个名字，仿佛要把它刻在心里。“谢谢你，林婉儿。”\n林婉儿点点头，目送着他离去。卜勇娃打开手电筒，照亮前方的小路，一步步向山上的方向走去。他的身影渐渐消失在夜色中，只留下一束光在黑暗中摇曳。\n林婉儿站在门口，望着卜勇娃远去的方向，心中涌起一种说不出的感觉。她转身回到屋里，继续照顾受伤的男子，心中却始终无法平静。\n这一晚，对两人来说都格外漫长。卜勇娃在山上回忆起过去的点点滴滴，而林婉儿则守在床边，思绪万千。他们各自的心事，就像那夜空中的星星，静静地闪烁着，诉说着各自的故事。\n第二章 清晨的第一缕阳光透过稀疏的云层，洒在了宁静的小村庄上。村里的小路两旁，野花随风轻轻摇曳，空气中弥漫着泥土和花草的清新气息。远处的山峦在晨雾中若隐若现，宛如一幅水墨画。弥嘟家的小院里，几只鸡在院子里悠闲地觅食，偶尔发出几声咯咯的叫声。院子一角的木柴堆旁，弥嘟的姐姐正忙碌地抱起一把把干柴，准备生火做饭。\n回到家后的弥嘟发现父母并不在家，父亲在电视柜上留下了一封信件，上面写着：“去清林湾办丧，大后天回来，照顾好弟妹。”后面还写着日期。弥嘟的姐姐看了信件后收了起来，跑到外面抱柴准备烧火做饭。\n第二天早上，家里来了几位客人，父亲正在与他们拉家常。“这几天酒席太多了，忙不过来啊！”他叹了口气，接着说，“几个人的死法都很怪异，很多人怕是得了什么传染病。”\n吃完早饭后，孩子们也该去上学了。“爸，我下个星期可能不回家，学校那边说让我们留在学校里面复习。”弥嘟的姐姐说道。\n“复习什么？”她父亲问道。\n“就是准备毕业考了，老师让我们好好备考。”\n“行吧，你不回来，弥嘟他们怎么办呢？”这话既是问弥嘟姐姐，也是问他自己。他吸了一口烟，接着说，“你就在学校吧！到时候我去接他们几个小的。”\n说罢，弥嘟姐姐带着弟弟们上了学。到了木巴后，孩子们照旧去摘山石榴。弥嘟挣着自己也要去，姐姐说到时候别人都走了，姐姐可不管你。以为这能把他镇住，没想到弥嘟还是坚持要去。从卜勇娃家和白衣女子的草房中穿过，前面是羊圈，羊圈的右侧有一条路通往后山，山石榴树就在那里。\n姐姐和弥嘟走到羊圈旁，弥嘟姐姐突然说：“你看他们都在前面，等会他们先摘完就走了，到时候我还要带你，我们慢慢走，到时候他们就不等我们了，遇到鬼怎么办？你现在回去，我去摘好吗？”\n但是弥嘟还是不肯，弥嘟姐姐无奈之下放了狠话：“你再这样下次不带你了，让你一个人在后面……”说完，姐姐往回走，继续说：“你要摘你自己去吧！我回去等你。”这么一来，弥嘟也害怕了，差点哭出来，只好原路返回。路过白衣女子门前时，他停留了一会儿，恰好女子开了门。昏暗的背景让弥嘟看不见她家里的全貌，女子依旧微微一笑，只是这次似乎透露着无比的高兴和得意。\n“你还记得这个吗，小弟弟？”说着，女子掏出了一本小册子，递到了弥嘟的眼前。“再送你一根棒棒糖，然后送你这个小册子。”\n弥嘟尝过那颗独特的棒棒糖，确实与以往吃过的不一样。\n“我姐姐说，不能拿别人的东西。”弥嘟说道。\n这时，弥嘟后面走来摘完山石榴的孩子们，他们叫住弥嘟，弥嘟跑向了他们。女子把东西收起来，看向孩子们，孩子们也看向她，都诧异这里竟然住着这么漂亮的姐姐。孩子们走后，卜勇娃从山上下来，准备进屋，看见女子站在门口，问道：“怎么站在门外？”\n“没什么。”女子回答道。\n“对了，你怎么不去上学呢？还在读书吧？”\n“读啊，但是我是在家里读的。”\n“这里吗？”\n“是的，我家那个教我的。”\n之前没注意女子这么说，现在他才注意到，原来被他一铲子打倒的男子是她的丈夫。想到这，他内心竟有些不自在，感觉什么东西一瞬间被拿掉一样。\n“张老师！！”\n卜勇娃转头看向了说话的人——弥嘟的姐姐。他还有点诧异，弥嘟姐姐有些不确定，并再次问道：“是胡冲村的张老师吗？”\n“嗯嗯，是我。”卜勇娃顿了一会才艰难地回答道，他没想到在这里还能遇见认识自己老师这个身份的人。\n在卜勇娃的母亲去世不久后，村里急需一位数学老师。作为村里最高学历的人，卜勇娃被学校聘请去当老师。起初，他是拒绝的。母亲去世后，他身上的钱也花光了，虽然他的父亲留下了一些地产和渔场，但这些财产现在都掌握在其他兄弟手中。在他外出读书的这几年里，家里的这些财产几乎被其他兄弟划分完了。虽说也给他分了一部分，但卜勇娃并不想到田间水上劳作，他想找一个清闲一些的工作。当老师似乎是个不错的选择，但他心里却有些忐忑：自己真的有资格去教那些孩子吗？\n一天，卜勇娃待在家里想出去买东西，但摸了摸口袋，只摸出了一张母亲生前寄给他的钱。这张钱已经被蹂躏得褶皱不堪，或许在市场上已经不能用了。卜勇娃索性回到屋里，坐在破旧的椅子上，陷入了沉思。\n这房子实际上是属于他的弟弟的。按照村里的传统，谁照顾父母或常年赡养父母，父母的房子就归谁。这个人自然不是卜勇娃，而是他的弟弟。弟弟知道卜勇娃不容易，生平也是一个好人，即使卜勇娃天天在家吃吃喝喝，他也不说什么。但是，他的妻子却不这么想。在走访亲戚吃饭的时候，她总拿这件事说事。这些闲话最终传到了卜勇娃的耳朵里。\n一天，家里请人吃饭，来的亲戚说着说着，便把这件事抬到了台面上。这不说还好，一说便一发不可收拾。\n“实（卜勇娃的小名）啊，你也该去找点事做了，天天窝在你弟弟家里……”一位长辈说道，语气中带着些许责备。\n“我说啊，实啊，我说啵，说嘛你也别说我骂你，你在你弟弟家……该找点事做，我和你爸，从小看你长大，现在你爸不在……别给他老人家丢了面子……”另一位长辈接着说道，语重心长地劝诫着。\n卜勇娃沉默不语，心中五味杂陈。他明白这些话并非恶意，但也深深地刺痛了他的心。他知道自己不能再这样下去了，必须做出改变。然而，面对现实的压力和内心的挣扎，他感到无比的迷茫和无助。\n第二天，卜勇娃鼓起勇气来到学校应聘。学校的领导见到他时，语气有些不耐烦：“问你的时候你死活不来，你看现在学校已经不缺数学老师了。”\n卜勇娃的心沉了下来，准备转身离开。这时，领导突然叫住了他：“语文你教得了吗？现在缺一个语文老师，可以教的话就去教语文吧！”\n卜勇娃愣了一下，随即上前感谢，激动地跑回家准备去了。其实，领导聘用他并非真的缺语文老师，而是因为学校曾受过卜勇娃父亲的资助，这个人情领导不能不认。再加上他也听说了卜勇娃的事情，觉得卜勇娃毕竟上过初中，是个有用之才。\n就这样，卜勇娃在胡冲村当起了语文老师，这一干就是五六年。一天早上，卜勇娃因为带学生到宿舍赶蝙蝠，被领导叫到了办公室，并拿到了一张辞退书。他被辞退并不是因为带学生打蝙蝠，而是有学生举报他的教学方式有问题，学校也收到了家长的反馈，迫于压力，学校不得不辞退了卜勇娃。当时，卜勇娃是弥嘟姐姐班的语文老师，而到宿舍赶蝙蝠的事情正是弥嘟姐姐向卜勇娃汇报后，卜勇娃带着孩子们去宿舍驱赶蝙蝠的。\n后来，学校里传着卜勇娃是因为带学生到宿舍打蝙蝠被辞退的谣言。虽然弥嘟姐姐知道那不是事实，但内心还是对此过意不去。\n“这不怪你，我当年被辞退是因为教学方式有问题，这不怪你，你不用放在心上。”卜勇娃吸着烟，淡淡地说道。\n弥嘟的姐姐还想多说些什么，但卜勇娃打断了她：“你该去上学了，不然你的同学先走了。”\n“好的老师，下次放学回家再来看您。”弥嘟姐姐说完便跑了回去。\n“没想到你还有这样的过往。”白衣女子高兴地说道，仿佛发现了什么惊天的秘密。\n“都过去了，现在照样在这放羊。”卜勇娃苦笑了一下。\n“要不来我家坐坐，喝喝茶。”\n卜勇娃婉拒道：“不了，我想回家休息。”\n但白衣女子再次邀请：“上次的帮忙还没感谢呢，怎么说也来家坐坐，喝喝茶以表感谢。”\n自从那次以后，卜勇娃经常与白衣女子搭话，两人也渐渐熟络起来。似乎白衣女子正一步一步带他返回那个世界。\n因为胡冲村的猎人们常在卜勇娃家休息，所以晚上家里灯火通明他也不会觉得奇怪。他想，或许猎人们又得到了猎物，今晚说不定又是一个把酒言欢的夜晚。卜勇娃赶着牛羊往圈子里走去，突然看到一个猎人从白衣女子家里有说有笑地走出来。卜勇娃本想上前问个明白，但转念一想，难道自己要问人家一脸高兴地从里面走出来是有什么好事吗？没等他想明白，那人便笑着对他说道：“回来啦！”卜勇娃感觉自己像是个外来人，要借宿在那位猎人家一样。\n弥嘟姐姐带他上学已经是三四年前的事情了，现在弥嘟已经上了学前班。学前班里只有十几个孩子，与弥嘟最要好的是坐在他前排的阿贝。阿贝和弥嘟从小一起长大，弥嘟有什么事都会告诉阿贝。一天夜里，弥嘟怎么也睡不着，在宿舍里翻来覆去，扰得阿贝用后背顶了顶他。\n“干嘛啊你！”阿贝有些不满地问道。\n“我睡不着。”弥嘟说道。\n“怎么睡不着？”阿贝好奇地问。\n“我给你看一个东西。”说着，弥嘟从兜里掏出一本小册子。小册子上面什么也没有写，翻开一看，第一页画着一栋房子，颇有西方教堂建筑的风格。阿贝看了说道：“这有什么好看的？”\n没等阿贝继续说，弥嘟就跳过了几页。此时能感觉到弥嘟内心激动无比，隔着被子都能听见他心跳的声音。阿贝突然觉着弥嘟的脸颊烫烫的，好像被焖在蒸笼里一样。翻着翻着他突然停了下来，阿贝说：“怎么了？神神秘秘的。”\n弥嘟沉默片刻，一脸害羞的模样。阿贝觉着不对劲，一把将他的手撇开，倒要看看这有什么好藏着掖着的。只见手一杯撇开，小册子上出现了一位女子的画像。女子披头散发，衣着不整，但这却无法遮掩她的美貌。双手撑着身体，张开大腿瘫坐在床上。阿贝直勾勾地看着册子上的画像，他先是一脸羞涩，接着咦了一声，合上画册，一手盖上被子，窝在被子里不敢出来，突然说了一句：“你哪来这些东西的啊！”\n弥嘟支支吾吾地说了实话：“我说实话吧，昨天起床的时候在自己的衣兜里摸到的，也不知道哪个王八蛋放的。”\n“我劝你赶紧把这东西扔了，我爸说偷看女人是混蛋！”阿贝严肃地说道。\n弥嘟先是啊了一声，接着内心又有点舍不得，最终还是把它丢进了宿舍的垃圾桶里。可在这之前，弥嘟早把里面的女人男人，还有他们干的事看了个遍。\n第二天上午是语文课，但语文老师没来，来的是学校的一个领导。领导替语文老师上课，问孩子们上到第几页时，孩子们异口同声地回答着，唯有弥嘟还想着昨晚的事情，生怕阿贝把这件事情都告诉了班级里的同学。下课的时候，阿贝转头和同桌低声说着什么，弥嘟看见后更加担心自己昨晚的事情败露。放学后去食堂领饭盒的时候，弥嘟理也不理阿贝。那时候上学的学生还需要自己准备米油盐，学校只负责帮孩子们煮。等放学后，食堂的阿姨会把煮好的饭菜放到窗口前。孩子们每天早上除了洗脸刷牙，还要准备自己的饭菜，把大米放到铝饭盒里，再拿出铁制的口盅，从自己的木箱里舀一勺猪油，抓一把豆子，一起放进口盅里，接着倒点盐，倒些水，放到食堂的窗口前就可以了。\n弥嘟接过哥哥领来的口盅，一屁股坐在了水池旁的柳树下。旁边的一个孩子骂道：“妈的一边去！”弥嘟知道自己惹不起，只好找了一个地方坐了下来。傍晚的时候，阿贝主动搭上话，没等阿贝开始，弥嘟就急切地问：“你是不是把昨晚的事告诉小蒋了？小蒋就是阿贝的同桌，今早阿贝还与他窃窃私语，弥嘟都看在眼里。”\n阿贝没把这当回事，回了一句没有后，急着说自己的事：“我同桌说最近胡冲村死了很多人，今天我们的数学老师亲戚也死了，所以数学老师今早没来。”\n阿贝说的数学老师也就是他们的语文老师，同时还是他们的班主任。班主任不在，晚上的课领导也没来，教室里吵吵闹闹的。阿贝越说越来兴致，一口气把胡冲村最近死人的事都告诉了弥嘟。弥嘟听了直冒冷汗，晚上又睡不着了。睡不着不是因为今天听了阿贝说的死人的事，而是没了小册子的事。弥嘟爬起来想去垃圾桶看看小册子有没有被倒掉——果然还是被倒掉了。\n",
    "description": "",
    "tags": "恐怖",
    "title": "草屋夫妇",
    "uri": "/textbook/5.%E7%99%BD%E9%AA%A8%E5%A4%AB%E5%A6%87/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 恐怖",
    "uri": "/tags/%E6%81%90%E6%80%96/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: Version",
    "uri": "/categories/version/"
  },
  {
    "breadcrumb": "Maloudown \u003e 三、关于",
    "content": " 附件 ",
    "description": "",
    "tags": [
      "网站版本",
      "网站优化"
    ],
    "title": "版本",
    "uri": "/about_create_web/%E7%89%88%E6%9C%AC/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 网站版本",
    "uri": "/tags/%E7%BD%91%E7%AB%99%E7%89%88%E6%9C%AC/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 网站优化",
    "uri": "/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B4-拓展笔记",
    "uri": "/categories/b4-%E6%8B%93%E5%B1%95%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 10.微信小程序",
    "content": " 附件 ",
    "description": "",
    "tags": "微信",
    "title": "基础知识",
    "uri": "/branch-bundle-1/10.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 微信",
    "uri": "/tags/%E5%BE%AE%E4%BF%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: git",
    "uri": "/tags/git/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 报错与解决",
    "uri": "/tags/%E6%8A%A5%E9%94%99%E4%B8%8E%E8%A7%A3%E5%86%B3/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "1、使用git commi -m “……“时报错： Your branch is up to date with ‘origin/master‘ 今天在提交项目的时候报了这个错误，在网上查了解决办法，有的说创建新的分支可以解决，但我的不行。\n最后我的解决办法是先退出git base here，再重新进入，下面是具体步骤：\n先使用git add .； 接着使用git status -s查看我更改的文件，也是我要推送的文件，如果前面的有M和??，那么久重新更新文件，然后重复上面的步骤； 发现前面的M是绿色的后就可以使用git commit -m \"文件备注\"； 然后推送就可以了git push origin main。 AndroidStudio中的grable下载很慢，如何解决？ 参考地址\n这里的关键命令是git status -s，我现在搞不懂这个错误产生的原因……\n虚拟机连接不上网络，没有分配ENS33 参考链接\n浏览器突然无法访问某些网站，之前可以突然不行。 解决办法： 在浏览器中关闭，使用安全的 DNS 指定如何查找网站的网络地址，然后就可以访问了，原因我还没弄清楚。\nAndroidStudio中为什么不建议使用case R.id.generate判断，而是使用if(v.getId() == R.id.generate)？ 1.当使用Switch语句写如下代码时，\nswitch (v.getId()){ case R.id.generate: break; case R.id.add: break; }（红色表示报错）如果报错android studio报错constant expression required， 可以把Switch语句换成if-else语句即\nIf（v.getId() == R.id.generate） { …… }else if（v.getId() == R.id.add）{ …… }这样就可以了。来源以及具体原因： https://blog.csdn.net/weixin_43912621/article/details/106178388\n附件 ",
    "description": "",
    "tags": [
      "github",
      "报错与解决",
      "git"
    ],
    "title": "常与问题总结",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/github%E5%B8%B8%E9%81%87%E9%97%AE%E9%A2%98/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 后端",
    "uri": "/tags/%E5%90%8E%E7%AB%AF/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目",
    "content": "比赛说明 自己有幸参加这次唛盟杯的比赛，这次比赛流程如下：\n一、报名时2024年1月1到31日本来是12月份但延期了。\n二、培训时间，现在还不确定，不过也是可以肯定是年后的事了。\n三、项目制作时间3-5月，不知道后面会不会改。\n四、项目环境及操作流程\n（一）、开发工具\n1、要求使用唛盟低代码平台作为开发项目模板唛盟低代码平台链接；\n2、要求使用唛盟研发管理系统（唛盟xm）进行软件研发项目管理唛盟研发管理系统链接;\n（二）、唛盟xm操作流程\n1、先在唛盟xm中建立一个产品，产品名称为“知识产权流程管理系统”； 2、细化产品需求； 3、由产品派生一个项目，构建项目团队； 4、由需求派生项目任务，并确定任务执行人、计划完成时间等； 5、编制测试用例，建立测试计划，执行测试； 6、出具项目报告，提交结项申请。 （三）、代码提交\n官方提供代码库链接，我们下载后，在该代码库基础上进行开发、提交代码。\n比赛题目 一、项目主题 知识产权流程管理系统\n二、项目描述\n该系统用于知识产权项目申报的全过程跟踪管理，其功能包括：\n客户下单、 提交申请、 申请反馈、 订单查询、 订单详情、 文档查阅下载等六大部分。 该系统分为客户端和管理端两个子系统。客户端对客户开放，主要功能包括：\n客户下单、 付款、 订单查询、 订单进度消息推送（推送到公众号、网站内部消息）、 文档查阅下载等。 管理端对管理人员开放，不对客户开放，负责订单管理、文档上传（批量上传）等。\n三、项目需求 （一）、用户端\n个人中心模块：\n1、订单查询\n分为我的订单（综合查询）及商标、专利、版权、科技项目四大子类查询，订单查询按全部业务下单时间顺列。\n订单查询功能大致效果图： 2、订单详细\n可根据订单详情按钮跳转到对应的订单详情。 订单详情页展示图： （二）、管理端\n订单管理模块：\n1、订单查询\n查询订单，展示列表。\n2、订单详细\n在订单列表中点击某个订单，进入订单详情。\n3、文档上传\n在订单详情页，点击文档上传，选中本地文件，上传本地文件到服务器，支持批量、单文件上传。\n注册唛盟账号 队长和队员注册账号 一、扫描一级部门的二维码\n这一部分只建议参加了比赛的网友查看。本次是组队参加，一队3-5人，队长要在他们的官方网页端注册号团队（二级部门），方便后面的项目管理，然后再通过一级部门添加自己的团队，首先是扫描官方给的二维码，扫这个二维码后注册就会在一级部门下，这也是要注册在一级部门之下的办法，\n二、授权登录成功后，跳转到提示页面，点击“首页”\n三、进入低代码平台首页，按照提示，点击“账户明细”\n四、按照提示，输入姓名，并提交\n五、点击唛盟低代码平台官网，选择微信扫码登录\n唛盟低代码平台官网：https://maimengcloud.com/lcode/m1/#/login\n六、看到用户名称是自己的即报名成功\n队长注册团队 1要求 1.构建每个参赛团队的独立部门 2.将参赛队员拉入部门 3.给每个参赛队员设置好岗位 2相关环境 唛盟账户系统\n3操作步骤 3.1 在一级部门，即总部下建立子部门\n进入【部门管理】，点击【添加下级】\n3.2输入部门信息\n部门名称要求：以参赛团队名称作为部门名称 上级领导选：一级部门 部门负责人：选参赛团队组长 部门性质：技术部门 协作类型：内部组织 其它字段不填\n（如果你不是第一届比赛的同学，那这个不需要关注，可能每年都不一样）\n3.3保存提交\n3.4把岗位挂接到部门上\n【部门管理】中找到刚才建立的部门，点击【岗位】按钮弹出以下岗位选择框：\n选择左边需要绑定的岗位，移动到右边，点击【提交】按钮即完成岗位绑定（如果没有显示岗位，多次刷新，或者退出重新登录，这个知识第一届遇到此问题解决的方案）\n3.5把用户拉入部门\n打开【用户管理】菜单，先把自己的搜索出来，如果不是通过一级部门的二维码注册的，会搜不到的哦。找到需要拉入的队友，点击【部门/岗位】\n弹出以下部门岗位选择界面：\n在弹出的界面中左边选中归属的部门，右边选中岗位，再【提交】即可\n这部分本来也不想记了，毕竟没什么用了，可能下一届又不一样了，但想想自己记一下当作回忆也可以。\n安装git和nodejs 在安装前我们通过这个链接https://gitee.com/maimengcloud/mdp-lcode-ui-web去看看这个项目的介绍，\n大概浏览一下，然后往下拉根据导航直接跳到 快速开始\n这里并不是说其他的不重要，只是说对于一个项目而言如果不是涉及本地启动的话不必花费时间去纠结，等你能让项目在本地启动后再回来看看也不迟，当然这也有弊端，可能会错一些细节哈。\n在快速开始的地方提到：\n注意：该项目使用 element-ui@2.3.0+ 版本，所以最低兼容 vue@2.5.0+ nodejs版本v14.16.1\n所以我们安装的时候要注意版本的问题尽量不要选太高的，如果你已经安装了一部分或全部，而且版本很高或很低，这样也不必太担心（大不了删掉重新安装，哈哈），下面是我的一些经验，希望帮到你。\ngit的安装 这部分没有太多可讲的，网上有很多的教程，讲的也很好，这里需要你记住的一条命令是：\ngit clone \u003c远程仓库地址\u003e \u003c本地存放目录\u003e这里举个例子，就比如这次比赛用到的这个项目,我们建一个文件夹装要下载的项目，比如是mdp文件夹，然后右键，win11选显示更多，在弹出的选项选择： git bash here\n然后复制下面的内容回车就可以了。\ngit clone https://gitee.com/maimengcloud/mdp-lcode-ui-web.git mdp-lcode-ui-web/\n但是有的时候也会因为网速的问题，导致无法下载，比如回车后报错，如下:\nCloning into ‘mdp-lcode-ui-web’… fatal: unable to access ‘https://gitee.com/maimengcloud/mdp-lcode-ui-web.git/': Failed to connect to 127.0.0.1 port 26501 after 2017 ms: Couldn’t connect to server\n简单翻译理解就是这个远程仓库无法访问，其实这也是使用让我比较烦恼的问题，这里的原因我可能没办法给你讲清楚（你有时间可以去琢磨哈），但有个软件可以分享给你，帮你解决这个问题，即 watt toolkit ,而且这个软件在微软软件商城就有。\n下载后选github，然后点击一键加速。\n然我们再回到git base here，再次输入刚才的命令回车，\n发现刚才的代码仓库已经下载到本地了。\n如果你使用上面的软件还是无法下载远程的仓库，那你需要根据报错信息在网上查考相关的信息，这里提供上面报错的可能解决方案，只是针对上面的问题哦！参照文章\n安装node 网上可能称为nodejs都是一个工具，这个工具的简介还请参照官方，这里我们有做过多的了解哦。在安装node之前我们要先安装nvm。这是一个管理node的工具，这里安装的主要目的是 升高或降低node版本，简单就是想安装哪个版本（已发布且可下载的版本）的可以用这个工具来实现。\nnvm是否要安装取决于你的情况，除了nvm，此次项目还需要安装工具node，vue，mvn。\n方案一：为防止版本过高过低影响运行，以后可能还需要，最好是下载nvm管理node，然后也要了解升级或降低vue版本的方法，最后下载mvn；\n方案二：自己不管安装还是没安装，直接安装node，vue，mvn，本次项目用到的node，vue，mvn都在package.json文件里定义写好了，运行后会根据里面去下载，似乎对项目没太大影响（因为我工具处于最高版本，或是相对低一点的版本，使用相同的命令，报错都是一个，基于这点你可以尝试。）\n方案一 安装nvm 参照文档 关于文章的几点说明：\n登录github的时候记得开watt toolket; 如果nvm下载不了要刷新或者退出重新进入，多试几次； 基于本次的项目我们只看文章的一——四，五往后有时间就了解一下就好了； 里面的 三、配置路径和下载源我们需要把淘宝镜像改为如下：\nnode_mirror: https://cdn.npmmirror.com/binaries/node/ npm_mirror: https://cdn.npmmirror.com/binaries/npm/这是因为淘宝的镜像换了。\n接着参照文章，目的是node还要做一些配置，主要node的环境变量设置，还有目录node_cache和目录node_global的一些设置。从文章的下图开始看，关于node的下载就不看了。 注意在设置目录node_cache和目录node_global时，\nnpm config set prefix “\u003c自己的文件目录\u003e\\node_global” npm config set cache “\u003c自己的文件目录\u003e\\node_cache”\n这两个路径时要记得把它改成自己安装的路径：\n安装指定的vue版本 情况一：你没安装过vue 首先你要先安装好node，然后用node的npm工具安装vue。\n使用命令查看可安装版本：\n要查看的vue版本是1.x和2.x的\nnpm view vue-cli versions --json 要查看的vue版本是3.x的\nnpm view @vue/cli versions --json安装vue指定的版本：\n安装的vue版本是1.x和2.x的\nnpm install -g @vue/cli@版本号 yarn global add @vue/cli@版本号 要查看的vue版本是3.x的\nnpm install -g vue-cli@版本号 yarn global add vue-cli@版本号第一次安装要去配环境变量。\n情况二：你安装过vue 卸载已经安装的Vue Cli\n卸载 3.x 或 4.x 版本的Vue Cli\nnpm uninstall -g @vue/cli yarn global remove @vue/cli 卸载 1.x 或 2.x 版本的Vue Cli\nnpm uninstall vue-cli -g yarn global remove vue-cli重复情况一的步骤，然后打开cmd，输入：\nvue -V显示安装的版本则说明安装完成。\n原文章链接\n安装mvn（Maven）工具 直接参照这个文章就好了。\n方案二 安装node和vue 参照文章，同样的里面涉及到镜像文件的设置要注意换掉：\nnode_mirror: https://cdn.npmmirror.com/binaries/node/ npm_mirror: https://cdn.npmmirror.com/binaries/npm/除此之外在设置目录node_cache和目录node_global这两个路径时要记得把它改成自己安装的路径：\nnpm config set prefix “\u003c自己的文件目录\u003e\\node_global” npm config set cache “\u003c自己的文件目录\u003e\\node_cache”\n安装mvn 直接参照这个文章就好了。\n至此工具就就安装完了，接着我们就要去启动项目了。\n本地启动项目 本次使用的系统是win11和code应用程序，如果你用的不是这个系统和应用程序情况可能不一样哈。\n根据项目的简介开始运行项目 这里我使用的是code应用程序（你如果用的是别的应用程序另说咯），点击文件夹用code打开后，根据项目文档执行命令：\nnpm install结果…………………………报错啦（我就知道没这么简单）！！！错误如下：\n上面的报错意思是：在尝试安装项目依赖时，npm遇到了依赖冲突问题。具体来说，babel-loader需要webpack的版本在2、3或4之间，但是你的项目中已经安装了webpack的5.90.1版本。这导致了peer依赖冲突，因为babel-loader期望的webpack版本与实际安装的版本不匹配，\n解决办法如下：\n1.查看自己的node版本；\n``` node -v ``` 2.修改\"package.json\"，在\"devDependencies\"中增加\"node\": “^21.6.1\"依赖；\n``` \"node\":\"^21.6.1\", ``` 3.npm install -s node-sass@4.14.1;\n4.npm install –save –legacy-peer-deps;\n结果……………………报错啦！！！！！ 修改\"package.json\"，原来的改为\"node\": \"^13.14.0\"依赖； 再次运行结果没报错。 5.npm install –registry=https://cdn.npmmirror.com\n接着我们运行如下代码 `npm install --registry=https://cdn.npmmirror.com` 6.npm run dev\n运行npm run dev，结果还是报错了…… 这里的错误说vue-template-compiler的版本为2.7.16，那我们就去\"package.json\"找到vue， 原来的vue版本： 把上面的修改为`\"vue\":\"^2.7.16\",` 这时候要重新运行 `npm install --save --legacy-peer-deps`,然后再次运行 `npm run dev`; 结果还是报错，如下： 大概意思是没有找到ajv这个包，那么我们在\"package.json\"里的 **\"dependencies\"** 添加`\"ajv\": \"^8.12.0\",` 然后重复`npm install --save --legacy-peer-deps`, `npm run dev`操作就可以了。 显示如下： 我们再看看页面，页面如下： 到这里说明没问题了。 从上面我们可以了解到一点，自己安装的版本似乎并不会影响项目的运行，所以选择方案二来进行安装似乎更简单，但从往长远的看方案一更更好，他可以随时换版本，更为方便。\n原文章链接\n",
    "description": "",
    "tags": [
      "前端",
      "后端"
    ],
    "title": "唛盟杯比赛详记",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E5%94%9B%E7%9B%9F%E6%9D%AF%E9%A1%B9%E7%9B%AE%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 前端",
    "uri": "/tags/%E5%89%8D%E7%AB%AF/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "拥有一个属于自己的服务器个人感觉就很赞，我最初是在不买公网IP情况下，用一台电脑做服务器，然后另外一台电脑可以远程访问，部署网站，然后别人可以访问这个网站，这样一个功能。如果你也有这样的想法还请阅读下去，希望自己的经验对你有所帮助。\n所需设备 一台旧电脑，一台目前在使用的电脑。\n在旧电脑上安装natapp程序 在百度上搜索NATAPP，或点击这个链接:NATAPP,\n进入网站后先简单注册一下用户,顺便实名认证一下，因为买隧道会提示需要实名，接着点击首页下载自己的电脑系统对应版本，我的是Windows（下面的测试也是基于Windows）\n下载好后解压文件，得到如下图程序：\n在解压文件下新建一个文件： config.ini,做好这一步后我们去购买免费的隧道，如下图：\n点击网站的文档，然后点击教程/文档里的 使用本地配置文件config.ini 文章，\n然后复制里面的配置信息：\n#将本文件放置于natapp同级目录 程序将读取 [default] 段 #在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置 #命令行参数 -config= 可以指定任意config.ini文件 [default] authtoken= #对应一条隧道的authtoken clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空, log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为none loglevel=ERROR #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUG http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空在字段authtoken后面值在我的隧道配置里可以找到，如下：\n复制下图authtoken的值填到config.ini文件里\n我这边演示的效果如下：\n完成上面的操作后，我们运行NATAPP程序，结果如下：\n你会得到一个随机的网址，这个网址指向你的本地端口，当你有网站挂载到本地端口时，你就可以通过网址访问到你的本地端口网址，内网外网都可以，但是这个网址每一次运行都会不一样，这点需要注意，然后就是端口的设置，看下图：\n我这里写的的端口是1313，如果你网站运行后不在1313，例如你运行网站后，本地的网站启动端口是8080.那你就把这个地方的1313改为8080就可以了。\n下面我们举个例子看看，假设我现在我需要外网的网友访问我挂在在自己电脑本地的网站，那们在做好上面的操作后我先去启动自己的网站，这里使用hugo的网站模版，用code程序打开网站模版，然后调出终端，在终端输入命令 hugo server ,表示启动网站，如下图：\n然后去复制刚才运行NATAPP程序后的网站，在浏览器中打开，我们先试一下局域网能不能访问，结果如下：\n将网站发给自己的朋友，测试外网是否可以访问，\n结果是外网可以正常可以访问。\n那么到这里你的电脑其实就充当了一台服务器，将网站放到了你电脑上，只要你的电脑保持开机状态那么别人就可以一直访问你的网站，或许NATAPP网站还有别的有趣功能，所以你不妨去摸索摸索，所不定可以找到多次启动NATAPP指向你本地的网址不变，你也就不用每次启动后都要发新的网址给对方了。\n那么其实到这里就差不多了，但是我们还需要用一台电脑控制另一台电脑，简而言之就是电脑的远程登录，其实电脑远程登录有许多的方法，这里我需要借助一个来实现内网穿透，其实上面的旧电脑变服务器也是使用了内网穿透， 附件 ",
    "description": "",
    "tags": [
      "前端",
      "网络",
      "网站"
    ],
    "title": "如何用旧电脑搭建自己的服务器？",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E7%94%A8%E6%97%A7%E7%94%B5%E8%84%91%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 网络",
    "uri": "/tags/%E7%BD%91%E7%BB%9C/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 哲学",
    "uri": "/tags/%E5%93%B2%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 庄子",
    "uri": "/tags/%E5%BA%84%E5%AD%90/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 11.哲学",
    "content": "今天通过王德峰老师的视频课来进一步的了解《庄子》的哲学之道，推荐看曹楚基注释的《庄子》。\n行无为而知避害，避害就是避开人为，像自然灾害不在道家讨论的范围内。避害的方法有两个:\n一是天下的人为的事情辨认出来。 二是自己不参与任何人为的事情。不参与是一种人生态度。 一、如何辨别人为？\n二、如何不参与人为之？\n庄子行于山中，见大木枝叶盛茂。伐木者止其旁而不取也。问其故，曰:“无所可用。”庄子曰:“此木以不材得终其天年。”夫子出于山。舍于故人之家。故人喜命竖子杀雁而烹之。竖子请曰:“其一能鸣，其一不能鸣，请奚杀?”主人曰:“杀不能鸣者。”明日弟子问于庄子曰:“昨日山中之木以不材得终其天年，今主人之雁以不材死，先生将何处?”庄子笑曰:“周将处夫材与不材之间。材与不材之间，似之而非也，故未免乎累。若夫乘道德1而浮游2则不然3。 ——《庄子山木篇》\n全身避害，终究避不了害，怎么办呢？\n列子有言：生非贵之所能存，生非爱之所能厚。\n老子的给出的方法：贵以身为天下，若可寄天下;爱以身为天下，若可托天下4。\n下面是原文： 宠辱若惊，贵大患若身。 何谓宠辱若惊?宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身?吾所以有大患者，为吾有身，及吾无身，吾有何患?故贵以身为天下，若可寄天下;爱以身为天下，若可托天下。 ——《道德经》第十三章\n接下来讨论逍遥游与齐物论。前一篇将境界，后一篇讲道理，前一篇讲要达到哪一种境界，后一篇是如何讲达到这种境界。\n《逍遥游》原文 北冥有鱼，其名为鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天，而莫之夭阏者，而后乃今将图南。蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？\n汤之问棘也是已：“穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云；抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鷃笑之曰：‘彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？’”此小大之辩也。\n故夫知效一官、行比一乡、德合一君、而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。\n尧让天下于许由，曰：“日月出矣，而爝火不息；其于光也，不亦难乎？时雨降矣，而犹浸灌；其于泽也，不亦劳乎？夫子立而天下治，而我犹尸之；吾自视缺然，请致天下。”许由曰：“子治天下，天下既已治也；而我犹代子，吾将为名乎？名者，实之宾也；吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣！”\n肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不反。吾惊怖其言。犹河汉而无极也；大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”曰：“藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子，不食五谷，吸风饮露，乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。吾以是狂而不信也。”连叔曰：“然。瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之！是其言也犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤：大浸稽天而不溺，大旱金石流，土山焦而不热。是其尘垢秕糠将犹陶铸尧舜者也，孰肯以物为事？”宋人资章甫而适诸越，越人断发文身，无所用之。尧治天下之民，平海内之政，往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。\n惠子谓庄子曰：“魏王贻我大瓠之种，我树之成，而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋曰：‘我世世为洴澼絖，不过数金，今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将，冬，与越人水战，大败越人。裂地而封之。能不龟手一也，或以封，或不免于洴澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽，而浮于江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”\n惠子谓庄子曰：“吾有大树，人谓之樗。其大本拥肿而不中绳墨，其小枝卷曲而不中规矩，立之涂，匠者不顾。今子之言大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不辟高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”\n轻物重生————老子:反者道之动，以不变应万变————庄子:齐生死一物我\n附件 道德：事物的德性。 ↩︎\n浮游：即物物而不物于物。意思是说，做一件事情，不被这件事情所支配。 ↩︎\n若夫乘道德而浮游则不然。按照事物的德性去做该做的事情，但又不被事物所支配。 ↩︎\n看重自己的身体把它等同于看重天下，于是就可以把身体寄托于天下（这里这么说的原因是如果你爱惜自己的身体向把一艘船藏到山沟里一样，不让人发现，但第二天还是被人偷走了一样，如果你把船藏于天下，那么不管怎么样船都不会被偷走。）。爱惜自己身体等同于爱惜天下，于是可以把它寄托于天下。 ↩︎\n",
    "description": "",
    "tags": [
      "庄子",
      "哲学"
    ],
    "title": "庄子之道",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/%E5%BA%84%E5%AD%90%E4%B9%8B%E9%81%93/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 费尔巴哈",
    "uri": "/tags/%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 11.哲学",
    "content": "一\n从前的一切唯物主义（包括费尔巴哈的唯物主义）的主要缺点是：对对象、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作感性的人的活动，当作实践去理解，不是从主体方面去理解。因此，和唯物主义相反，能动的方面却被唯心主义抽象地发展了，当然，唯心主义是不知道现实的、感性的活动本身的。费尔巴哈想要研究跟思想客体确实不同的感性客体：但是他没有把人的活动本身理解为对象性的［gegenständliche］活动。因此，他在《基督教的本质》中仅仅把理论的活动看作是真正人的活动，而对于实践则只是从它的卑污的犹太人的表现形式去理解和确定。因此，他不了解“革命的”、“实践批判的”活动的意义。\n二\n人的思维是否具有客观的［gegenständliche］真理性，这不是一个理论的问题，而是一个实践的问题。人应该在实践中证明自己思维的真理性，即自己思维的现实性和力量，自己思维的此岸性。关于思维——离开实践的思维——的现实性或非现实性的争论，是一个纯粹经院哲学的问题。\n三\n关于环境和教育起改变作用的唯物主义学说忘记了：环境是由人来改变的，而教育者本人一定是受教育的。因此，这种学说一定把社会分成两部分，其中一部分凌驾于社会之上。\n环境的改变和人的活动或自我改变的一致，只能被看作是并合理地理解为革命的实践。\n四\n费尔巴哈是从宗教上的自我异化，从世界被二重化为宗教世界和世俗世界这一事实出发的。他做的工作是把宗教世界归结于它的世俗基础。但是，世俗基础使自己从自身中分离出去，并在云霄中固定为一个独立王国，这只能用这个世俗基础的自我分裂和自我矛盾来说明。因此，对于这个世俗基础本身应当在自身中、从它的矛盾中去理解，并在实践中使之革命化。因此，例如，自从发现神圣家族的秘密在于世俗家庭之后，世俗家庭本身就应当在理论上和实践中被消灭。\n五\n费尔巴哈不满意抽象的思维而喜欢直观；但是他把感性不是看作实践的、人的感性的活动。\n六\n费尔巴哈把宗教的本质归结于人的本质。但是，人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。\n费尔巴哈没有对这种现实的本质进行批判，因此他不得不：\n（１）撇开历史的进程，把宗教感情固定为独立的东西，并假定有一种抽象的——孤立的——人的个体。\n（２）因此，本质只能被理解为“类”，理解为一种内在的、无声的、把许多个人自然地联系起来的普遍性。\n七\n因此，费尔巴哈没有看到，“宗教感情”本身是社会的产物，而他所分析的抽象的个人，是属于一定的社会形式的。\n第八条\n全部社会生活在本质上是实践的。凡是把理论引向神秘主义的神秘东西，都能在人的实践中以及对这个实践的理解中得到合理的解决。\n九\n直观的唯物主义，即不是把感性理解为实践活动的唯物主义至多也只能达到对单个人和市民社会的直观。\n十\n旧唯物主义的立脚点是市民社会，新唯物主义的立脚点则是人类社会或社会的人类。\n十一\n哲学家们只是用不同的方式解释世界，问题在于改变世界\n自我异化的解释\n类力量：\n肉体存在于感性存在 随地大小便是前者，上公厕表示后者\n资本主义的三大作用 推动世界史的形成， 为人类的全面发展准备物质资料\n人是人感性活动的产物，人类与自然界打交道 人的类存在基础是感性存在 感性的存在就是把自然的东西变成人的东西，就是变成社会的存在，就像美，美的感觉的\n人不仅是感性的对象，还是感性的活动的产物\n法哲学：philosophy of right ——–\u003e 权利 权力哲学：philosophy of power ——-\u003e 权力 power ^ | （决定）-----------------\u003e历史唯心主义 | | right right(上层建筑) ^ | （决定）-----------------\u003e历史唯物主义 | | power(经济建设) ------------------------------------------------------------------ right(上层建筑) ^ | （规范上层建筑考的是什么？）-----------------\u003eidiology(宗教或哲学) | | power(经济建设)1.生产力决定生产关系本质上说的是什么？\n社会权利的更替，新的社会权利如何战胜就得社会关系。\n2.经济基础决定上层建筑实际上说的是什么？\n社会权力如何穿上理性的外衣，编程合法的权力体系。\n3.生活决定意识，这揭示了马克思主义所说的实践概念\n决不以任何理论为前提的社会活动成为实践，复旦大学哲学系教师王德峰曾举一个例子，他说恋爱的一对男女在进行的社会活动就是实践，他们的相爱决不以任何理论为前提。\n同时借助这个例子说明马克思主义中所说的本质是消失了的存在，这个含义王老师是通过德语存在单词进行解释的，还是恋爱的例子，恋爱的本质是什么呢？是失恋，当一方或双方失恋后这个存在的爱情消失了，也就是失恋了。\n附件 ",
    "description": "",
    "tags": [
      "费尔巴哈",
      "哲学",
      "马克思主义哲学"
    ],
    "title": "费尔巴哈提纲",
    "uri": "/branch-bundle-1/11.%E5%93%B2%E5%AD%A6/%E8%B4%B9%E5%B0%94%E5%B7%B4%E5%93%88%E6%8F%90%E7%BA%B2/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 马克思主义哲学",
    "uri": "/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%93%B2%E5%AD%A6/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 软件",
    "uri": "/tags/%E8%BD%AF%E4%BB%B6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目 \u003e 贺青工程",
    "content": "设计一款可以参加志愿活动的小程序，其制作流程大致如下：\n需求分析与规划 确定目标用户群体及其需求：考虑志愿者、活动组织者和管理员等不同角色的功能需求。\n志愿者：\n注册/登录：志愿者可以通过手机号、邮箱或第三方账号进行注册和登录。 个人中心：查看并编辑个人信息，包括姓名、联系方式、服务时长、参与过的活动记录等。 活动浏览：查看活动列表，搜索感兴趣的服务项目，支持按地区、时间、类型筛选。 活动报名：选择感兴趣的志愿活动进行报名，填写相关报名表单，并能收到报名成功或失败的反馈信息。 签到打卡：参加活动时通过GPS定位、二维码扫描等方式进行签到和签退，记录服务时长。 互动交流：可在活动详情页留言评论，与其他志愿者交流心得，也可以对已完成的活动进行评价。 积分系统：根据参与活动的情况获取积分，可用于兑换礼品或其他激励。 活动组织者：\n活动发布：创建新的志愿活动，填写活动名称、地点、时间、内容描述、所需志愿者数量、技能要求等详细信息。 活动管理：查看已发布的活动状态，审核志愿者报名申请，确认志愿者名单，发送通知消息给志愿者。 数据统计：查看各项活动的报名人数、实际参与人数、总服务时长等统计数据。 评价反馈：查阅志愿者对活动的评价和建议，以便改进后续活动组织。 资源管理：上传活动相关的文档、图片等资源，管理活动物料。 管理员：\n用户管理：审核志愿者注册信息，处理用户投诉与咨询，维护用户账户安全。 权限管理：分配不同的角色权限，如设置哪些用户可以发布活动、审核报名等。 活动审批：对于某些大型或重要的活动，可能需要经过管理员审核后才能正式发布上线。 系统配置：设置全局参数，如积分规则、活动类别等基础数据的增删改查。 数据分析：获取平台整体运营数据，分析用户行为、活跃度以及志愿服务的整体状况，为决策提供依据。 功能列表梳理 活动浏览、报名参与、签到打卡、服务时长记录、通知公告、评价反馈、积分兑换等功能模块。 数据结构设计：定义数据库表结构，包括但不限于用户信息、活动信息、报名记录等。 原型设计与UI/UX设计 创建低保真或高保真原型，展示小程序的主要界面布局及交互流程。 设计符合用户体验的UI界面，确保简洁易用且美观大方。 技术选型与开发环境搭建 根据团队技术栈选择合适的开发平台，如微信小程序、支付宝小程序、百度小程序等。 搭建开发环境，安装所需的IDE工具（如微信开发者工具）及相关依赖库。 后端服务器开发 设计并实现后端API接口，处理用户的注册登录、活动发布与管理、报名审核等操作。 开发数据库系统，用于存储用户信息、活动数据等内容。 前端小程序开发 根据原型图编写前端页面代码，使用各小程序平台提供的组件和API进行功能开发。 实现用户认证、活动详情展示、报名表单提交、状态更新等功能。 测试与优化 单元测试：对各个功能模块进行独立测试，确保逻辑正确无误。 集成测试：模拟真实场景，测试整个应用的完整流程是否顺畅。 性能测试：检查在大量并发请求下系统的响应速度和稳定性。 用户体验测试：邀请部分目标用户试用，并根据反馈进行迭代优化。 上线部署与版本管理 将完成开发和测试的小程序上传至对应平台进行审核发布。 制定版本更新策略，持续收集用户反馈，定期更新优化软件。 后期维护与运营 定期检查系统性能，及时修复已知问题和潜在隐患。 对接新的需求，不断丰富和完善产品功能。 进行数据分析，了解用户行为，以数据驱动产品迭代优化。 这份文件是关于2024年全国大学生电子设计竞赛信息科技前沿专题赛（瑞萨杯）的通知。以下是比赛的主要信息和需要注意的事项：\n组织领导：\n竞赛由全国大学生电子设计竞赛组委会组织。 分组委会负责实施、协调和宣传工作。 瑞萨公司提供技术支持和赛前培训。 采用“分区初选+全国决赛”的模式，分为东区、南区、西区和北区。 参赛学校与参赛队：\n报名采用“选拔+邀请”方式。 自动获得全国决赛资格的学校需在规定时间内上报参赛名单。 参赛学生必须是全日制在校本科生。 每支参赛队由3名学生组成，可配备1名指导教师。 命题与竞赛形式：\n主题为“物联网+数字经济”，涉及非图形图像信息处理及测控技术。 初选和决赛作品需基于指定的瑞萨公司硬件平台。 竞赛采用开放式，不限定竞赛场地。 竞赛时间安排：\n竞赛时间为2024年2月26日至7月31日。 报名截止日期为2024年3月15日。 分区初选和全国决赛的具体时间安排详见文件。 竞赛报名：\n报名需提交学校竞赛负责人、参赛学生名单和指导教师信息。 报名表需签字盖章后发送给各区联络员。 不收取报名费。 竞赛培训：\n组委会将联合瑞萨公司开展线上培训。 提供参赛学生在线交流论坛。 瑞萨开发套件及相关软件将在指定时间发放。 中期检查：\n组委会将在2024年6月中上旬进行中期检查和巡视。 竞赛评审：\n分区初选和全国决赛的评审工作由专家组完成。 评审要求包括作品简介、中英文设计报告和实物作品。 评审时间安排和具体要求详见文件。 评奖与颁奖：\n各区评审组评选一、二、三等奖。 全国评审专家组评选全国一、二、三等奖。 颁奖大会在评审结束后举行。 联系方式：\n提供了竞赛组委会秘书处、专题赛报名联络员以及各区联络员的联系方式。 注意事项：\n确保参赛学生符合资格，且在竞赛期间保持在校状态。 按时完成报名和提交作品。 遵循评审要求，包括作品的提交格式和内容。 确保参赛作品的原创性，避免抄袭。 关注官方通知，以获取最新的培训、评审和颁奖信息。 妥善保管瑞萨开发套件，如有质量问题及时联系瑞萨公司更换。 附件 ",
    "description": "",
    "tags": [
      "软件",
      "微信"
    ],
    "title": "志愿活动软件设计与开发",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%B4%BA%E9%9D%92%E5%B7%A5%E7%A8%8B/%E5%B0%8F%E7%A8%8B%E5%BA%8Fui%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 12.实战项目 \u003e 贺青工程",
    "content": "页面美化验收 1.登录页面 2.首页—将志愿活动和活动时长数据放到轮播图下面 3.我的页面优化了吗？ 4.点击找回密码后，页面颜色不够美观，该页面应符合小程序主色调 5.首页—-为你推荐的志愿活动适当放大活动名称字体，调整活动名称下面的显示信息，请适当调整字体大小、行距、间距。 6.贺院学子一直在行动调整这个模块数字、志愿活动、志愿者等字段的字体大小，现在看起来感觉数字和文字很随意，请适当调整。 7.让“无权限”字段直接显示在页面上，字体背景设置为透明，而不是像现在这样看起来像一个按键。 8.我的组织页面中，显示的组织之间间距太近，请适当调整。 小程序功能验收 1.不同的登录方式有问题吗？ 2.签到开始时间为活动开始前半小时，（现在是没到签到时间不可以签到，精确度很高） 3.活动结束后不能进行签退，但是活动发起者可以对其进行补签，补签时长可以自定，自定义时长不能超过该志愿者从开始签到至活动结束的时长。 4.服务时长为签到签退时间差吗？ 5.签到签退需要在活动地点三公里以内才能进行。 6.活动发起者发布活动后或得四位数数字密码，该密码在志愿者点击签到或签退时弹出小弹窗，输入密码后实现签到签退。 7.当成员加入活动时，活动发起者能够一键通过成员的审核 8.发现页面上方，将日期和距离归纳在一个板块“排序” 9.当我登录后点击返回，返回到的页面是上一次的登录页面，需要一步一步返回，请设置为登陆成功后直接跳转到我的页面。 10. 11. 今晚检查有三，目前都没问题，如下：\n签到签退， 上传、查看、删除pdf和图片， 部分页面正常显示， 一些小问题 ：\n后台修改开始时间和截止时间后，虽然能正常显示，但修改后不起效果，假设报名时间为12：00，过了12点整后修改为13：00，那么活动还是无法参与。\n组织详情页不显示所写简介 参与人次之前说是等于组织活动参与人数之和，但是我这边看了好像与组织成员相等，并不是活动人数之和，而是总的组织成员人数，你们那边也看看吧。\n附件 ",
    "description": "",
    "tags": [
      "软件",
      "微信"
    ],
    "title": "验收问题",
    "uri": "/branch-bundle-1/12.%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%B4%BA%E9%9D%92%E5%B7%A5%E7%A8%8B/%E9%AA%8C%E6%94%B6%E6%96%B9%E6%A1%88/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: F1-复习资料",
    "uri": "/categories/f1-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 9.操作系统",
    "content": "认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般压缩解压文件： ​ 命令 gzip [文件名]\rgunzip [解压文件名] 例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# gzip hello.txt\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.gz\r[root@localhost stdio]# gunzip hello.txt.gz [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# 如果不想删除源文件要怎么做呢？使用如下命令： ​ 命令 gzip -c [文件名] \u003e [压缩文件名.gz]\rzcat [解压文件名.gz] \u003e[压缩文件名.gz] 例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# gzip -c hello.txt \u003ehello.txt.gz\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.gz\r[root@localhost stdio]# zcat hello.txt.gz \u003ehe.txt\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.gz he.txt\r[root@localhost stdio]# 在上面的命令中，zcat [解压文件名.gz] \u003e[压缩文件名.gz] 与 gunzip -c [解压文件名.gz] \u003e[压缩文件名.gz] 作用一样，另外，zcat [文件名]会将文件压缩信息输出在窗口上，即输出在 std。\nbzip2压缩文件和bunzip2压缩文件命令 一般压缩解压文件： ​ 命令 bzip2 [文件名]\rbunzip2 [解压文件名]\r//压缩解压后不会删除原文件\rbzip2 -k [文件名]\rbunzip2 -k [解压文件名] 例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# bzip2 hello.txt [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.bz2\r[root@localhost stdio]# bunzip2 hello.txt.bz2 [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# bzip2 -k hello.txt [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.bz2\r[root@localhost stdio]# rm hello.txt\rrm：是否删除普通文件 \"hello.txt\"？y\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.bz2\r[root@localhost stdio]# bunzip2 -k hello.txt.bz2\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.bz2\r[root@localhost stdio]# tar归档文件命令 ​ 命令 在Linux系统中，tar 是一个非常重要的归档工具，用于将一组文件和目录打包到一个单一的.tar文件中。它创建的这种归档文件并不进行压缩，仅仅是将多个文件集合在一起，并保持原始文件的权限、所有权和其他元数据信息。\ntar -cvf [文件名]\rtar -xvf [解压文件名]然而，为了减少存储空间占用以及在网络上传输时加快速度，通常会结合使用 tar 和压缩工具（如gzip或bzip2）对归档文件进行压缩。这里 -z 或 -j 参数的作用就是启用压缩功能\ntar -czvf [文件名]\rtar -xzvf [解压文件名]\rtar -cjvf [文件名]\rtar -xjvf [解压文件名]如果要选择性的归档或压缩、解压某个文件或目录，那么需要加 w，如下：\ntar -cwzvf [文件名]\rtar -xwzvf [解压文件名]\rtar -cwjvf [文件名]\rtar -xwjvf [解压文件名] 在命令中;\nc（create）：表示创建新备份 z（gzip或gunzip）:表示使用gzip指令处理文件 v（verbose）：显示指令执行过程 f（file）:指定备份文件 w(interactive):对每一步都进行确认 j:表示使用bzip2、bunzip2指令进行压缩解压 如果加选项 -C （directory），则说明转到指定的目录，命令如下：\n[root@localhost ~]# tar -cjvf stdio.tar stdio/\rstdio/\rstdio/1.c\r[root@localhost ~]# tar -xjvf stdio.tar -C st/\rstdio/\rstdio/1.c\r[root@localhost ~]# cd st/\r[root@localhost st]# ls\rstdio\r[root@localhost st]# ls stdio/\r1.c\r[root@localhost st]# 用户与用户组管理 用户与组文件 用户文件-passwd 存放用户登录用户信息的文件位置：/etc/passwd 文件中域的的格式：\nusername:passwd:uid:gid:userinfo:home:shell:\n例子：\n[root@localhost st]# tail -1 /etc/passwd daliu:x:1008:1006::/home/daliu:/bin/bash\n/etc/passwdw 文件中域的含义\n域 含义 username 用户名 password 登录密码（一般显示的是密码转换后的乱码） uid 用户ID（0-99一般为系统保留） gid 用户组ID userinfo 用户信息 home 分配该用户的主目录（但位置是人为决定的，自己可以修改） shell 登录后启动的shell 一般root用户的UID为0，UID一般是唯一的为的是区分不同的用户，但UID为0的除外，UID为0则说明为超级用户；\n创建用户时，系统会分配一个主目录给用户一般在 home 目录下，例如用户user主目录为 /home/user。\n用户文件-shadow Linux系统中的/etc/shadow文件是存放用户密码信息的重要安全文件，也称为“影子口令文件”。它的主要作用是存储用户的加密密码以及与密码相关的属性，以增强系统的安全性。\n在早期的Unix/Linux系统中，密码是以明文或简单加密的形式存储在/etc/passwd文件中。为了提高系统的安全性，从1970年代末期开始引入了影子口令的概念，将密码字段从/etc/passwd移出，并存放在只有超级用户（root）可以读取的/etc/shadow文件中，而原来的 /etc/passwd 中的密码字段显示 x ,这就是上面的例子中显示x的原因。\n通过这种方式，即使攻击者获取了/etc/shadow文件，由于密码已经被高度加密，直接破解难度大大增加，从而有效提高了系统的密码安全级别。同时，通过对密码策略的设定，还可以实现对用户密码复杂度和有效期的管理。\n域 含义 username password min max warm inactive expire flag 下面就举个例子：\n[root@localhost st]# tail -1 /etc/passwd daliu:x:1008:1006::/home/daliu:/bin/bash\n[root@localhost st]# tail -1 /etc/shadow daliu:$6$f703Izgm$gIA74I6Vyqdjstz3BazhvEUVWfSyelNuv7UKTUtB3cScauSctebqrBIr/KShHnBcWWQideao3aucMrXsO.I6Z/:19694:0:99999:7:::\n用户组文件-group 用户组一方面是为了查找用户时更方便，比如查找user用户，你不需要去passwd文件一行一行的查找，你只需要去group文件找到对应的用户组即可。\n同样的，用户组也有类似passwd、shadow之和这样的文件，分别为group、gshadow.\n/etc/group 文件中域的含义如下：\n域 含义 group_name 组用户名 group_password 加密后的用户组口令 group_id 用户组ID group_members 以逗号隔开的用户清单 /etc/gshadow 文件中域的含义如下：\n域 含义 group_name 组用户名 group_password 加密后的用户组口令 group_members 以逗号隔开的用户清单 检验用户与用户组文件之间是否正确 检验 /etc/passwd 与 /etc/shadow 文件之间的正确性，使用命令 pwck,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改； 检验 /etc/group 与 /etc/gshadow 文件之间的正确性，使用命令 grpck,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改。 相关的命令操作 1.添加用户与用户组———— useradd \u0026 groupadd\n用法：\nuseradd [选项] 登录 useradd -D useradd -D [选项] 值得注意的是，对于选项的-d、-md，加了m表示在/home目录创建用户目录，如果不加，表示该目录已存在不需要再使用m,详细请结合下面的展开内容来开。 展开 选项：\r-b, --base-dir BASE_DIR\t新账户的主目录的基目录\r-c, --comment COMMENT 新账户的 GECOS 字段\r-d, --home-dir HOME_DIR 新账户的主目录\r-D, --defaults\t显示或更改默认的 useradd 配置\r-e, --expiredate EXPIRE_DATE 新账户的过期日期\r-f, --inactive INACTIVE 新账户的密码不活动期\r-g, --gid GROUP\t新账户主组的名称或 ID\r-G, --groups GROUPS\t新账户的附加组列表\r-h, --help 显示此帮助信息并推出\r-k, --skel SKEL_DIR\t使用此目录作为骨架目录\r-K, --key KEY=VALUE 不使用 /etc/login.defs 中的默认值\r-l, --no-log-init\t不要将此用户添加到最近登录和登录失败数据库\r-m, --create-home\t创建用户的主目录\r-M, --no-create-home\t不创建用户的主目录\r-N, --no-user-group\t不创建同名的组\r-o, --non-unique\t允许使用重复的 UID 创建用户\r-p, --password PASSWORD\t加密后的新账户密码\r-r, --system 创建一个系统账户\r-R, --root CHROOT_DIR chroot 到的目录\r-s, --shell SHELL\t新账户的登录 shell\r-u, --uid UID\t新账户的用户 ID\r-U, --user-group\t创建与用户同名的组\r-Z, --selinux-user SEUSER\t为 SELinux 用户映射使用指定 SEUSER\r用法： groupadd [选项] [组名] ，一般会用到的选项有\n-g: 用户设置组ID； -o: 与-g配合使用，设置不唯一的组ID; -n: 修改组的名字，如：gpasswd -n [新组名] [旧组名] 2.删除用户与用户组———— userdel \u0026 groupdel\nuserdel:一般用法就是在后面加要删除的用户，如果加选项-r则会删除主目录文件； groupdel：在后面加要删除的用户组 3.修改用户与用户组———— usermod 、passwd \u0026 gpasswd\nusermod： 一般就是对问文件中的域进行修改，会加加上选项-u、-g、-s等，最后还得指定用户，用法： usermod [选项] [用户名]。另外，-L（-U） 的作用是对用户的锁定（解锁）； passwd：一般就是用来修改用户的密码，在登录的是root用户情况下passwd是要指定修改密码的用户的，而如果登录的是用户本身，使用passwd时就不用指定在； gpasswd： 用法： gpasswd [选项] [组名] ，一般会用到的选项有 -a(添加组的用户)， -d(删除组里的用户)，gpasswd -d [用户名] [组名] -A(添加组的管理员). -g(修改组GID),例如：gpasswd -g [新ID] [组名] 对于usermod的进一步说明，除了上面提到的选项，还有如下选项：\n展开 选项：\r-c, --comment 注释 GECOS 字段的新值\r-d, --home HOME_DIR 用户的新主目录\r-e, --expiredate EXPIRE_DATE 设定帐户过期的日期为 EXPIRE_DATE\r-f, --inactive INACTIVE 过期 INACTIVE 天数后，设定密码为失效状态\r-g, --gid GROUP 强制使用 GROUP 为新主组\r-G, --groups GROUPS 新的附加组列表 GROUPS\r-a, --append GROUP 将用户追加至上边 -G 中提到的附加组中，\r并不从其它组中删除此用户\r-h, --help 显示此帮助信息并推出\r-l, --login LOGIN 新的登录名称\r-L, --lock 锁定用户帐号\r-m, --move-home 将家目录内容移至新位置 (仅于 -d 一起使用)\r-o, --non-unique 允许使用重复的(非唯一的) UID\r-p, --password PASSWORD 将加密过的密码 (PASSWORD) 设为新密码\r-R, --root CHROOT_DIR chroot 到的目录\r-s, --shell SHELL 该用户帐号的新登录 shell\r-u, --uid UID 用户帐号的新 UID\r-U, --unlock 解锁用户帐号\r-Z, --selinux-user SEUSER 用户账户的新 SELinux 用户映射 3.登录用户与用户组———— su newgrp\nroot用户与普通用户之间的切换使用su,如果要切换根目录则需要在su 后加-，即： su - [用户]。\n在Linux中，组的登录使用 newgrp ，即 newgrp [组名]。\n下面通过一个例子加以理解：\n添加一个用户名为15user，且该用户在用户组15group中，设置用户组和用户密码为123，创建一个用户15user2让该用户为用户组管理员,修改user的UID为2024，最后删除所用所建信息。\n展开 [root@localhost ~]# groupadd 15group\r[root@localhost ~]# useradd -g 15group 15user\r[root@localhost ~]# tail -1 /etc/passwd\r15user:x:1001:1007::/home/15user:/bin/bash\r[root@localhost ~]# tail -1 /etc/group\r15group:x:1007:\r[root@localhost ~]# gpasswd 15group\r正在修改 15group 组的密码\r新密码：\r请重新输入新密码：\r[root@localhost ~]# passwd 15user\r更改用户 15user 的密码 。\r新的 密码：\r无效的密码： 密码少于 8 个字符\r重新输入新的 密码：\rpasswd：所有的身份验证令牌已经成功更新。\r[root@localhost ~]# useradd 15user2\r[root@localhost ~]# gpasswd -A 15user2 15group\r[root@localhost ~]# tail -2 /etc/group\r15group:x:1007:\r15user2:x:1002:\r[root@localhost ~]# tail -2 /etc/gshadow\r15group:$6$d4pzl/CPrp$3NYvX8gzE3DBm35BLqAE8aGzfUhrUZTSMGQfeRve2iUhrH1tZGR8I8t91gWzFD2GWFEDaaocO7XO85RjKDY.q1:15user2:\r15user2:!::\r[root@localhost ~]# usermod -u 2024 15user\r[root@localhost ~]# tail -2 /etc/passwd\r15user:x:2024:1007::/home/15user:/bin/bash\r15user2:x:1002:1002::/home/15user2:/bin/bash\r[root@localhost ~]# userdel 15user\r[root@localhost ~]# groupdel 15group\r[root@localhost ~]# userdel 15user2 在上面的例子中，我们使用gpasswd -A来设置用户组管理员。\n文件目录和目录权限管理 文件访问权限与用户分类 文件的访问权限 读(r)：允许读文件的内容 写(w)：允许向文件中写入数据 执行(x)：允许将文件作为程序执行 目录的访问权限 读(r)：允许查看目录中有哪些文件和目录； 写(w)：允许该在目录下创建（或删除）文件、目录，修改文件名字或者目录名字 执行(x)：允许访问目录(用 cd 命令进入该目录，并查看目录中可读文件的内容) 用户分类 文件所有者（owner）：建立文件、目录的用户。 同组用户(group)：属于同一组群的用户对属于该组群的文件有相同的访问权限。 其他用户(other)：除了文件所有者、同组用户的其他用户。 我们先用ls -l 查看文件的权限信息：\n在上面的开头有三段他们分别表示为文件所有者、同组用户、其他用户：\n其中的d表示目录。\n权限修改 访问权限的表示 （1）字母表示法（如：rwxr-xr-x） （2）数字表示法 （如：755） 使用数字进行文件权限的划分，其中r=4、w=2、x=1、-=0，这样rwx这组权限就是4+2+1=7，r-x这组权限就是5。\n修改权限的命令：chmod 命令格式1： chmod $n{_1}n{_2}n{_3}$ \u003c文件|目录\u003e 功能：为指定文件或目录修改给定的数值访问权限。 选项： $n{_1}n{_2}n{_3}$三位数字表示的文件访问权限。 命令格式2： chmod [用户标识] [设定方法] [权限字符] \u003c文件名或目录名〉 功能：修改文件或目录的访问权限。 选项： （1）用户标识：所有者（u）、同组（g）、其他人（o）、所有的人员（a） （2）设定方法：+ 增加权限、- 删除权限、= 分配权限，同时删除旧的权限 （3）权限字符：r（读）、w（写）、x（执行）、u（和所有者的权限相同）、g（和所同组用户的权限相同）、o（和其他用户的权限相同） 修改文件所有者的命令：chown 格式：chown [-R] \u003c用户[：组]\u003e \u003c文件或目录\u003e 功能：更改属主和组。 选项： -R：对目录及其子目录进行递归设置。 例如：chown sjh：sjh result.txt\n修改文件所属组群的命令：chgrp 格式：chgrp group file\n其中group：组名或组代号\n功能： 改变文件或目录组群\n例如：chgrp user result.txt\n关于chown与chgrp的命令的例子：\n展开 [root@localhost ~]# chown user2:user2 /tmp/test/user1_2.txt\r[root@localhost ~]# ls -l /tmp/test/\r总用量 0\r-rw-rw-r--. 1 user2 user2 0 1月 15 19:40 user1_2.txt\r[root@localhost ~]# chgrp root /tmp/test/user1_2.txt\r[root@localhost ~]# ls -l /tmp/test/\r总用量 0\r-rw-rw-r--. 1 user2 root 0 1月 15 19:40 user1_2.txt\r[root@localhost ~]# 修改默认权限的命令：umask 格式：umask [mask]\n功能：设置文件或目录的默认权限\n注意：系统默认屏蔽的权限为022（umask的默认值为0022），因此新 创建的目录权限就为777-022=755，用字符表示就是rwxr-xr-x，新创 建的普通文件权限为666-022=644，即rw–r–r–。\n文件隐藏属性 1）查看文件隐藏属性：lsattr\n2）修改文件隐藏属性：chattr\nchattr [+-=] [ ai] 文件或目录名称\na: 当设置a之后，这个文件将只能增加数据，而不能删除也不能修改数据， 必须要为root才能设置这个属性。 i：不能删除，不能修改，不能改名。必须要为root才能设置这个属性。 文件特殊权限 文件特殊权限有以下三种：\n1）SUID：Set UID（只对二进制程序有效，对shell script无效）\n例如：ll /usr/bin/passwd\n注意：当用户执行passwd命令的时候，需要修改/etc/shadow文件，而该文件普通用户并没有任何权限。\n2）SGID：Set GID\n例如：ll /usr/bin/locate 注意：当用户执行locate命令的时候，需要读取/var/lib/mlocate/mlocate.db文件。\n3）SBIT：Sticky Bit （只对目录有效）\n设置方法：\nchmod -o+t [指定目录名]\r或者\rchmod 1777 [指定目录名]对一个目录进行如上设置以后，假设有用户A和B，用户A在该目录下创建的文件只有他自己的root用户可以删，像B这样的其他用户删不了。\n特殊文件说明文章链接\n软件包管理 接下里介绍两个软件安装的工具，分别是RPM：Red Hat Package Manager（Red Hat软件包管，以及YUM:Yellow dog Dpdater,Modified.\nRPM工具不需要网络，需要提前准备好安装包，但是他也有缺点安装的时候如果缺少依赖包你还需要再安装依赖包；\n而YUM工具需要再有网的状态下才可以下载，它免去了依赖包提醒，自动将依赖包下载好，较为方便，我跟推荐使用YUM。\nRPM工具的使用 1．安装软件包（install）\nrpm -ivh rpm软件包全名：\ni：安装一个新的软件包 v：显示详细信息 h：显示安装进度条理工具 2．查询已安装的软件包（query）\nrpm –qa //查询出本机所有已经安装的软件\rrpm –q httpd //查询httpd软件包是否已经安装\rrpm -q【i l c d R】 vsftpd\rrpm -qf /etc/inittab\r查询未安装的软件包：\rrpm -qp 【i l c d R】 gconf-editor-2.28.0-3.el6.i686.rpm3．升级与更新（upgrade/freshen）\nrpm -Uvh 软件包名称\r//原来没有安装过的，直接安装；如果已安装过，则更新至新版\rrpm -Fvh 软件包名称\r//原来没有安装过的，不安装；如果已安装过，则更新至新版4．卸载RPM包（erase）\nrpm -e vsftpd\r注意：卸载时只需要给出软件包名称vsftpd，而不需要给出软件包的全部名称信息vsftpd-2.2.2-6.el6.i686.rpm。YUM工具的使用 yum在线升级机制：\n安装软件 yum install gcc 删除软件 yum remove gcc 查询软件 yum search gcc 软件包管理：\n举例一：搜寻与磁盘阵列(raid)相关的软件有哪些？ [root@www ~]# yum search raid 举例二：找出mdadm这个软件的功能为何？ [root@www ~]# yum info mdadm 举例三：列出yum 服务器上面提供的所有软件名称。 [root@www ~]# yum list 举例四：列出目前服务器上可供本机进行升级的软件有哪些？ [root@www ~]# yum list updates 举例五：列出提供passwd这个文件的软件有哪些？ [root@www ~]# yum provides passwd yum的软件组功能：\n查询软件组：yum grouplist（查阅目前容器与本机上面的可用与安装过 的软件群组有哪些？） yum groupinfo Eclipse（查询Eclipse软件组的相关信息）\n安装软件组： yum groupinstall Eclipse 删除软件组： yum groupremove Eclipse 硬盘分区及格式化 硬盘分区介绍 硬盘的分区分为主磁盘分区和扩展磁盘分区。 一个硬盘最多可以划分为 4 个主磁盘分区，这时不能再创建扩展分区。 一个硬盘中最多只能创建 1个扩展分区 ，扩展分区不能直接使用，必须在扩展分区中再划分出逻辑分区才可以使用。 逻辑分区是从5开始的，每多1个分区，数字加1就可以。 硬盘标识 （1）IDE硬盘：hd[a-d]*\nhd表示硬盘类型为IDE，中括号中的字母为a、b、c、d中的一个，a是基本盘，b是从盘，是辅助主盘，d是辅助从盘，*指分区，即主分区和扩展分区。\n例如：hda1代表第一块IDE硬盘上的第一个分区。hdb5代表第二块IDE硬盘的第一个逻辑分区。\n（2）SCSI/SATA硬盘：sd[a-p]*\nsd表示SCSI/SATA硬盘。SCSI/SATA的引导盘使用设备文件/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda4作为主分区或者扩展分区，而以/dev/sda5，/dev/sda6等作为逻辑分区。\n创建硬盘分区 先使用ls -l /dev |grep ‘sd’查看文件里是否有可用的磁盘，如果没有需要创建一个磁盘，创建步骤：\n1．通过虚拟机设置增加一块SCSI硬盘，大小为5G，重启系统。 展开 按照下图点击下一步\n根据实际情况输入所需硬盘大小，这里输入5GB\n然后点击完成\n最后在命令窗口输入reboot重启。\n2．将该硬盘分为2个主分区（每个主分区的大小为1G），1个扩展分区（大小为3G），将第2个主分区制作成swap分区。\n命令： 展开 //先用命令查看sd,sd表示SCSI/SATA硬盘， ls /dev/sd |grep sd //硬盘分区 fdisk /dev/sdb //使用m查看帮助命令，n为新建命令，d为删除命令，w为写入命令，每次配完都要写入才有效。 n p //这是新建主分区的意思 //接着指定分区起始位置，一般我们默认，所以回车就可以 //然后就是指定分区的大小，这里我设置1G、 +1G //可以用p命令查看设置的情况 P //按照上面的流程进行其他的设置，一下给出步骤命令 n p +1G n e +3G 3．将扩展分区划出2个逻辑分区（大小分别为1G、2G）。\n命令： 展开 //到这步后我们可以给扩展分区分配逻辑分区，分配时逻辑分区用l命令。 n l +1G n l +2G 查看磁盘情况与磁盘格式化 （1）查看系统中的新硬盘：ls /dev/sd* （2）查看分区：fdisk –l /dev/sda （3）创建主分区：fdisk /dev/sdc （4）创建扩展分区：输入n,再输入e （5）创建逻辑分区: 输入n,再输入l （6）修改分区类型 （7）格式化分区： mkfs –t ext4 /dev/sdc1 还可以写成**mkfs.ext4 /dev/sdc1** 格式化交换分区略有不同，使用命令 mkswap ,例如： mkswap dev/sdb2 （8）磁盘检查命令：fsck –t ext4 /dev/sdc1 badblocks /dev/sdb5 （9）查看磁盘使用情况 df,或使用df -h输出更易于查看。 上面的-t意思是参数TYPE的意思，后面接ext4()、vfat(FAT32)、ntfs()等，\n挂载文件系统：mount 1、 挂载硬盘分区： 步骤1：mkdir /usr/music 步骤2：mount /dev/sdc5 /usr/music 2、 挂载光驱： 步骤1：mkdir /mnt/cdrom 步骤2：mount /dev/cdrom /mnt/cdrom 3、 挂载U盘： 步骤1：mkdir /mnt/usb 步骤2：mount /dev/sdd1 /mnt/usb 4、 挂载Windows下的C盘 （FAT32格式）： 步骤1：mkdir /mnt/dosc 步骤2：mount -t vfat /dev/sda1 /mnt/dos 注意： C盘必须已经被格式化为FAT32格式。\n显示系统内所有已经挂载的文件系统 mount 不带任何参数执行mount命令，则会显示当前系统中已经挂载的所有的文件系统列表。\n卸载设备：umount 格式： umount \u003c设备名或挂载点\u003e\n说明：卸载指定的设备，既可以使用设备名也可以使用挂载点。\n举例： # umount /dev/cdrom\n自动挂载文件系统：/etc/fstab 每条记录由6个字段组成。\n1.设备名称 2.设备挂载点 3.文件系统类型 4.挂载选项 5.是否备份 6.自检顺序\n如果想要系统自动挂载/dev/sdc5分区，可在/etc/fstab文件添加下面这行：\n/dev/sdc5 /usr/music ext4 defaults 0 0\n注意:由于fstab文件非常重要，如果这个文件有错误，就可能会造成系统不能正常启动。因此向fstab文件中添加数据时应非常小心。修改完该文件后务必使用mount -a命令测试有没有错误。\n磁盘配额 以sdb1为例\n第一步：先配置sdb磁盘，然后挂载sdb1磁盘\n第二步：使用quotaon /sdb1/生成aquota.group和aquota.user文件\n第三步：对用户或用户组进行磁盘限制,例如：edquota -u user1，然后会进入一个文件，文件里的0表示禁用，在里面可以设置创建文件个数或文件大小的软限制、硬限制；\n第四步：我们登录user1，在/sdb/目录下创建文件，使用 db if=/dev/zero of=/sdb1/test/ bs=1k count=10这条命令进行测试，这是一个写文件大小的命令，这样可以快速测试文件大小的软限制和硬限制；\n第五步：子里面建文件，检验创建文件个数的软限制和硬限制；\n第六步: 可以使用repquota -u查看目录的情况；\n第七步：关闭磁盘匹配额，quotatoff /sdb1/\nLinux编程 附件 ",
    "description": "",
    "tags": [
      "软硬件"
    ],
    "title": "Linux期末复习",
    "uri": "/branch-bundle-1/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 软硬件",
    "uri": "/tags/%E8%BD%AF%E7%A1%AC%E4%BB%B6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 2.AndroidStudio",
    "content": "AndroidStudio简介 1.配置Android开发环境：\n安装JDK： （1）下载JDK （2）配置环境变量； 安装Android Studio； 安装SDK。 2.自动构建工具Gradle：\nGradle 是以 Groovy 语言为基础，面向Java应用为主，基于DSL（领域特定语言）语法的自动化构建工具。它可以自动化地进行软件构建、测试、发布、部署、软件打包，同时也可以完成项目相关功能，如生成静态网站、生成文档等。另外其集合了Ant的灵活性和强大功能，以及Maven的依赖管理和约定，从而创造了一个更有效的构建方式。凭借Groovy的DSL和创新打包方式，Gradle提供了一个可声明的方式，并在合理默认值的基础上描述所有类型的构建。Gradle目前已被选作许多开源项目的构建系统。\n3.Logcat日志输出工具：使用 Logcat 查看日志\nAndroid Studio 中的 Logcat 窗口会实时显示设备日志来帮助您调试应用，例如，使用 Log 类添加到应用的消息、在 Android 上运行的服务发出的消息或系统消息（例如在发生垃圾回收时）。如果应用抛出异常，Logcat 会显示一条消息，后跟相关联的堆栈轨迹，其中包含指向代码行的链接。\n4.Android Studio中 Make Project 、Clean Project 、Rebuild Project 的作用\nMake Project：编译Project下所有Module（组件或模块），一般是自上次编译后Project下有更新的文件，增量编译，不生成Apk。 Clean Project：删除之前编译后的编译文件。部分版本的AS会自动重新编译整个Project，不生成Apk。 Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成Apk 5.Run窗口：可以输出程序运行过程中出现的错误。 6.manifests文件夹（清单文件夹）：Android系统配置文件夹，包含一个AndroidManifest.xml文件（清单文件），可在此文件注册声明\n\u003cactivity\u003e页面、 \u003cservice\u003e服务、 \u003creceiver\u003e接收器、 \u003cprovider\u003e提供者或提供程序、 \u003cuses-permission\u003e使用权限等； 7.java文件夹：存放Java代码的文件夹，新建项目时默认生成了三个文件夹，com.first.project文件夹用来存放Java文件，这里包含一个名为MainActivity的Java文件，是新建项目时默认生成的。 第二个和第三个文件为测试代码文件夹，不是十分常用。\nres文件夹：存放Android项目的资源文件，包含四个文件夹： drawable（图片资源文件夹）、 layout（布局资源文件夹）、 mipmap（图片资源文件夹，存放项目图标）、 values（存放数值资源文件）， 此外有menu文件（菜单资源文件）。 8.Android系统体系结构四层，从上到下分别是\n应用程序层 应用程序框架层 系统运行库层 Linux内核层 每一层都是用其下面各层所提供的服务。 应用程序层\nAndroid平台包含了许多核心的应用程序，诸如Email客户端、SMS短消息程序、日历、地图、浏览器、联系人等应用程序。这些应用程序都是用Java语言编写的。开发人员可以灵活地根据需求替换这些自带的应用程序或者开发新的应用程序。\n应用程序框架\n开发者可以完全访问核心应用程序所使用的API框架。该层简化了组件的复用，使得开发人员可以直接使用系统提供的组件来进行快速地开发，也可以通过继承灵活地加以拓展。这些东西包括：\n活动管理器（Activity Manager，管理各个应用程序的生命周期以及通常的导航回退功能） 视图系统（View System，构建应用程序的基本组件） 内容提供器（ContentProvider，使得不同的应用程序之间可以存取或者分享数据） 资源管理器（Resource Manager，提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件等） 通知管理器（Notification Manager，使应用程序可以在状态栏中显示自定义的提示信息）等。\n系统运行库层\n包括系统库和Android Runtime，系统库是应用程序框架的支撑，是连接应用程序框架层与Linux内核层的重要纽带。程序在Android Runtime中执行，其运行时分为核心库和Dalvik虚拟机两部分。\nLinux内核层\nAndroid基于Linux2.6的内核，其核心系统服务如安全性、内存管理、进程管理、网络协议以及驱动模型都依赖于Linux内核，同时内核层也扮演了介于硬件层和软件栈之间的抽象层的角色。 Linux内核层和系统运行库层之间，从Linux操作系统的角度来看，是内核空间与用户空间的分界线，Linux层运行于内核空间，以上各层运行于用户空间。系统运行库层和应用框架层之间是本地代码层和Java代码层的接口。应用框架层和应用程序层是Android的系统API的接口，对于Android应用程序的开发，应用程序框架层以下的内容是不可见的，仅考虑系统API即可。\n9.四大核心组件有：activity（活动或页面）、service（服务）、broadcast receiver（广播接收器）、content provider（内容提供者）\n10.Activity介绍Android系统是通过任务栈来管理Activity的。当一个Activity启动时，会把Activity压入到堆栈中，当用户按返回键或者结束掉该Activity时，它会从堆栈中弹出。\n11.Android为我们定义了四种加载方式\nStandard 加载模式 ——标准模式/默认加载模式\n标准模式：系统默认的Activity启动模式，当Intent欲打开Activity时，在该Activity不存在，存在于栈顶和存在于栈底三种情况下都会正常创建Activity，并压入任务栈栈顶；\nSingleTop 加载模式 ——栈顶单例模式\n栈顶单例模式：当启动一个Activity时，只有当该activity存在任务栈中且为栈顶，Intent才会通过onNewIntent()方法传递给在栈顶Activity实例；其他情况则正常创建Activity并压入任务栈；\nSingleTask 加载模式 ——栈内单例模式\n站内单例模式：当启动一个Activity时，系统会先检查任务栈内是否有该Activity，如果该Activity不存在则正常创建Activity实例，如果存在且在栈底则会将它上面的Activity弹出并销毁，使该Activity置于栈顶再调用onNewIntent()方法；\nSingleInstence 加载模式 ——全局单例模式\n与SingleTask模式基本一样，只是在这个模式下Activity所处的任务栈中只能有Activity这一个实例，不能有其他的实例。\n12.Activity生命周期是指Activity从创建到销毁的过程，在这一过程中，Activity一般处于4种状态，即：Active/Running、Paused、Stop、Killed\n（1）Active/Running 此时Activity一定处于屏幕的最前端，用户完全可以看得到，并且可以与用户进行交互。对于Activity栈来说，它处于栈顶； （2）Paused 此时Activity在屏幕上仍然可见，但是它已经失去了焦点，用户不能与之进行交互。暂停状态的Activity是存活的，它仍然维持着其内部状态和信息，但是系统可能会在手机内存极低的情况下杀掉该Activity； （3）Stop 此时Activity在屏幕上完全不能被用户看见，也就是说这个Activity已经完全被其他Activity所遮住。处于停止状态的Activity，系统仍然保留有其内部状态和成员信息，但是它经常会由于手机系统内存被征用而被系统杀死回收； （4）Killed Activity被系统杀死回收或者未启动。\n13.为了能够让Android程序了解自身状态的变化，Android系统中具有很多事件回调函数，我们可以重载这些方法来实现自己的操作。Android生命周期的事件回调函数如下：\nvoid onCreate(Bundle savedInstanceState) void onStart() void onRestart() void onResume() void onPause() void onStop() void onDestroy()14.Activity生命周期\n15.Fragment必须是依存于Activity而存在，因此Activity的生命周期会直接影响到Fragment的生命周期。图在课本第50页。\n由图可以看到Fragment比Activity多了几个额外的生命周期回调函数：\nonAttach(Activity)：当Fragment与Activity发生关联时调用。从该方法开始，就可以通过Fragment.getActivity方法获取与Fragment关联的窗口对象了，但在该方法中仍然无法操作Fragment中的控件。 onCreateView(LayoutInflater, ViewGroup, Bundle)：创建该Fragment的视图。onActivityCreated(Bundle)：当Activity的onCreate方法返回时调用。\nonDestoryView():与onCreateView相对应，当该Fragment的视图被移除时调用。onDetach()：与onAttach相对应，当Fragment与Activity关联被取消时调用。\n16.在使用Intent进行Activity之间的跳转时，我们通常有三种Intent跳转方式，即：不带参数的跳转、带参数的跳转以及带返回值的跳转，代码实现可参考实验报告或书本。\n17.TextView常用的属性\nandroid:id=\"@+id/textView1\"表示该控件的id，在布局文件中或者代码中被引用 android:textStyle=\"bold\"表示TextView里面的字加粗显示 android:layout_height=\"wrap_content\"表示该控件的高度为其包含内容的高度 android:layout_width=\"wrap_content\"表示该控件的宽度为其包含内容的宽度 android:text=\"@string/signin\" 显示的内容，这里表示存放在string.xml文件中name=signin的文本 android:layout_height=\"40dip\"设置具体的高度 android:textColor=\"#7089c0\"设置文本的颜色 android:textSize=\"18sp\"设置文本的大小 android:gravity=\"center_vertical\"设置文本垂直居中 android:paddingLeft=\"5dip\"设置内边距 android:layout_marginTop=\"5dip\"设置外边距18.LinearLayout线性布局、\nRelativeLayout相对布局、 FrameLayout帧布局、 TableLayout表格布局、 AbsoluteLayout绝对布局 线性布局，是指该容器（LinearLayout）内子控件的摆放方式有两种： 第一种：垂直放置（VERTICAL），相对水平放置来讲，垂直放置就相当于一列，放置的控件或者容器只能在该列中的某个位置，两个控件之间只存在上下方向的关系，不存在其他方向上的关系。当这一列放满后，再添加的控件就至于屏幕之外存在，无法看见。 第二种：水平放置（HORIZONTAL），指的是该容器里面存放的控件或者容器只能以一行的形式出现，放置的控件只能是该行中的某个位置，两个控件或者容器之间只有左右关系没有其他方向上的关系，当放置水平方向满屏时不会自动换行，再放置的控件将在屏幕之外存在，无法看见。 在线性布局中重要的属性值对应表示\nandroid:orientation\t//设置控件或者容器存放的方式 android:id\t//设置控件id，方便在使用时找到其引用 android:layout_width\t//容器的宽度，该值必须设置 android:layout_height\t//容器的高度，该值必须设置 android:layout_weight\t//该属性针对其内的子控件，存放在LinearLayout中的控件都有这个属性，用来设置该控件或者容器占父控件或者容器的比例。相对布局，是指利用控件之间的相对位置关系来对布局进行放置。换句话说，在该容器中的控件与其他任何一个控件或者容器（包括父控件）有相对关系。\n帧布局，是指该容器内放置的控件或者容器没有上下左右的关系，只有层叠前后的关系。放置在容器内的控件按放置的前后顺序逐一层叠摆放，自然地后面摆放的控件就将前面摆放的控件覆盖了，叠在它的上面了。对于放置前后的关系，在没有设置其他属性之前，Android系统采用的是叠放的原则，即后加入节点的层叠在上面。设置属性android：bringToFront=“true|false”将前面放置的控件提到最前面可见。\n表格布局，指该容器是一个表格，放置控件时，控件的位置坐落在表格的某个位置上。其中TableRow是配合TableLayout使用的，目的是为了让TableLayout生成多个列，否则TableLayout中就只能存在一列元素，但可以有多行。\nTableLayout的直接父类是LinearLayout，所以其具有LinearLayout的属性，TableLayout中的每一行用TableRow表示，每一列就是TableRow中的个数指定的。TableRow的直接父类是LinearLayout，但是其放置的方式只能水平放置。\n绝对布局，是指以屏幕左上角为坐标原点（0,0），控件在容器中的位置以坐标的形式存在，可以随意指定控件的坐标位置，非常灵活。在开发过程中很少使用，原因是屏幕兼容性不好，不便控制两个控件之间的位置。其中控件或者容器放置的位置通过android:layout_x和android:layout_y这两个属性进行设置。\nConstraintLayout约束布局\n优点：\nConstraintLayout之所以成为目前Android开发中主流的布局，除了官方建议使用ConstraintLayout外还有以下几个方面的优势 1.功能强大，ConstraintLayout几乎能实现其他布局所有的功能 2.能减少布局层次的嵌套，有性能的优势 3.可视化操作的增强，大部分界面用ConstraintLayout都能通过可视化编辑区域完成\n19.对话框（Dialog）是Android系统在Activity或者其他组件运行过程中提供的一种资源消耗很小的提示机制，它可以帮助应用完成一些必要的提示功能，同时还提供一些用户交互的功能，包括简单的提示、等待、选择、展示等功能。操作简单，资源消耗较少。代码实现可参考实验报告或书本\n1提示对话框\npackage com.example.alertdialog; import android.content.DialogInterface; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import java.util.ArrayList; import java.util.HashMap; public class MultipleChoiceDialogBox extends AppCompatActivity { private Button button; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.test); button = findViewById(R.id.dialog_box_up); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(MultipleChoiceDialogBox.this); builder.setTitle(\"这是一个简单的弹窗\"); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(\"你学会了吗？\"); builder.setPositiveButton(\"学会了\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.setNegativeButton(\"不会\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }2单选对话框\npackage com.example.alertdialog; import android.content.DialogInterface; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import java.util.ArrayList; import java.util.HashMap; public class MultipleChoiceDialogBox extends AppCompatActivity { private Button button; private TextView textView; private String sexx[] ={\"男\",\"女\"}; private int choiceWitch = 1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.test); button = findViewById(R.id.dialog_box_up); textView=findViewById(R.id.show_dialog_box_text); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(MultipleChoiceDialogBox.this); builder.setCancelable(false); builder.setSingleChoiceItems(sexx, -1, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { choiceWitch=which; } }); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { textView.setText(sexx[choiceWitch]); } }); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }3多选对话框\npackage com.example.gpc.wzxapplicationwu1; import android.content.DialogInterface; import android.os.Bundle; import android.support.annotation.Nullable; import android.support.v7.app.AlertDialog; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; import java.util.ArrayList; import java.util.HashMap; public class AlertDialogActivity extends AppCompatActivity{ private Button button; private TextView textView; private String sexx[] ={\"a\",\"b\",\"c\",\"d\"}; private boolean stu[] = {false,false,false,false}; private int choiceWitch = 1; private ArrayList\u003cInteger\u003e list = new ArrayList(); private String str = \"\"; private HashMap\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e(); @Override protected void onCreate(@Nullable final Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.alert_dialog); textView = findViewById(R.id.alert_dialog_textview); button = findViewById(R.id.alert_dialog_button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(AlertDialogActivity.this); builder.setMultiChoiceItems(sexx, stu, new DialogInterface.OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i, boolean b) { if(b == true){ map.put(i,i); } else { map.remove(i); } } }); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { for (Integer j : map.keySet()){ int z = map.get(j); str = str + sexx[z]; } textView.setText(str); str = \"\"; } }); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }19.Android系统中的ContextMenu(上下文菜单)类似于PC中的右键弹出菜单，当一个视图注册了上下文菜单时，长按该视图对象将出现一个提供相关功能的浮动菜单。上下文菜单可以被注册到任何视图对象中，最常见的是用于列表视图中，但上下文菜单不支持图标和快捷键。\n选项菜单 当Activity在前台运行时，如果用户按下微信消息列表页面右上角加号键，此时就会在屏幕右上角弹出相应的选项菜单。但这个功能需要开发人员编程来实现，如果在开发应用程序时没有实现该功能，那么程序运行时按下手机的meun键是不会起作用的。\n下拉菜单 严格来讲Spinner不算是一个菜单，但是其操作和表现形式具有菜单的行为。Spinner的有效使用可以提高用户的体验。当用户需要选择的时候，可以提供一个下拉列表将所有可选的项列出来，供用户选择。\n21.Toast（提示）的使用，代码实现可参考实验报告或书本。\nToast.makeText(MultipleChoiceDialogBox.this,“nihao”,Toast.LENGTH_LONG).show();\n22.Notification表示通知，是可以显示在Android系统通知栏上的一种数据的封装形，运用Notification可以提高应用的交互性，带来良好的用户感受。 关于Notification，主要涉及到Notification类与NotificationManager类的使用。 Notification类的实例表示在通知栏显示的一个通知，该通知内容包括该通知的ID、时间、内容、标题、图标等。 NotificationManager实例用来将该通知发送到系统的通知栏上。\n23.本地服务（Local Service）用于应用程序内部，可以实现应用程序自己的一些耗时任务，比如查询升级信息、网络传输，或者在一些场合需要在后台执行，比如播放音乐，并不占用应用程序比如Activity所属的线程，而是单开线程后台执行，这样用户体验比较好。\nService的两种启动方式 (1)通过bindService绑定： 绑定时，bindService -\u003e onCreate() –\u003e onBind()； 解绑定：unbindService –\u003eonUnbind() –\u003e onDestory()； 此时如果调用者（如Activity）直接退出，Service 由于与调用者绑定在一起，则Service随着调用者一同停止。\n（2）通过startService绑定： 启动时，startService –\u003e onCreate() –\u003e onStart()； 停止时，stopService –\u003e onDestroy()； 此时，服务与调用者（如Activity）没有绝对关联，当调用者关闭后服务还会一直在后台运行。 服务的生命周期\n23.在Android里面有各式各样的广播，比如：电池的状态变化、信号的强弱状态、电话的接听和短信的接收等等，本节将会介绍系统发送、监听这些广播的机制。\n两种广播注册方法的区别 第一种不是常驻型广播，也就是说广播跟随程序的生命周期 第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播过来，程序广播接收器也会被系统调用自动运行\n25.作为一个完整的应用程序，数据的存储与操作是必不可少的。Android系统为我们提供了四种数据存储方式，分别是：Shared Preference、SQLite、File和ContentProvider。 SharedPreference：一种常用的数据存储方式，其本质就是基于xml文件存储键值对（key-value）数据，通常用来存储一些简单的配置信息。\nSQLite：一个轻量级的数据库，支持基本SQL语法，是Android系统中常被采用的一种数据存储方式。Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的API。 文件储存：即常说的文件（I/O）存储方法，常用于存储数量比较大的数据，但缺点是更新数据将是一件困难的事情。 ContentProvider：它是Android系统中能实现应用程序之间数据共享的一种存储方式。由于Android系统中，数据基本都是私有的，存放于“data/data/程序包名（package name）”目录下，所以要实现数据共享，正确方式是使用ContentProvider。由于数据通常在各应用间是私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。如果应用程序有数据需要共享时，就需要使用ContentProvider为这些数据定义一个URI（包装成Uri对象），然后其他的应用程序就通过ContentResolver传入这个URI来对数据进行操作。\n26.SharedPreferences对象的常用方法有以下几种：\n27.Sqlite数据库的使用涉及到两个类：SQLiteDataBase和SQLiteOpenHelper\nSQLiteDatabase具体方法：\nSQLiteOpenHelper 具体方法\n例：要得到一个可写数据库，首先创建一个类继承 SQLiteOpenHelper，重写 onCreate()方法并在该方法中创建表，然后使用创建出的 SQLiteOpenHelper 的子类对象的 getWritableDatabase()方法获得一个可读写的数据库对象。\n28.网络状态\n29.JSON数据解析 是一种轻量级的数据交换格式，它基于纯文本，采用完全独立于语言的文本格式来存储和传输数据。在编程环境中解析JSON数据意味着将JSON字符串转换为程序可以理解并操作的数据结构 JSON Object：JSON中对象(Object)以“{”开始, 以“}”结束。对象中的每一个item都是一个键值对，表现为“key:value”的形式, 键值对之间使用逗号分隔。如下代码所示： { “name”：“coolxing”， “age”：24， “male”：true， “address”：{ “street”:“huiLongGuan”， “city”:“beijing”， “country”:“china” } }\nJSONArray: JSON数组(Array)以\"[“开始, 以”]“结束, 数组中的每一个元素可以是String,Number, Boolean, null, Object对象甚至是Array数组, 数组间的元素使用逗号分隔,如下代码所示： [ “coolxing”, 24， { “street”:“huiLongGuan”， “city”:“beijing”， “country”:“china” } ]\n30.Webview WebView 加载页面主要调用三个方法：LoadUrl、LoadData、LoadDataWithBaseURL. LoadUrl 直接加载网页、图片并显示。 LoadData 显示文字与图片内容。(模拟器1.5、1.6)。 LoadDataWithBase 显示文字与图片内容 (支持多个模拟器版本)。 使用webview的websetting来设置，WebSetting websetting = webView.getSettings(). Websetting常用方法：\n31.进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元。 通俗地讲一个进程代表一个应用程序，该应用程序运行在自己的进程当中，使用系统为其分配的堆内存，不受其他应用程序或者是其他进程的影响，是独立运行的。当然一个进程中可以同时运行多个应用程序，这时堆内存是共享的。\nAndroid系统为每个应用程序分配了一个进程，应用程序中组件（Activity，Service，BroadCast）的状态决定的一个进程的“重要性层次”，层次最低的属于旧进程。这个“重要性层次”有五个等级，也就是进程的生命周期，按最高层次到最低层次排列如下： （1）前台进程 （2）可视进程 （3）服务进程 （4）背景进程 （5）空进程\n一个Android应用只能存在一个进程，但是可以存在多个线程，也就是说，当应用启动后，系统分配了内存，这个进程的内存不被其他进程使用，但被进程中一个或多个线程共享。宏观地讲所有的进程是并发执行的，而进程中的多个线程同时执行但并不是并发的，系统的CPU会根据应用的线程数触发每个线程执行的时刻，当CPU时间轮到分配某个线程执行时刻时该线程开始执行，执行到下一个线程执行的时，依此轮询，直到线程执行结束。 在理解启动模式前，理解几个概念\n任务 用户尝试在您的应用中执行操作时与之互动的一系列 activity。这些 activity 按照每个 activity 的打开顺序排列在称为“返回堆栈”的堆栈中，也称为任务栈。 Activity：简单理解就是页面，下面介绍启动模式的时候我们都把它理解为“页面”； Intent：教材一般叫意图，简单理解它就是带操作的信息，像指令一样，接收到Intent就类似接收到指令一样。 一个应用可以有多个任务栈，在考虑一个应用一个任务栈的情况下，两个页面如果在不同应用程序，那么在启动这两个页面的时候，他们会被压入各自的任务栈，所以两个不同应用程序的各自页面一般不会出现在同一个任务栈中； onNewIntent() 方法的作用主要是允许已存在的 Activity 更新其状态以响应新的 Intent 数据。例如，在接收动态广播（如地理位置更新、消息通知等）或重新加载内容时，无需重启 Activity 就可以处理新的数据。开发者需要重写这个方法并在其中处理接收到的新 Intent 数据。 四种启动模式：\n标准模式（standard）\n默认启动模式，如果任务栈中没有Activity则会实例化一个新的Activity，并将其压入当前任务栈的顶部。 如果同一个Activity已经存在栈顶，那么新的实例仍然会被创建并压入栈中，因此栈中可能包含多个该Activity实例。\n单例模式（singleTop）\n当一个新的Intent要启动已位于栈顶的Activity（与请求的Intent匹配的Activity）时，系统不会创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例；\n如果目标Activity不在栈顶，则会正常创建新的实例； 如果目标Activity不在栈顶而在栈顶的下一层呢？ 比如现在有A-B-C-D,D在栈顶，如果传来的Intent是要打开页面C，在单例模式下也是正常创建； 总结：\n在单例模式下，\n如果页面不存在，也就是要打开的Activity没有在任务栈中实例化，那么正常创建Activity实例，并压入栈中； 如果Activity已经存在于任务栈中，且为栈顶，那么系统不创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例， 如果不是栈顶，正常创建Activity实例。 栈内复用模式（singleTask）\n当打开一个页面，也就是启动一个Activity时，系统首先会在整个任务栈中查找这个Activity是否已经在栈中，\n情况一：如果存在并且处于栈底，则直接把该Activity之上的所有Activity弹出栈，使这个Activity置于栈顶并调用其onNewIntent()。 情况二：如果在栈顶，则将intent通过onNewIntent()方法传递给现有的Activity实例 如果不存在已有的Activity实例，才会创建新的实例并放入栈顶。这种模式下的Activity始终只有一个实例存在于任务栈中。\n单实例模式（singleInstance）\n当启动Activity时，系统会为它创建一个新的任务栈，然后在这个新的栈顶放上这个Activity的实例。 如果再次启动这个Activity，即使是在另一个任务栈中，系统也不会创建新实例，而是将意图传递给已经存在的Activity实例。\n附件 ",
    "description": "",
    "tags": [
      "安卓"
    ],
    "title": "AndroidStudio",
    "uri": "/branch-bundle-1/2.androidstudio/androidstudio%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: Z-专业课",
    "uri": "/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 安卓",
    "uri": "/tags/%E5%AE%89%E5%8D%93/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: R-软硬件",
    "uri": "/tags/r-%E8%BD%AF%E7%A1%AC%E4%BB%B6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 13.计算机组成原理",
    "content": "1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表\n比较内容 电子数字计算机 电子模拟计算机 数据表示方法 0或1 电压 计算方式 数字计算 电压组合和测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑计算能力 强 无 计算机的五代变化 第一代1946~1957年， 数据处理 得到应用； 第二代1958~1964年， 工业控制 开始得到应用； 第三代1965~1971年， 小型计算机开始出现； 第四代1972~1990年， 微型计算机 开始出现； 第五代1991年开始， 单片机 开始出现 计算机的性能指标 处理机字长 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。 存储器带宽 单位时间内从存储器独处的二进制数信息量，一般用 字节数/秒表示。\n2 运算方法和运算器 注：\n掌握各进制之间的转换； 掌握小数点之间的二进制与十进制之间的转换； 二进制纯小数或纯整数表示方法 二进制纯小数： 0.10101 或 1.10101，0或1表示正负号，在正负号后面，在实际中计算机并不存储小数点； 二进制纯整数： 10101.，同样纯整数也用0或1区分正负号。 用Xn-1表示二进制数的个数，Xn表示符号位，如下： Xn Xn-1……X0 符号 量值（尾数） 纯小数表示范围： $0\u003c=|x|\u003c=1-2^{-n} $ 纯整数表示范围： $0\u003c=|x|\u003c=2^{-n} - 1$\n浮点数表示方法 电子质量(克)： 9×10^28 = 0.9×10^27 太阳质量(克)： 2×10^33 = 0.2×10^34\n任意十进制数 N 可以表示为：\n$$N=10^E \\cdot M$$同样在二进制中也有这样类似的表达：\n$$ N=2^e \\cdot M$$ 在二进制浮点数表达中：\n尾数：M，是一个纯小数； 比例因子：e，表示指数，常用整数表示，也称为 阶码 ； 基数：式子中的2 二进制浮点数格式：\n$E_s$ $E_m-1…E_1 E_0$ $M_s$ $M_m-1…M_1 M_0$ 阶符 阶码 数符 尾数 IEEE754标准格式表示浮点数\n知识储备： $\\frac{1}{2^0}=1$, $\\frac{1}{2^1}=0.5$, $\\frac{1}{2^2}=0.25$, $\\frac{1}{2^3}=0.125$, $\\frac{1}{2^4}=0.0625$, $\\frac{1}{2^5}=0.03125$\n浮点数表示：\n$$ N=2^e \\cdot M$$ 浮点数所占位数：\n$S$ $E$ $M$ $31$ $30 \\gets 23$ $22 \\gets 0$ 基数R=2，基数固定，采用隐含方式来表示它。 32位的浮点数： S数的符号位，1位，在最高位，“0”表示正数，“1”表示负 数。 M是尾数， 23位，在低位部分，采用纯小数表示,不对小数点进行存储； E是阶码，8位，也就是说阶码最大不超过255，但阶码采用移码表示 $E=2^{7}+e=127+e$，原因是移码比较大小方便。 规格化： 若不对浮点数的表示作出明确规定，同一个浮点数的表示就不是惟一的，所以一般都会规定这个浮点数的位数 尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。 采用这种方式时，将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏移值127(01111111)，即E=e+127。如果是二进制转真值就E=e-127 下面举两个例子进行说明：\n例1：二进制转十进制若浮点数x的754标准存储格式为(41360000)16，求其浮点数的十进制数值。\n解：将16进制数展开后，可得二制数格式为\n0 100 00010 011 0110 0000 0000 0000 0000\n符号S=0\n阶码E=100 00010\n尾数M=011 0110 0000 0000 0000 0000\n指数e=E-127=10000010-01111111=00000011= $(3)_10$，故有\n1.M=1.011 0110 0000 0000 0000 0000=1.011011\n于是有\n$x=(-1)S \\times 1.M \\times 2^e=+(1.011011) \\times 2^3=+1011.011=(11.375)_10$ 问： 0.011怎么转成0.375？\n根据上面的知识储备有 $ \\frac{1}{2^0}\\times 0 + \\frac{1}{2^1}\\times 1 +\\frac{1}{2^2}\\times 1=0+0.25+0.125=0.375 $\n例2：十进制转二进制若浮点数为 $(28.8125)_10$，求其浮点数的IEEE754标准存储格式的二进制数值。\n解： $(28.8125)_10$= $(11100.1101)_2$\n格式化表示为： $(11100.1101)_2=1.11001101 \\times 2^4$\n于是有\ne=4\nE=e+127=4+127=131= $(1000 0011)_2$\nM=1100 1101 0000 0000 0000 000（去掉小数点和小数点前的1，而且有23位，不够补0）\nS=0\nIEEE754标准的32为存储数据位：0 1000 0011 1100 1101 0000 0000 0000 000\n数的机器码表示 计算机进行运算时，会把符号位和数字一起编码表示为相应的数，这些数可以用不同的方法表示，例如：原码、补码、移码、反码；\n为了区别一般写的数（比如-12，+3等）和机器中的编码（比如 0 1100,1 0011），通常前者称之为 真值，后者称为 机器数 或 机器码 。\n$[x]_原$表示机器数，x表示真值。\n例如：\n$x=+0011$， $[x]{_原}=\\textbf{0}0011$\n$x=-0011$， $[x]{_原}=\\textbf{1}0011$，\n原码机器中有“+0”“-0”之分，固有两种形式：例如： $[x]{_原}$与 $\\textbf{1}0011$表达的意思一样。\n数学上把类似于 $-3=+9 (mod12)$的式成为 同余式。\n原码、反码、补码、移码 对原码、反码、补码、移码的简单说明，已知计算机为4位，x=-3.\n例子 表示方法 二进制 说明 -3 原码 $[-3]{_原}$=00011 -3 反码 $[-3]{_反}$=01100 按位取反 -3 补码 $[-3]{_补}$=01101 反码最低位加1，注意这个时候符号还是1 -3 移码 $[-3]{_移}$=1,1101 $[e]{_移}=2^{k}+e=2^4-0011=0,1101$ 对于正数来说，前三个都一样，重点说明移码：\n定点整数定义 $[e]{_移}=2^{k}+e, 2^k \u003ee≥-2^k$\n上面的表达式中， $[e]{_移}$表示机器码，e为真值， $2^k$表示固定偏移常量。\n已知e=+0011,k=4， $[e]{_移}=2^{k}+e=2^{4}+0011=1,0011$\n已知e=-0011,k=4， $[e]{_移}=2^{k}+e=2^{4}-0011=0,1101$\n移码中的逗号不是小数点，而是表示左边一位是符号位，显然移码中符号位与前三者的表示相反（详见P21）。\n下面请看例题：\n已知计算机是8位的，请分别写出纯整数125，-110，纯小数+0.125，-0.375；二进制数x=11011,y=-01010的原码、反码、补码、移码。（注意格式，要对齐）\n表示方法 表示方法 +125=00101 1111 -110=10011 1011 $[125]{_原}$=00101 1111 $[-110]{_原}$=10011 1011 $[125]{_反}$=00101 1111 $[-110]{_反}$=11100 0100 $[125]{_补}$=00101 1111 $[-110]{_补}$=11100 0101 $[125]{_移}$=1,0101 1111 $[-110]{_移}$=0,1100 0100 +0.125=0.0010 0000 -0.357=1.0110 0000 $[125]{_原}$=0.0010 0000 $[-110]{_原}$=1.0110 0000 $[125]{_反}$=0.0010 0000 $[-110]{_反}$=1.1001 1111 $[125]{_补}$=0.0010 0000 $[-110]{_补}$=1.1010 0000 $[125]{_移}$=1,0010 0000 $[-110]{_移}$=0,1010 0000 x=11011 -110=-01010 $[125]{_原}$=00001 1011 $[-110]{_原}$=10000 1010 $[125]{_反}$=00001 1011 $[-110]{_反}$=11111 0101 $[125]{_补}$=00001 1011 $[-110]{_补}$=11111 0111 $[125]{_移}$=1,0001 1011 $[-110]{_移}$=0,1111 0111 定点加法、减法运算 公式 补码加法：任意两数补码之和等于两数之和的补码， $[x]{_补}+[y]{_补}=[x+y]{_补}$\n补码减法： $[x-y]{_补}=[x]{_补}-[y]{_补}=[x]{_补}+[-y]{_补}$\n从 $[y]{_补}$求 $[-y]{_补}$的法则是对 $[y]{_补}$包括符号位在内求反，最低位加1得到表达式为：\n$[-y]{_补}=\\rightharpoondown [y]{_补}+2^{-n}$ 其中，符号 $\\rightharpoondown$表示对 $[y]{_补}$作求反操作，包括正负号在内， $2^{-n}$表示末位（最低位）加1.\n下面举例加以理解运算过程：\n（ 详见P29 ）\n溢出概念与检验方法 在定点整数机器中，运算过程中出现大于字长绝对值的现象称为 溢出，溢出分正、负溢出两种，用两位符号位表示， 00、11分别表示整数和负数，01表示正溢出，10 表示负溢出。\n详细说明原理： 假设x表示二进制数，用 $2^{-n}",
    "description": "",
    "tags": [
      "R-软硬件"
    ],
    "title": "计算机组成原理-复习",
    "uri": "/branch-bundle-1/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 物联网工程",
    "uri": "/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 6.Arduino",
    "content": "物联网的特点 物联网是互联网的拓展和延伸，物联网设备通常为带传感器的电子硬件，并与网络相连接。 物联网的应用层是核心。 物联网的作用 全面感知：全面感知就是通过各种类型的传感器实时感知被测物理对象的状态。 可靠传递：可靠传递就是通过各种网络与互联网的融合，将物体的信息实时准确地传递出去。 智能计算：智能处理就是利用云计算、模糊识别等各种智能计算技术，对海量的数据和信息分析和处理，以实现对物体智能化控制。 物联网体系架构 ISO七层参考模型 以及每一层的功能。\n物理层：在物理媒体上传输原始的数据比特流。 数据链路层：将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。 网络层：将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。 传输层：提供不具体网络的高效、经济、透明的端到端数据传输服务。 会话层：进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。 表示层： 为应用层进程提供格式化的表示和转换数据服务。 应用层：提供应用程序访问OSI环境的手段。 物联网的三层结构 “云”、“管”、“端”分别指：应用层、网络层、感知层。 物联网服务器的主要功能接收数据、处理数据、保存数据。 物联网硬件设备有感知和反馈的作用\n可用于物联网短距离无线通信的技术主要有： Zigbee； RFID； NFC ; 蓝牙。 物联网近距离通信技术有： 蓝牙、 RFID、 ZigBee 工业物联网设备的组网方式可分为RS-232；RS-485；USB。\nRS-232： RS-232是一种早期广泛应用于串行通信的标准，提供点对点的数据传输，通常用于短距离通信（约15米以内）。 信号电平范围较大（±15V左右），支持全双工通信，即数据可以在两个方向上同时传输。 在工业环境中，RS-232常用于配置设备、调试或连接单个设备到计算机或其他控制器。 RS-485： RS-485基于差分信号传输，允许更长的传输距离（可达几千米），并且具有更好的抗噪声和电磁干扰能力。 它支持多点总线式网络架构，可以实现一个主设备与多个从设备之间的通信，因此特别适用于构建分布式控制系统或传感器网络。 RS-485采用半双工通信模式，在同一时间只能进行发送或接收操作，但通过软件协议控制可以实现在同一总线上多个节点有序通信。 USB（Universal Serial Bus）： USB是一种通用串行总线标准，它提供高速数据传输，并且能够为设备供电，使得它在现代工业自动化和物联网应用中越来越普遍。 USB支持热插拔，使用方便，而且有多种速度版本（如USB 2.0, USB 3.0等），数据传输速率远高于RS-232和RS-485。 在工业环境中，USB接口可能用于快速配置设备、固件升级或者连接各种智能设备，但它不适合长距离传输，一般局限于设备间较近距离的直接连接。 物联网M2M通信指的是机器与机器通信\n蓝牙采用高速跳频(Frequency Hopping)和时分多址(Time Division Multiple Access，TDMA)等先进技术，支持点对点及点对多点通信。其传输频段为全球公共通用的2.4 GHz频段，能提供1 Mb/s的传输速率和10 m的传输距离，并采用时分双工传输方案实现全双工传输。\nAndroid客户端在物联网体系中属于应用程序层。\n人工智能属于物联网体系中的服务层。\nNFC 是一种非接触式的识别技术。\n开关量与传感器 开关量与数字信号 数字信号指的是0和1两种信号的变化。传感器可以只使用0和1来表示自己的状态变化，也就是“有信号”和“没信号”两种情况，类似我们生活中的开关装置。\n模拟信号抗噪算法\n2.1 算术平均算法\n方法: 采样N个数据后进行平均\n优点: 算法简单、适合于一般带有不规则噪声的信号\n缺点: 用来运算的数值会越来越多，相对反应会越慢，不适用于实时性的控制，另外占用内存也多\n2.2 移动平均算法\n方法: 先将每一个新数据加入队列中并删除最后一个，再进行平均\n优点:算法简单、适用于有周期性干扰噪声的信号\n缺点:对于突然出现的异常脉冲信号的抑制较差，采样的数量过大时同样占用内存。\n模数转换 把传感器获取的测量值用连续的电子信号表示出来，就是模拟信号。想用PC处理模拟信号，就需要进行模拟/数字(A/D）转换，把模拟信号转换成离散值，即数字信号。A/D转换操作分成以下3个步骤。\n采样(sampling) =\u003e用某个频率来区分模拟输入信号，获取值 量化=\u003e把采样后的值近似表现为离散值 编码(coding)=\u003e把量化后的数值编码成二进制代码。如下图 传感器知识点 在物联网节点之间做通信的时候，通信频率越高，意味着传输距离越近。\n传感器的性能指标： 传感器动态特性：指传感器在输入变化时，它的输出特性，常以迁跃响应和频率响应来表示。\n传感器的线性度：传感器的实际静态特性输出是条曲线而非直线。\n传感器的灵敏度：传感器在静态工作情况下，输出变量变化y对输入变化量x的比值。\n传感器的分辨率：指传感器能感受到的被测量的最小变化的能力，也就是说某一输入量缓慢变化，当输入未超过某一值时，输出不变，超过了就有变化，则可以说此时传感器能分辨出来，这就是传感器的分辨率。\n传感器的组成与结构 传感器一般由敏感元件、转换元件、基本转换电路组成。 敏感元件：直接感受被测量，并且输出与被测量成一定关系的某一物理量的元件； 转换元件：敏感元件的输出就是它的输入，把输入转换成电路参量； 转换电路：将转换电路的输出转换成电量输出； 传感器的静态特性 静态特性是指测试系统在静态信号下，输入与输出的关系； 衡量测试装置静态特性的重要指标：\n线性度(Linearity) 灵敏度(Sensitivity) 迟 滞(Hysteresis) 重复性(Repeatability) 常见的传感器 光电式传感器（光敏电阻传感器） 如果把光敏电阻连接到外电路中，在外电压的作用下，用光照射就能改变电路中电流的大小。 如下图为工作原理图 光敏电阻的重要参数与基本特性 暗电流、暗电阻与亮电流、亮电阻：\n光敏电阻在未受到光照时的电阻和流过的电流分别称之为暗电阻和暗电流，有光照时则对应称之为亮电流、亮电阻；\n光电流 亮电流与暗电流的差值；\n结露传感器 理想的干燥空气：78%氮气+21%氧气+1%其他气体\n多尔顿分压定律：空气的压强P应该等于该混合物中各种气体分压之和,公示如下： 什么是湿度？ 空气中所含的水蒸气的量\n湿度的表示方法：\n绝对温度 相对温度 露点温度 露点温度(露点)：在一定的空气压力下，逐渐降低空气的温度，当空气中所含水蒸气达到饱和状态，而开始结露或结霜时的温度。 震动传感器： 震动三要素：振幅、频率、相位 以简谐运动为例： x=A cos(wt+y)\n红外对管（红外传感器） 红外对管中，黑色管子是红外发射传感器。\n智慧大棚中的常用传感器： （1）空气温湿度传感器 （2）光照传感器 （3）土壤湿度传感器 （4）风速传感器 （5）二氧化碳传感器 数据分析的基础架构\n首先把数据分析的基础架构分为 4 项来看，这 4 项分别是采集、积累、加工、分析。 高级分析的基础 机器学习可以说是高级分析的典型代表。机器学习领域汇集了众多技术，这些技术用于让计算机基于大量数据来学习数据的倾向并作出某些判断。机器学习的算法可以根据输入的数据类型分为“监督学习”和“非监督学习”两种。\n监督学习和非监督学习\n监督学习：当用机器学习的算法让计算机学习数据倾向时，算法会根据用于学习的数据中是否含有“正确答案”的数据而有所不同。 打个比方，假设现在要从传感器数据来判断分析设备的故障情况和建筑物的损坏情况等异常状况。如果采用监督学习的算法，就需要输入过去实际发生异常状况时的数据，即需要明确地输入“异常”的数据。说白了，算法要学习“正确答案”和“不正确答案”之间存在的差异。 非监督学习：监督学习则处理的是未标记的数据集，即数据集中没有预先定义的输出变量或目标变量。 非监督学习的目标在于发现数据内部的隐藏结构、模式、相似性或关联性，而不是预测特定的结果。非监督学习的主要主要任务有以下几种： Android IDE 介绍 Android客户端在物联网体系中属于 应用程序层 。\nArduino是2005年被设计开发出来的，开发平台的特点有： 开放性、混合编程、容易拓展。\nArduino开发环境是免费和开源的，开发语言为C/C++混合编程。\nArduino中下载程序到单片机需要先安装串口转USB的驱动程序。\nArduino程序的架构大体可分为3个部分 （1）声明变量及接口的名称。\n（2） setup()。 在Arduino程序运行时首先要调用setup()函数，用于初始化变量、设置针脚的输出/输入类型、配置串口、引入类库文件等等。每次Arduino上电或重启后，setup()函数只运行一次。\n（3） loop()。 在setup()函数中初始化和定义变量，然后执行loop()函数。顾名思义，该函数在程序运行过程中不断地循环，根据反馈，相应地改变执行情况。通过该函数动态控制Arduino主控板。\nArduino IDE编程并下载程序流程 在Arduino IDE编程并下载程序到开发板的过程，实际上是编译器将程序翻译为 机器语言（即二进制语言）的过程。计算机将二进制的指令传送到单片机程序闪存中，单片机识别指令后进行工作。下图是从编写好的程序到Arduno开发板运行程序的流程 Arduino开发中 数字管脚读取函数 digitalRead（） ； 模拟管脚读取函数 analogRead（） ； 串口调试函数为 Serial.println()，用于在串口打印内容 延时函数——Delay() 延时的基本单位为ms,Delay(200)为延时200ms Arduino UNO开发板提供6个模拟接口，模拟信号分辨率为10位（意味着ADC可以将输入的模拟电压分成2^10 = 1024个离散级别进行数字化），它能测到的最小电压为 5V/1024=0.0049V 。 Arduino的物理管脚有Analog、Digital、VCC、GND、VIN、RES等 Analog（模拟）管脚：\nArduino Uno等开发板上有一组特定的引脚标记为A0、A1、A2…A5（或更多，取决于具体型号），它们是模拟输入引脚。 这些引脚可以接收连续变化的电压值（通常在0到5V之间），并将其转换成数字值（0-1023，对应于ADC即模数转换器的分辨率是10位）。 通过这些引脚，你可以读取来自传感器或其他模拟信号源的数据。 Digital（数字）管脚：\n数字管脚用于处理二进制信号，也就是高电平（通常对应5V或3.3V，取决于板子类型和所处的操作模式）和低电平（接地，即0V）。 它们既可以作为输入端口检测外部设备的高低电平状态，也可以作为输出端口驱动LED、继电器或其他数字器件。 部分数字管脚还支持PWM（脉宽调制）输出，这样就可以模拟出不同亮度级别的LED或者调整电机速度等。 VCC：\nVCC代表“电源正极”。 GND：\nGND代表“接地”。 VIN：\nVIN是外部电源输入端，允许用户接入高于5V的电源（比如9V或12V电池）。这个引脚的电压将被板载稳压器转换成稳定的5V供给VCC使用。当Arduino通过USB线供电时，VIN不是必需的，但如果需要更高功率或独立电源，则可以使用此引脚。 RES / RESET：\nRES或RESET是复位引脚，当此引脚被拉低（一般是短接到GND）时，Arduino板上的微控制器会执行复位操作，重启其程序执行从头开始。在一些情况下，可以通过外部电路控制复位信号来实现更高级的功能，例如硬复位或远程复位。 Soc（系统芯片）处理器的功能强于MCU处理器的功能 SOC（System-on-a-Chip）处理器相较于MCU（Microcontroller Unit）处理器功能更强大的原因主要体现在以下几个方面：\n集成度：\nSOC芯片高度集成了中央处理器（CPU）、图形处理器（GPU）、内存（RAM、ROM/Flash）、以及其他专用硬件加速器如DSP（数字信号处理器）、通信模块（如Wi-Fi、蓝牙、LTE等）、以及各种外设接口，形成一个一体化的复杂系统。而MCU虽然也在单一芯片上集成了CPU和一些内存资源及I/O接口，但集成度一般低于SOC。 性能与计算能力：\nSOC通常采用高性能的CPU内核架构，可以支持多核设计，运行速度更快，并且可能支持运行复杂的操作系统（如Linux、Android等），能够处理更多的并发任务和执行更为复杂的算法。 MCU往往采用针对低功耗和实时控制优化的精简指令集CPU，更适合于简单、快速响应的任务。 存储容量和扩展性：\nSOC具有更大的内存空间，包括程序存储器和数据存储器，支持更大数据量的处理和存储需求，同时也可以通过外部总线连接更多存储设备。 相比之下，MCU的内部存储器相对有限，虽然也能扩展外部存储，但在规模上通常不及SOC。 多媒体与通信能力：\nSOC普遍具备强大的多媒体处理能力，例如图像处理、音频编解码、视频编码等，还集成有高级网络和无线通信功能，以适应移动设备和物联网应用的需求。 MCU在这些方面的集成程度和性能则较低，除非专门设计用于某些特定领域，否则它们通常不包含这些复杂的功能模块。 能耗与散热管理：\n虽然SOC功能强大，但也面临着更高的能耗和散热挑战。不过，现代的SOC设计采用了先进的电源管理和低功耗技术来平衡性能与能效之间的关系。 MCU在设计之初就重点考虑了低功耗应用，适合电池供电或对能源敏感的应用场景。 上课实验知识点 温湿度传感器 温湿度传感器采用的是 单总线协议 。\n单总线传送数据定义以AM2302为例。 SDA用于微处理器与AM2302之间的通讯和同步,采用单总线数据格式，一次传送40位数据，高位先出。\n通信格式 AM2302的湿度分辨率是16bit，高位在前。\n主机和传感器之间可以通过如下几个步骤完成数据读取。 步骤一 传感器上电后 ，测试环境温湿度数据，并记录数据，此后传感器自动转入休眠状态。\n步骤二 微处理器的I/O设置为输出，同时输出低电平，且低电平保持时间不能小于80ous，典型值是拉低1Ms，然后微处理器的I/O设置为输入状态，释放总线，由于上拉电阻，微处理器的I/O如AM2302的SDA数据线也随之变高，等主机释放总线后，AM2302发送响应信号，即输出80us的低电平作为应答信号，紧接着输出80us的高电平通知外设准备接收数据，信号传输如图7所示 步骤三 AM2302发送完响应后，随后由数据总线SDA连续串行输出40位数据，微处理器根据l/o电平的变化接收40位数据。\n位数据“o”的格式为:50微秒的低电平加26-28微秒的高电平; 位数据“1”的格式为: 50微秒的低电平加70微秒的高电平; 位数据“o”、位数据“1”格式信号如图8所示。 // REQUEST SAMPLE（发送请求，此阶段为激活温湿度传感器） pinMode(DHT_PIN, OUTPUT);//4号引脚设置输出模式，默认高电平输出 digitalWrite(DHT_PIN, LOW);//设置低电平输出，并延迟18ms delay(18); digitalWrite(DHT_PIN, HIGH);//设置高电平，并延迟40us delayMicroseconds(40); //第二阶段：通知开发板，自己准备发数据。 pinMode(DHT_PIN, INPUT);//设置输入模式 // ACKNOWLEDGE or TIMEOUT（确认或超时） unsigned int count = 10000;//定义无符号整形 while(digitalRead(DHT_PIN) == LOW) if (count-- == 0) return DHT_ERR_TIMEOUT;//返回DHT_ERR_TIMEOUT = -1 count = 10000; while(digitalRead(DHT_PIN) == HIGH) if (count-- == 0) return DHT_ERR_TIMEOUT; // READ OUTPUT - 40 BITS =\u003e 5 BYTES or TIMEOUT（读取输出- 40比特=\u003e 5字节或超时） for (int i=0; i\u003c40; i++) { count = 10000; while(digitalRead(DHT_PIN) == LOW) if (count-- == 0) return DHT_ERR_TIMEOUT; unsigned long t = micros(); //函数返回Arduino板开始运行当前程序时的微秒（us）数。 count = 10000; while(digitalRead(DHT_PIN) == HIGH) if (count-- == 0) return DHT_ERR_TIMEOUT; // |=:按位或后赋值 if ((micros() - t) \u003e 40) bits[idx] |= (1 \u003c\u003c cnt); //上次读取的时间到现在读取的时间差大于40，那么bits[idx] //的1左移CNT位，假设传的第一个数据是1，即(micros() - t)\u003e40， //那么把1左移cnt位后赋值给数组bits[]（刚开始的时候cnt=0, //也就是1左移0位） if (cnt == 0) // 高8位数据传完了没有呢？ { cnt = 7; // 传完了，那让cnt=7，即进行下一轮低八位的传输， idx++; // 数组加1，说明下一次存的数据放在了数组的下一位 } else cnt--; } sum = bits[0]+bits[1]+bits[2]+bits[3]; if(bits[4] != sum) return DHT_ERR_CHECK; //校验位 单总线读写流程 初始化 发命令 读取湿度和温度 流程图如下： 系统设计 物联网系统的开发流程： （1）系统规划阶段 （2）验证假设阶段 （3）系统开发阶段 （4）系统交付阶段 （5）维护应用阶段\n需求分析 首要步骤是获取用户需求。\n物联网详细设计 有代码编写、流程图绘制、 软件测试等。\n物联网设备选型的主要流程： （1）处理器选型，选择合适的单片机或开发板。\r（2）传感器选型，选择合适的数字或模拟传感器。\r（3）中间件选型，选择合适的网络通信方式。\r物联网系统测试的主要流程： （1）进行软件测试，分静态测试和动态测试。\r静态测试和动态测试是软件测试中的两种主要类型，它们在软件开发生命周期的不同阶段用来验证软件的质量和正确性。\r（2）进行硬件测试和网络测试。\r（3）进行系统集成测试。\r静态测试： 静态测试是指不执行程序代码的情况下进行的测试活动。它主要用于检查软件的非执行属性，主要包括：\n文档审查：检查需求规格说明书、设计文档、用户手册等非代码类文档是否清晰、完整、一致以及符合标准。\n代码审查（包括桌面检查、走查和正式审查）：通过人工或自动化工具对源代码进行逐行分析，查找可能存在的错误、缺陷、不符合编码规范的地方，以及潜在的设计问题和结构弱点。\n静态分析：利用静态分析工具自动检测代码中的潜在错误，如未初始化的变量、死代码、数据流错误、复杂度过高函数等问题。\n静态测试的目标在于发现并修复在软件开发早期就能确定的问题，以减少后期动态测试时发现严重错误的可能性。\n动态测试： 动态测试则是在实际运行软件的过程中进行的测试，重点在于检查程序的实际执行效果，主要包括：\n单元测试：针对单个模块或函数进行测试，确保其内部逻辑功能正常。\n集成测试：将各个模块组合在一起测试，验证接口间的交互及整体功能。\n系统测试：验证整个系统的功能、性能、安全性等方面是否满足预定要求。\n验收测试（包括用户验收测试）：根据业务需求验证软件能否在真实环境中正确工作。\n压力测试、负载测试和性能测试：检验软件在极限条件下的表现，例如处理大量并发请求的能力。\n动态测试通常使用黑盒测试、白盒测试和灰盒测试策略来构造测试用例，并通过实际运行程序得到结果与预期结果对比，从而发现并报告错误。\n总之，静态测试关注的是不运行程序就可识别的问题，而动态测试则侧重于在实际运行条件下暴露软件行为中的缺陷。两者结合能够更全面地保证软件质量。\n标准 , ASCI码使用7bit数据来表示所有的大写和小写字母、数字0到9、标点符号,以及在美式英语中使用的特殊控制字符。\n串口通信 标准 , ASCI码使用7bit数据来表示所有的大写和小写字母、数字0到9、标点符号,以及在美式英语中使用的特殊控制字符。\n串行通信是指使用一条数据线,将数据一位一位地依次传输,每一位数据占据一个固定的时间长度\n在进行串口通信时,两个串口设备间需要**发送端(TX)与接收端(RX)**交叉相连,并共用电源地(GND)。\n串行通信的约定 串行通信中的这种约定包含两个方面，\n一方面是通信的速率要保持一致， 另一方面是字符的编码要一致。 波特率 通信速率是指单位时间内传输的信息量,可用比特率和波特率来表示。 比特率 是指每秒传输的二进制位数,用bps (bits)表示。 波特率 是指每秒传输的符号数,若每个符号所含的信息量为1比特,则波特率等于比特率。\n串口工作原理\n在Arduino与其它器件通讯的过程中,数据传输实际上都是以数字信号(即电平高低变化)的形式进行的,串口通信也是如此.当使用Serial.print()函数输出数据时,Arduino的发送端会输出一连串的数字信号,称这些数字信号为数据帧. 例如,当时用Serial.print(‘A’)语句发送数据时,实际发送的数据帧格式如下图所示: Serial.begin()是Arduino开发平台串口初始化函数。 物联网设备跟云平台的通讯方法分为同步传输和异步传输\n以光照度传感器为例，讲解串口通信模式。\nconst int sensorPin = 2; const int ledPin = 13; int lineFound = -1; void setup() { Serial.begin(115200); pinMode(sensorPin, INPUT); pinMode(ledPin, OUTPUT); } void loop() { lineFound = digitalRead(sensorPin); if(lineFound == HIGH) { Serial.println(\" \"); digitalWrite(ledPin, HIGH); } else { Serial.println(\" \"); digitalWrite(ledPin, LOW); } delay(10); }流程如下： 串口例程：\nconst int analogInPin = A0; int sensorValue = 0; void setup(){ Serial.begin(115200,8N1); } void loop(){ sensorValue = analogRead(analogInPin); delay(250); }（1）串口通信模式有：1）波特率为115200 （2）校验方式为无校验 (3)数据位为8位、停止位为1位 （2）串口通信流程图 ",
    "description": "",
    "tags": "物联网工程",
    "title": "物联网控制-小知识",
    "uri": "/branch-bundle-1/6.arduino/21%E7%BA%A7%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 4.Esp8266_WiFi",
    "content": "通信串口 参照上一节课\n物联网是新一代信息技术领域的重要组成部分。其英文名称是“The Internet of things”，顾名思义，“物联网就是物物相连的互联网”。\n这有两层意思：\n第一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络； 第二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信。\n全面感知：全面感知就是通过各种类型的传感器实时感知被测物理对象的状态。 可靠传递：可靠传递就是通过各种网络与互联网的融合，将物体的信息实时准确地传递出去。 智能计算：智能处理就是利用云计算、模糊识别等各种智能计算技术，对海量的数据和信息分析和处理，以实现对物体智能化控制。 通信 通信的目的 传递消息中所包含的信息\n消息 是物质或精神状态的一种反映，例如语音、文字、音乐、数据、图片或活动图片等\n信息 是消息的有效信息内容\n通信系统的一般模型 信息源、发送设备、信道、接收设备、受信者、噪声源。\n发送端：信息源、发送设备； 接收端：接收设备、受信源； 通信系统分类 根据按信道中传输的 信号分类 ，通信系统分为 模拟通信系统 和 数字通信系统 。模拟通信系统传送的是模拟信号，这代表消息的信号参量取值是连续的。\n调制是指把信号转换成适合在信道中传输的形式的一种方产。广义调制分为 基带调制 和 频带（载波）调制\n点对点之间的通信，按消息传送的方向，通信方式可分为 单工通信 、半双工通信及全双工通信 三种\n串行通信 将数字元码序列以串行方式一个元码接着一个元码的在一条信道上传输。\n优点：只需一条通信信道，节省线路铺设费用； 缺点：速度慢，需要外加码组或字符同步措施。\n随着技术的发展，以USB为代表的串行传输速度已经超过并行传输。\n并行通信 将代表信息的数字信号元码序列以组的方式在两条或者两条以上在并行信道上同时传输。\n优点：节省传输时间，速度快，不需要字符同步措施； 缺点：需要n条数据线，成本高。\n标准 , ASCI码使用7bit数据来表示所有的大写和小写字母、数字0到9、标点符号,以及在美式英语中使用的特殊控制字符。\n串行通信是指使用一条数据线,将数据一位一位地依次传输,每一位数据占据一个固定的时间长度\n在进行串口通信时,两个串口设备间需要**发送端(TX)与接收端(RX)**交叉相连,并共用电源地(GND)。\n串行通信的约定 串行通信中的这种约定包含两个方面，\n一方面是通信的速率要保持一致， 另一方面是字符的编码要一致。 波特率 通信速率是指单位时间内传输的信息量,可用比特率和波特率来表示。 比特率 是指每秒传输的二进制位数,用bps (bits)表示。 波特率 是指每秒传输的符号数,若每个符号所含的信息量为1比特,则波特率等于比特率。\n串口工作原理\n在Arduino与其它器件通讯的过程中,数据传输实际上都是以数字信号(即电平高低变化)的形式进行的,串口通信也是如此.当使用Serial.print()函数输出数据时,Arduino的发送端会输出一连串的数字信号,称这些数字信号为数据帧. 例如,当时用Serial.print(‘A’)语句发送数据时,实际发送的数据帧格式如下图所示: Serial.begin()是Arduino开发平台串口初始化函数。 物联网设备跟云平台的通讯方法分为同步传输和异步传输\n以光照度传感器为例，讲解串口通信模式。\nconst int sensorPin = 2; const int ledPin = 13; int lineFound = -1; void setup() { Serial.begin(115200); pinMode(sensorPin, INPUT); pinMode(ledPin, OUTPUT); } void loop() { lineFound = digitalRead(sensorPin); if(lineFound == HIGH) { Serial.println(\" \"); digitalWrite(ledPin, HIGH); } else { Serial.println(\" \"); digitalWrite(ledPin, LOW); } delay(10); }流程如下： 串口例程：\nconst int analogInPin = A0; int sensorValue = 0; void setup(){ Serial.begin(115200,8N1); } void loop(){ sensorValue = analogRead(analogInPin); delay(250); }（1）串口通信模式有：1）波特率为115200 （2）校验方式为无校验 (3)数据位为8位、停止位为1位\n（2）串口通信流程图 ZigBee与IEEE802.15.4 ZigBee网络中的每一个节点都有一个16bit网络地址和一个64bit IEEE扩展地址。\nIEEE802.15.4定义了2450MHz、868MHz、915MHz三个频段。对于不同的国家和地区，为其提供的工作频率范围是不同的，其中2450MHz （2.4GHz）频段是全球统一无需申请的的ISM频段，提供 250kbps 的通信速率，并提供16个信道;868MHz频段是欧洲的ISM频段，提供1个速率为20kbps的信道，915MH频段是美国的ISM频段，提供10个速率为40kbps的信道。\n在ZigBee网络中存在三种节点类型：\nCoordinator(协调器)， Router(路由器) End-Device(终端设备)。 ZigBee网络由一个Coordinator以及多个Router和多个End_Device组成。\nZigBee可采用 星状 、片状 和 网状 网络结构，由一个主节点管理若干子节点，最多一个主节点可管理254个子节点;同时主节点还可由上一层网络节点管理，最多可组成65000个节点的大网。\n三种设备类型\n三种节点类型及其案例\n三种网络拓扑结构类型\n星形拓扑 包含一个Co-ordinator（协调者） 节点和一系列的 End Device（终端）节点，每一个End Device 节点只能和 Co-ordinator 节点进行通讯。如果需要在两个 End Device 节点之间进行通讯必须通过Co-ordinator 节点进行信息的转发。\n树形网络 树形拓扑包括一个Co-ordinator（协调者）以及一系列的 Router（路由器） 和 End Device（终端）节点。Co-ordinator 连接一系列的 Router 和 End Device， 他的子节点的 Router也可以连接一系列的 Router 和End Device. 这样可以重复多个层级。 Co-ordinator 和 Router 节点可以包含自己的子节点。End Device 不能有自己的子节点。有同一个父节点的节点之间称为兄弟节点。\n网型网络（Mesh拓扑） 网形网络（Mesh拓扑） 包含一个Co-ordinator和一系列的Router 和End Device。这种网络拓扑形式和树形拓扑相同；请参考上面所提到的树形网络拓扑。但是，网状网络拓扑具有更加灵活的信息路由规则，在可能的情况下，路由节点之间可以直接的通讯。这种路由机制使得信息的通讯变得更有效率，而且意味这一旦一个路由路径出现了问题，信息可以自动的沿着其他的路由路径进行传输。\nRFID射频识别技术 RFID的定义：射频识别（Radio Frequency Identification，RFID）是一种 非接触式 的自动识别技术，它通过射频信号自动识别特定目标对象并读写相关数据，而无须识别系统与特定目标之间建立机械或光学接触。\nRFID系统通常由 电子标签 、读写器 和 计算机网路 三部分组成。\nRFID系统中的读写器的 工作频率 决定了整个RFID系统的工作频率，功率大小决定了整个RFID系统的工作距离。\n在RFID系统中常用的频段有4种：低频LF(125kHz)、高频HF(13.56MHz)、超高频UHF(850～910MHz)及微波(2.45GHz)\n电子标签分为 无源标签(passive)、 半无源标签(semi-passive) 和 有源标签(active)三种类型。\nRFID最基本的硬件体系结构由RFID电子标签、RFID读写器和计算机。\nRFID系统的工作原理 利用射频信号的空间耦合（电磁感应或电磁传播）传输特性，实现对静止的、移动的待识别物品的自动识别，如图所示：\nRFID网络框架结构 通信串口组网、 读写器与计算机直接连接、 读写器通过中间件连入网络 RFID工作过程 读写器向M1卡发一组固定频率的电磁波，卡片内有一个LC串联谐振电路，其频率与读写器发射的频率相同，在电磁波的激励下，LC谐振电路产生共振，从而使电容内有了电荷，在这个电容的另一端，接有一个单向导通的电子泵，将电容内的电荷送到另一个电容内储存，当所积累的电荷达到2v时，此电容可做为电源为其它电路提供工作电压，将卡内数据发射出去或接取读写器的数据。\n蓝牙技术 蓝牙技术工作在2.4GHz频段，2.4GHz的ISM波段是一种短距离无线传输技术，供开源使用。 2. 蓝牙使用跳频技术，将传输的数据分割成数据包，通过79个指定的蓝牙频道分别传输数据包。每个频道的频宽为1MHz，蓝牙4.0使用2MHz间距，可容纳40个频道。 3. 蓝牙采用高速跳频(Frequency Hopping)和时分多址(Time Division Multiple Access，TDMA)等先进技术，支持点对点及点对多点通信。其传输频段为全球公共通用的2.4 GHz频段，能提供1 Mb/s的传输速率和10 m的传输距离，并采用时分双工传输方案实现全双工传输。 4. 在一个微微网中，所有设备的级别是相同的，具有相同的权限。主设备单元负责提供时钟同步信号和跳频序列，从设备单元一般是受控同步的设备单元。\n链路管理协议层利用状态机定义了设备的五中状态\n就绪 扫描 广播 发起 连接 WiFi技术 WiFi技术的基本概念 定义： 一种可以将个人计算机、手机设备等终端以无线方式互相连接的技术。 WiFi（wireless Fidelity），在无线局域网领域称为“无线相容性认证”，是一种无线网络通信的品牌，有Wi-Fi联盟所持有，目的是为了改善基于IEEE802.11b标准的无线网络产品之间的互通性。 WiFi既是一种商业认证，也是一种无线联网技术； WiFi技术的优点：可移动、实现简单、可靠性强、环保指数高； 无线局域网（Wireless Local Area Network，WLAN） 无线局域网（WLAN）工作频段\n按照国家的无线电管理部门规定，WLAN使用2.4GHz和5.8GHz两个频段。这两个频段属于特高频和微博范围，属于微波波段（波长小于一米） 2.4GHz频段信道划分： 可用的宽带为83.5MHz，划分13个信道，每个信道宽为22MHz，信道之间有间隔，间隔5MHz。2.4GHz频段信道划分如下图所示：\n5.8GHz频段信道划分： 在中国大陆，IEEE802.11a使用的是5.98GHz频段，工作频率范围为5725-5875MHz。可用信道为5个，分别为149，153，,157，,161，165，每两个信道之间相差4，信道之间没有间隔。 无线局域网（WLAN）的架构 无线局域网参考模型与OSI七层参考模型如下图： IEEE802标准遵循ISO/OSI 参考模型的原来规则确定最低两层——物理层与数据链路层的功能，以及与网络层的接口服务、网络互联等有关的高层功能。 2. 无线局域网（WLAN）的重要协议\nIEEE最初制定的无线局域网标准主要用于解决 办公室局域网 和 校园网 中用户以及 终端的无线接入 问题，其业务主要限于数据存取，其速率最高只能达到2Mpbs。 由于它在速率和传输距离上都不能满足人们的需要，IEEE小组又相继推出了802.11b、802.11a、802.11g、802.11n、802.11ac等一系列标准。 (1) WLAN技术具有以下优势\n灵活性强，终端设备可以在WLAN网络的覆盖范围内任意放置和低速移动。 部署成本较低，省去了终端设备综合布线的费用。 扩展能力好，增加AP就可以增大容量和覆盖范围。 技术成熟，在国外已经得到广泛的应用。 采用了扩频技术和加密机制，具有较强的抗干扰性和网络保密性，安装简单。 (2）帧的种类和用途如下:\n数据帧:用来传送数据，不含任何数据的空帧也属于数据帧。 控制帧:控制媒体存储的各种帧。 管理帧:与无线网络运作有关的帧，例如无线设备的连接，身份认证等等。 ESP8266单片机 ESP8266模块的开发语言C语言 ESP8266模块有1个模拟输入管脚 常用函数 WiFi.begin(ssid,pass)： ssid: 热点的名字 pass：热点的密码 WiFi.mode()：设定wifi的操作模式，其参数值为: WIFl_AP,WIFl_STA,WIFI_AP_STA或者WIFI_OFF WIFI_OFF:关闭WiFi WIFI_STA:设置成Wi-Fi终端 WIFI_AP:设置成Wi-Fi网络接入点(基站，热点) WIFI_AP_STA:-设置成Wi-Fi网络接入点以版终端 WIFI.getMode():返回当前的WIFI模式，上述四种模式中的一种。 WIFI.softAP(ssid):创建一个无线局域网热点。这个热点允许其他设备（如手机、电脑等）通过Wi-Fi连接到ESP8266。参数 ssid 是要创建的Wi-Fi热点的名称，是一个字符串类型变量,最多31个字符。 WiFi.softAP(ssid,password,channel,hidden,max_connetion)：设置受密码保护的网络或配置其他网络参数，此功能的第一个参数是必须的，其余四个是可选的； password 带有密码的可选字符串。对于WPA2-PSK网络，其长度至少应为8个字符。如果未指定，则接入点将打开，任何人都可以连接（最多63个字符）\nchannel（可选参数） ：指定SoftAP要使用的Wi-Fi信道。不同的国家和地区有不同的可用信道范围，我国的信道范围规定,选择一个相对空闲的信道有助于提高无线通信质量。\nhidden（可选参数） ：如果设为true，表示创建一个隐藏网络，即不广播其SSID，这样其他设备不能通过常规方式自动扫描到该热点。用户需要手动输入正确的SSID才能连接。\nmax_connection（可选参数） ：定义允许同时连接到SoftAP的最大客户端数量。超出这个数目的设备将无法再加入此Wi-Fi网络。\nsoftAPgetStationNum()：获取连接的soft-AP接口的站点数WiFi. softAPdisconnect(wifioff)，功能会将当前配置的SSID和soft_AP的密码设置为空值，该参数wifioff是可选的，如果设置为true，将关闭soft-AP模式 WiFi.softAPIP(): 返回访问点的网络接口的IP地址，返回值是IPAddress类型。 WiFi.softAPmacAddress(mac): 函数接受一个参数mac，该参数是指向内存位置的指针（一个uint8_t大小为6个元素的数组），以保存mac地址。函数本身返回相同的指针值。 Station模式 首先AP发出信标(beacon)帧，意思就是我在这里，谁来连接我啊; 移动工作站 也会发出探(probe)帧，意思是有谁我可以连接啊。这个是工作站主动发出来的，每隔一定时间发出一次。 所以，根据这点，可以产生很多有价值的应用。比如你的带WiFi功能的手机，即使不连接wifi的情况下，只要打开WiFi功能，就可以被路由器截获这帧信息，路由器收集之后，你的信息就会被一个审计的东西发到服务器上，你手机号xxx上线时间xxx下线时间xxx都浏览了那些网页，WiFi建立连接过程都一目了然，你的位置也全都暴露了，这就叫WiFi探针。\n具体流程如下所示:\n探测请求过程： STA：设备 ————\u003eProbe Request(探测请求)—\u003e AP：热点\n返回应答帧： STA\u003c———– Probe Response \u003c———– AP，这个是由wifi（热点）返回的应答帧;\n接下来是身份验证过程，可以使用诸如 WEP、WEP2、WPA 等加密方式应用到认证请求上;\n身份验证过程： STA ————\u003e Authentication Request ——–\u003eAP 认证请求中包含认证 Auth类型，Open System , Shared Key等信息，路由器返回认证结果;\n连接请求 STA\u003c———— Authentication Response\u003c——— AP连接请求; STA————\u003e Association Request ————\u003eAP请求与AP建立关联，从而可以进行数据交互;认证过连接请求OK返回。\n数据传输 STA\u003c————- Association Response\u003c———– AP\n#include \u003cESP8266WiFi. h\u003e #define ssid\"ESP8266\" #define pssd\"123456789” const char* stassid= \"doit\"; const char* stapssd = \"doit3305\"; void setup(){ // put your setup eode here, to run once : serial.begin(115200);//波特率设置为115200 wiPi.mode(WIFI_AP_STA);//设置WIFI操作模式为WIFI_AP_STA,即接入点以及终端 wiPi.disconnect();// wiri.begin(stassid, stagssd); while(WiPi.status() !=L_COHIEECTED){ delay=(500) ; Serial.print(\"\".\"\"); } serial .println(\"TIFI connect sucess\") ; serial. println(WiPi.localIP()); WiPi.softAP(ssid,pssd);//连接WIFI IPAddress ip=wiPi.softAPIP();//softAPIP()返回网络接口IP地址，返回值为IPAddress serial . println(ip): Serial . println(wiPi.softAPmacAddress().c_str()); } void loop(){ //put your main code here, to run repeatedly : Serial.printf(\"Station conneted to soft-AP = %d\\n\" ,WiPi.softAPgetStationJlun());//softAPgetStationJlun获取soft-AP接口的站点数 delay=(5000); }TCP/IP协议 TCP/IP不是指特定的某一个协议，而是一个协议族，包含众多的协议。\n互联网通信的本质是数字通信，任何数字通信都离不开通信协议的制定，通信设备只有按照约定的、统一的方式去封装和解析信息，才能实现通信。互联网通信所要遵守的众多协议，被统称为TCP/IP .\nServerd的应用 与之相关的函数：\nServer ：服务器是所有基于WIFI Server的基类， Server()函数：创建一个服务器，以侦听指定端口上的连续； Server(port) 参数port:侦听的端口（int类型）； 返回值：无 如下为一个Server应用的代码，代码实现了用开发板连接手机开的热点，然后在手机上输入串口监视器打印的IP，然后可以看见显示 “analog input:2” 的网页。\n#include\u003cESP8266WiFi.h\u003e cconst char* ssid = \"LW\"; const char* pssd = \"ping123456\"; WiFiServer server(80);//侦听端口，无返回值 void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial.println(); Serial.printf(\"connetctint tu %s\",ssid); WiFi.begin(ssid,pssd); //连接wifi while(WiFi.status()!=WL_CONNECTED) //等待连接wifi { delay(500); Serial.print(\".\"); } Serial.println(\"connected\"); server.begin(); //侦听服务器 Serial.printf(\"web server started,open %s in a web browser\\n\",WiFi.localIP().toString().c_str()); } String prepareHtmlPage() //返回网页浏览器 { String htmlPage= String(\"HTTP/1.1 200 OK\\r\\n\")+ \"Contect-Type:text/html\\r\\n\"+ \"Connerction:close\\r\\n\"+ //连接关闭请求 \"Refersh:5\\r\\n\"+ //5秒刷新一次网页 \"\\r\\n\"+ \"\u003c!DOCTYPE HTML\u003e\" + \"\u003chtml\u003e\"+ \"analog input:\" + String(analogRead(A0))+ \"\u003c/html\u003e\"+ \"\\r\\n\"; return htmlPage; } void loop() { // put your main code here, to run repeatedly: WiFiClient client = server.available(); //检测是否有客户端存在 if(client) { Serial.println(\"\\n[Client connected]\"); while(client.connected()) //判断客户端是否连接成功 { String line = client.readStringUntil('\\r'); //每行读取到r结束 //等待服务器的应答 if(line.length()==1\u0026\u0026line[0]=='\\n') { client.println(prepareHtmlPage()); break; } } } delay(1); }TCPClient函数 相关函数介绍\nconnect()描述：\r连接到构造函数中指定的IP地址和端口。返回值指示成功或失败。使用域名( ex:google.com）时，connect()还支持DNS查找。\r句法:\r- client.connect(ip,port)\r- client.connect(URL,port)参数\rip: 客户端将连接的ip地址（4个字节的数组)\rURL: 客户端将连接到的域名（字符串，例如: \"arduino.cc\"）\rPort: 客户端将连接到的端口（ int）\r返回值：如果连接成功，则返回 true;\r否则，返回false\rprint()描述：\r将数据打印到客户端连接到服务器。将数字打印为数字序列，每个数字为一个ASCI字符句法:\rclient.print(data)\rclient.print(data,BASE)参数\rdata:要打印的数据（char,byte,int,long或string）\rBASE（可选）:打印数字的基数:DEC代表十进制（基数10），\rOCT代表八进制（基数8），\rHEX代表十六进制（基数16\u003e\r客户端访问服务器流程\n连接到Wi-Fi 选择服务器 实例化客户端WiFiClient client; 把客户端连接到服务器 请求数据 读取来自服务器的回复 实现代码如下： #include \u003cESP8266WiFi.h\u003e const char* ssid = \"LW\"; const char* pssd = \"ping123456\"; const char* host = \"www.baidu.com\"; void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial.println(); Serial.printf(\"connecting to %s \",ssid); WiFi.begin(ssid,pssd); while(WiFi.status()!=WL_CONNECTED) //等待WIFI连接成功 { delay(500); Serial.print(\".\"); } Serial.println(\"connected\"); } void loop() { // put your main code here, to run repeatedly: /* String host=\"\"; while(Serial.available()\u003e0) { host += (char)Serial.read(); delay(2) } */ //char host[30]; // for(int i=0;i\u003c30;i++) // { // host[i]='\\0'; // } // while(Serial.available()\u003e0) // { // host += (char)Serial.read(); // delay(2) // } // WiFiClient client; Serial.printf(\"\\n[connecting to %s ...\",host); if(client.connect(host,80)) //连接服务器成功 { Serial.println(\"connected]\"); //访问google.cn的报头，采用GET方式， Serial.println(\"[Sending a request]\"); client.println(String(\"GET/\")+ \"HTTP/1.1\\r\\n\"+ \"Host:\"+host+\"\\r\\n\"+ \"Connection: close\\r\\n\"+ \"\\r\\n\" ); Serial.println(\"[Response:]\"); while(client.connected()||client.available()) //等待如果客户端已经连接，并且有数据到来 { if(client.available()) { String line = client.readStringUntil('\\n'); //从缓存区读取服务器的数据 Serial.println(line); } } client.stop(); //停止客户端 Serial.println(\"\\n[Disconnected]\"); } else { Serial.println(\"connection failed !\"); client.stop(); } delay(5000); }HTTP协议简介 当使用浏览器(客户端)访问一个网页时,大致经过了以下三步:\n用户输入网址后,浏览器(客户端)会向服务器 发出HTTP请求 ; 服务器收到请求后会返回HTML形式的文本以响应请求; 浏览器收到服务器返回的HTML文本后,将文本转换为网页显示出来。 HTTP请求 当客户端访问网页时,会先发起HTTP请求。HTTP请求由三部分组成,分别是 请求行、请求报头 和 请求正文。\nHTTP响应 服务器在接收到HTTP请求消息后,会返回一个响应消息。HTTP响应也是由三个部分组成,分别是状态行、响应报头和响应正文。\nUDP协议 用户数据报UDP有两个字段:数据字段和首部字段。首部字段很简单，只有8个字节(图5-5)，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下:\n(1)源端口 源端口号。在需要对方回信时选用。不需要时可用全0。 (2)目的端口 目的端口号。这在终点交付报文时必须使用。 (3）长度 UDP用户数据报的长度，其最小值是8（仅有首部)。 (4)检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。\n程序流程：\n设置ESP8266工作在station模式（ WiFi.mode(WIFI_STA)) ;②将ESP8266接入到wIFI网络中WiFi.begin(SSID,PSSD); 实例化WiFiUDP对象指定端口，建立UDP连接，连接后自动开始侦听传入的数据包。 WiFiUDP Udp; Udp.begin(localUdpPort); 等待输入的UDP包处理收到的数据并回复。 Udp.parsePacket ( ) ; Udp.read(incomingPacket,255); Udp.beginPacket(Udp.remotelP(), Udp.remotePort()); Udp.write(replyPacket); Udp.endPacket(); /* 1、设置ESP8266工作在station模式（WiFi.mode(WIFI_STA)）; 2、将ESP8266接入到WIFI网络中WiFi.begin(SSID,PSSD); 3、实例化WiFiUDP对象指定端口，建立UDP连接，连接后自动开始侦听传入的数据包。 WiFiUDP Udp; Udp.begin(localUdpPort); 4、等待输入的UDP包处理收到的数据并回复。 Udp.parsePacket（）; Udp.read(incomingPacket, 255); Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(replyPacket); Udp.endPacket(); */ #include \u003cESP8266WiFi.h\u003e #include \u003cWiFiUdp.h\u003e const char* ssid = \"iPhone\"; const char* password = \"peng2020\"; WiFiUDP Udp; unsigned int localUdpPort = 4210; // local port to listen on char incomingPacket[255]; // buffer for incoming packets char replyPacket[] = \"Hi there! Got the message :-)\"; // a reply string to send back void setup() { // put your setup code here, to run once: Serial.begin(115200); Serial.println(); Serial.printf(\"Connecting to %s \", ssid); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); //开始连接WIFI while (WiFi.status() != WL_CONNECTED) //等待连接 { delay(500); Serial.print(\".\"); } Serial.println(\" connected\"); Udp.begin(localUdpPort); //指定本地连接端口号 Serial.printf(\"Now listening at IP %s, UDP port %d\\n\", WiFi.localIP().toString().c_str(), localUdpPort); } void loop() { // put your main code here, to run repeatedly: int packetSize = Udp.parsePacket(); //调用函数解析数据包 if (packetSize) { // receive incoming UDP packets Serial.printf(\"Received %d bytes from %s, port %d\\n\", packetSize, Udp.remoteIP().toString().c_str(), Udp.remotePort()); int len = Udp.read(incomingPacket, 255); //从缓存区读取数据 if (len \u003e 0) { incomingPacket[len] = 0; //给缓存区加结束符 } Serial.printf(\"UDP packet contents: %s\\n\", incomingPacket); // send back a reply, to the IP address and port we got the packet from Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); //指定远程连接地址和端口号 Udp.write(replyPacket); Udp.endPacket(); } }HTTP与MQTT协议对比 不同于HTTP的标头采用文字描述，MQTT的标头探用数字编码，整个长度只占2位元组，等同两个字元，后面跟著讯息的主题(topic)和内容(payload)，实际格式如下:\nQoS(品质)设定 QoS代表发布者与代理人，或者代理人与订阅者之间的传输品质。MQTT定义了0,1和2三个层级的品质设定（实际支援情况依伺服器软体而定，Mosquitto伺服器全都支援)∶0:最多传送一次(at most once) 1:至少传送一次(at least once)2:确实传送一次(exactly once) 用寄信来比喻，QoS0就像寄平信，不保证讯息会送达。\n阿里云平台 物联网云平台：接收设备上报的数据、向设备下发数据、对数据进行转发/分析/计算/显示、管理设备… #include \u003cESP8266WiFi.h\u003e//安装esp8266arduino开发环境 static WiFiClient espClient; #include \u003cAliyunIoTSDK.h\u003e//引入阿里云 IoT SDK //需要安装crypto库、PubSubClient库 //设置产品和设备的信息，从阿里云设备信息里查看 #define PRODUCT_KEY \"k0mzriwvgtZ\"//替换自己的PRODUCT_KEY #define DEVICE_NAME \"LED2\"//替换自己的DEVICE_NAME #define DEVICE_SECRET \"674c24074d05a31a672094c0d23dc07c\"//替换自己的DEVICE_SECRET #define REGION_ID \"cn-shanghai\"//默认cn-shanghai #define WIFI_SSID \"LW\"//替换自己的WIFI #define WIFI_PASSWD \"ping123456\"//替换自己的WIFI #define PIN_LED 2 //LED unsigned long lastMsMain = 0; void setup() { Serial.begin(115200); //pinMode(LED_BUILTIN, OUTPUT); // digitalWrite(LED_BUILTIN, HIGH); pinMode(PIN_LED, OUTPUT); digitalWrite(PIN_LED, HIGH); //连接到wifi wifiInit(WIFI_SSID, WIFI_PASSWD); //初始化 iot，需传入 wifi 的 client，和设备产品信息 AliyunIoTSDK::begin(espClient, PRODUCT_KEY, DEVICE_NAME, DEVICE_SECRET, REGION_ID); //绑定一个设备属性回调，当远程修改此属性，会触发LED函数 AliyunIoTSDK::bindData(\"LED2\", LED); } void loop() { AliyunIoTSDK::loop();//必要函数 if (millis() - lastMsMain \u003e= 2000)//每2秒发送一次 { lastMsMain = millis(); //发送LED状态到云平台（高电平：1；低电平：0） AliyunIoTSDK::send(\"LED2PIN\", digitalRead(PIN_LED)); } } //wifi 连接 void wifiInit(const char *ssid, const char *passphrase) { WiFi.mode(WIFI_STA); WiFi.begin(ssid, passphrase); while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(\"WiFi not Connect\"); } Serial.println(\"Connected to AP\"); } //灯的属性修改的回调函数 void LED(JsonVariant L)//固定格式，修改参数l { int LED = L[\"LED2\"];//参数l，与标识符一致 if (LED == 0) { digitalWrite(PIN_LED, HIGH); } else { digitalWrite(PIN_LED, LOW); } Serial.printf(\"收到的LED是：\"); Serial.println(LED); }",
    "description": "",
    "tags": "物联网工程",
    "title": "物联网通信技术-小知识",
    "uri": "/branch-bundle-1/4.esp8266_wifi/21%E7%BA%A7%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: D1-51单片机",
    "uri": "/categories/d1-51%E5%8D%95%E7%89%87%E6%9C%BA/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 8.51单片机",
    "content": "不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了pretues_8.11 仿真软 件和keil5代码编辑器，自己把心中所得分享一下。\n别人编译编译成功的工程，我另外用keil5打开编译为什么会失败？\n假设你拿到的别人的工程所选芯片为stm32f103VC，那么你在另外的电脑打开keil5，在设置里选芯片也是stm32f103VC，如果选的芯片与工程最初选的型号不同，那编译可能会失败，接着在打勾生成.hex文件。\npretues里没有找到keil5里选择的芯片，能用别的芯片代替吗？\n答案是可以的，但尽量使用版本更高的芯片，使之能向下兼容，在keil5如果选了stm32f103VC，而pretues仿真的芯片是stm32f103C6，那么你并不用担心芯片不对应而导致你仿真失败。\n在pretues导入.hex文件后直接开始仿真，为什么报了许多错误？\n可能原因：在选择好.hex文件后，还必须设置晶振频率，即12MHz，如果没置会导致仿真失败，另外你不用担心选择的.hex文件路径有中文，我测过即使导入文件路径有中文也可以正常运行。\n附件 ",
    "description": "",
    "tags": [
      "代码烧录",
      "报错与解决"
    ],
    "title": "pretues+kiel5仿真软件配合使用时需要注意的地方",
    "uri": "/branch-bundle-1/8.51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 代码烧录",
    "uri": "/tags/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 爱情",
    "uri": "/tags/%E7%88%B1%E6%83%85/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "第一章 与君初相识 高中那会儿我老失眠，原因一言难尽。\n记得有一次我去吃饭，遇到张君，我们聊闲聊中，谈到了我失眠的事，张君听了说，他们有个朋友以睡觉为己任的人。我不信，哪有这种人？\n几天后张君竟把他介绍给了我，我们仨还一起去吃了饭，顺便逛了街，特别是喝奶茶的时候，张君故意给我和他有二人空间，整得像相亲似的，而后只是聊了些生活学习上的问题……在买花的时候我叫住他：“那个？”\n没想到他没听见，“听说你以‘睡觉’为己任，”我提了声音又叫了一遍，搞得自己有些尴尬：“是真的？”\n他一脸疑惑，又露出让人想笑的表情，道：“what?”\n气氛顿时尴尬，我有些不好意思，手挡了挡额头，说了句，没什么。回头继续吃着烧烤便不再问什么，寻思着张君的话自己也信？\n傍晚有些冷，校门就是我们的最后一站，老天在天角涂了层口红，不知道什么色号的，仔细看还挺美的。突然，岭正叫住了我，道：“都是为了我的下一代!”\n我一时间没反应过来，以为他在与别人对话，不想他似有深情地看着我，补充道：“所以，你要好好睡觉才行！”\n而后迷人之笑，怎么说呢？看着像在演戏一样，感觉这种桥段只有小说电视里才有，让我又懵又有些难为情，一时想不到什么好的词，只好顶着职业假笑示意“好的”。 “绘妹妹，”回寝室路上张君调侃道：“你要好好睡觉哦。”而后一阵哈哈大笑，我急忙想制止她，可越要这么做她就越要说，越说越开心。\n回宿舍后我细品了岭正的话，总感觉有什么意思在里头，但时间久了便不再放在心上。\n……\n后来张君不怎么提他，我倒是期待着张君说点关于他的什么，至于为什么这么想，我不敢究其原因，也不想问张君 ，只想着张君能和我说说，明明是些琐碎的事罢了，再次回忆，便不由自主地想起那些人，那些事。\n三个月后的一天，张君突然问我，还记得不得上次给你介绍的帅哥。我说，帅哥不记得了，只记得有个人说什么好好睡觉。随后聊的具体内容记不太清，依稀记得张君说，他转到了我们学校，而且在我们隔壁班。这算个惊喜吗……在我的生活里没那么多惊喜，也许眼睛会和惊喜反应，“生成”眼睛和平平无奇。\n分班后的一天，我去找张君，问她在哪个班。张君告诉我，他们班在一楼，离食堂最近。她还说，一般来说，学校的食堂都挺干净的，外面的不怎么卫生，可绘啊！我还是喜欢吃外面的，特别是小帅哥带来的。\n我说：“又是用美色挣来的吧！”\n张君听到后哈哈笑了，笑声爽朗，我也跟着笑了起来，和她总能这么开心，但是，笑过之后我却突然感觉心情有些沉重。因为在上个学期期末考试结束后，我看到她和另外一个男同学坐在靠窗的位置上，他们俩个正在讨论着什么。他们的讨论是那样的热烈和激情，这是我从未见到过的。这一刻，我不知为何渴望着融入他们。\n第二章 仲夏夜之星 张君看着楼道下，一个小巧的女孩正一步一步走来，她知道是谁，长舒了一口气，转身对着小峰说道，小峰，我好像有点喜欢上你了。小峰一时还转不过来，刚刚还在讨论高考的试题，现在怎么……小峰没说什么，故意移开视线看着试题，张君，又继续道：\n“可以牵牵我的手吗？一会儿，就一会儿。”张君抿了抿小嘴，“不说话就是默许。”张君不再犹豫，牵起了小峰的手。小峰面颊泛红，激动又开心，温暖的小手，好像柔软的云朵，微风拂过两腮，不经意让小峰忆起往事。他想：现在怎么也不想松开这个女孩的手了，因为这一天小峰已经等了很久很久了。\n四年前的一个夜晚，我打球准备回宿舍，在收拾时，看到张君一个人独自坐在长椅上，篮球场两排明亮的灯光照在她的身上，泛着光，影子投影到地面综错散乱，被拉成常常的弧线，我走了过去，夜晚的榕树下凉得让人想就地睡觉，有些疲惫的我边走边拉伸着身体。\n“唉，在这干嘛呢？”\n“哟，打球呐。”张君寻着熟悉声音，看向小峰，确认是他后，说道：“出来乘凉。”\n“切，女生宿舍不有风扇吗？”\n“你以为想吹就吹啊！那也是要看舍友滴……女生的世界，你个男生不懂。”\n小峰擦了擦头，看着地面道：\n“谁tm大晚上跑出来乘凉啊？现在又不是夏季。”\n“小峰，如果有个男生喜欢你……”张君长叹，又咽了咽口水，慵懒的说：“你们……”\n“什么？男的！那不搞基吗？”\n“呀，什么搞基啊，认真听我说嘛！”她继续道：“她还是你同学，你怎么办？”\n“拒绝啊……为什么？当然是因为我喜欢女孩子啦，而且我接受不了……如果吗？哪有什么如果，你这是假设，这样的场景和画面我敢都不敢想像，怎么你搞……” 张君插话道：“什么什么呀！好好说话好不好。”\n那天我想着要再次向张君表白，当时气氛尤为适宜，夜晚的操场很快人离影散，满天的星空捧着圆月，远远的传来葡萄架下的蟋蟀的奏鸣曲，好像拉小提琴一样，悠长而又慢慢地穿到我和张君这，操场的灯光还明着，铺洒一地，犹如海浪扑来，直冲张君的脚下，瞬间在身上如水浸透白纸般，我坐在长椅较暗的地方，一身好像穿着高雅的西服，一切都让我内心波涛汹涌。\n我们似乎同时说出了对方的名字，我有些不好意思，他亦如此，我便让他先说。\n“我被个女孩喜欢上了，她是我要好的朋友，看着小颗小颗的，纤弱又可爱，让我……不由自主产生保护她的心理，可是我不想因为这件事破坏我们的友谊……”\n聊了会，交谈中张君告诉了我那人的名字，知道后也有些震撼，也许那时候不知道什么是喜欢，什么是爱，所以我不能理解她们的关系和情愫。正说着，我们看到校警摸着电筒，四处照射，似个夜间丛林里的猎人，我们也结束了相关的话题。\n那后我渐渐的对她们之间的关系有些不自在起来，虽然如此，但我对张君的心却一直不变，对她仍存一丝丝希望，期待着有一天她回头，可以见到我还在原地等她归来，我无法忘记我与她们一同“出境”的尴尬处境，特别是虚假地做她男友，在喜欢她的人面前，把恋人的关系发挥到极致的事，我讨厌又害怕，犹如一场美梦，醒来却是肮脏的现实，噩梦般的现实。\n记得有一次我还因此谎称生病，停了一周的课，可我忘不掉张君，我依旧喜欢她，我想和她来一次真正的恋爱，不一定热烈浪漫，但一定真实难以忘怀。在高中时我就知道她其实不喜欢我，可我还是默默等待着，在漆黑的夜晚做个可怜的人。\n等我明白渐渐理解，和解这些事时，那已是许多年后的事了，张君也早已远嫁他乡，他乡的那颗星也一直在我可以看到的地方闪闪发光。\n第三章 剪不断，理还乱 苏绘走上楼梯，走廊传来张君的声音，他们讨论着今年高考各科试卷。\n我纳闷一个文科生，一个理科生的，有什么好讨论的？我知道此刻我是羡慕的，想想自己摸底考自己就是一个失败者，失败者，失败者……\n我苦涩地一笑，恰巧张君见状问道：“绘，怎么了？”\n我回过神，道：“没什么。”\n等我微微抬头——张君和小峰的手十指相扣，看着好像他们的手被牢牢焊死，原来刚刚的男孩是小峰，为什么，为什么，那背影，那声音完全是另外的人。对我是那样的尊敬，玩笑都开不起，而对张君却畅言所欲，小峰， 小峰……我的内心一声又一声，就像远山传来的回音。\n张君闻言大笑：“哈哈哈……你这个形象真好笑，对了告诉你哦，我和小峰确立关系了哦，今晚要不要庆祝一下下。”\n张君说的小峰，是我认识的人，那会还初中，我一直觉得小峰比较内向，又有点高冷，可现在看来它和张君的性格都比较随意，所以关系也建立得很快，现在都是情侣了。我和张君是从小认识的，可以说我们是死党，我总喜欢调戏她和她的堂弟云，和他们关系特别好，我觉得我是他们最好的朋友，所以总是会开开些无伤大雅的玩笑。\n“干嘛呢？开玩笑的，我和小峰没交往，”和小峰分开后，张君说了实话，可我当时并不相信，即使她说，有个人喜欢他，小峰为了避开她，他们就演演喽。\n“我说嘛！君姐怎么会那么快换男朋友嘛！”\n“啊？”张君看着我，愣了会儿，说道：“那不是。”随后我们鹅鹅地笑出声。\n后面我和张君又聊了几句，然后就各回了各自己的寝室，我推开寝室进去，一片死寂充斥着寝室，我坐在床边，呆呆地看着天花板，突然觉得心里一阵空落落，仿佛心底里丢失了一个什么东西，很难受很难受。\n张君，小峰和岭正分到了一个班，他们三个在班级里很低调，也不敢在学校里表露出他们三个的关系，毕竟那个班有些特殊，或许是不想引起别人的注意吧。不知道从什么时候开始自己躲在暗角默默地暗恋着岭正，对岭正的记忆自从分开后慢慢从脑海中消失，突然我想起，张君说的，我以后可能会是他的妻子，虽然我知道这是个假的概率，毕竟我和他还没到那一步，但心底里却不免升腾起一丝妄想，这些妄想也随着时间一天一天蒸发殆尽，为了不让这样的念头消失，我试着与他见面。我知道我配不上他，但是心底深处，却有些隐隐约约的期盼，期盼着有一天，我们能够在校园偶遇，在校园内，能够成为朋友，这样，我就能够时时刻刻，见证我和他在张君心目中的地位了。\n一晃一年的时间，转瞬即逝。\n我和张君、小峰、岭正他们的联系少之又少，除了偶尔见面聊聊，别的联系少之又少。\n我们似乎都各奔东西了。\n第四章 再忆江南曲 大一的一天晚上，我一个人躺在床上，想着和张君的点滴往事，我想起了我们初入江南高中时那个阳光开朗的张君，想起了那个总是喜欢逗我，却从来没有欺负我的云，想起了初中我第一次在学校的篮球场和小峰见面的那个早晨。\n初中篮球场。\n那一天天气格外炎热，有些受不了的直接不来，有些则虚弱地装一下，老师自然是信的，这样的天气搞不好真的会中暑呢。小峰注意班上的班花很久了，从军训那天开始，他就一直关注着她，报体育委员也是因为有她的名字，只可惜她没选上。这天，女子篮球组在练习，\n“唉！她身边老跟一个家伙”\n“什么家伙，人家有名字，叫苏绘。”\n“耶，你们认识？”小峰的同学手靠在他肩上，说道：“什么时候的事。”\n“唉，小学那会儿了，不过她是隔壁班的，她应该不记得我。”\n小峰看要到他们组训练了，顾不了那么多了，直接上前与班花搭话。\n我们第一次见面。小峰说：“如果你愿意当我的女朋友，我可以考虑带你进军篮球队。”当时张君愣了好一会，我也一样，这句话他是对张君说的，想想当时他是体育委员，我只不过是个连投球都不会，还硬要参加女子篮球队的家伙，自己真的傻得可怜。\n张君看了看绘，对她说，绘可以帮我去拿一下纸巾吗，在那边的树底下，谢谢。\n看着绘远去，张君提高了些声音，说道，你有那本事，我就答应。\n小峰一脸春风拂面，说道：“你说的，别反悔。”\n想到这我觉得那件事张君是刻意这么做的。\n第五章 终章 那时的我还是一个不谙世事的毛丫头，看着张君与小峰在一起，自己竟眼红了起来，那段时间一切的事情都只想着怎么和岭正在一起，我每天都在幻想着和他有朝一日可以成为男女朋友的画面，但是，一切的梦境都只是梦境而已，在现实里，我和他永远也不会在一起。想到那天鼓气勇气与岭正告白，却被拒绝的画面……眼泪不知怎的流出眼眶，打湿脸颊，黑夜抚摸着我，似乎在特意安慰，可我内心久久无法平静，久久无法入睡。\n翻来覆去怎么也是那美好而又难过的岁月。\n那天，我去学校图书馆借书，张君的书包落在图书馆里。张君让我在图书馆外面等一下，张君走了很久，我在图书馆外面站了好久好久，突然有人拍了我肩膀一下，我吓了一跳，猛地回头，见是云，我松了口气，拍了拍胸脯，责怪他道：“怎么走路一点声音都没有，吓死我了。”\n云微笑着，道：“我看你站在外面想事情想得很投入，所以就狠下心打扰你。”\n我问：“你怎么在这里？”\n云说：“我和朋友谈了点事儿，他们让我在这里等。”\n云的那些朋友都是高年级的学生，有男有女，看起来都不怎么好惹的样子，不用说也知道，云在这里肯定是认识不少人的，我心中不禁有些担忧，担心云在这里受到别人欺负。 我问：“你朋友都是些什么人啊？”\n云道：“是我以前的同学，现在都在这个学校里上学，我在这里认识不少人，以后有事儿，找我，我罩着你！”\n我道：“好啊，那我有事儿了再找你吧！”\n云说：“行！”\n云和我说的话很简单，但是，我知道他一定是一个善良的人。\n在外面久久不见张君出来，我的内心莫名有些难受，等待也许就是这样……\n想到这我才知道，那时的自己对张君是怎么样的感情，我就是只愿做信鸽脚下的信筒，即使有天会被丢弃，只要有一刻还在与她在一起，我所忍受的都是值得的，可我一直在她的庇护下，一步一步走向自己的未来，这种种美好而痛苦的记忆我永生难忘，这一生也不会再有。\n写于2021年6月\n",
    "description": "",
    "tags": [
      "校园",
      "爱情"
    ],
    "title": "君绘语",
    "uri": "/textbook/4.%E5%90%9B%E7%BB%98%E8%AF%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 校园",
    "uri": "/tags/%E6%A0%A1%E5%9B%AD/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\rgraph TD;\rsubgraph 主要人物\r白唐瑶 --\u003e|女儿| 白正恩\r白唐瑶 --\u003e|女儿| 唐淑清\r白唐瑶 --\u003e|姐姐| 白唐文\r白唐瑶 --\u003e|姐姐| 白唐灵\r白唐瑶 --\u003e|表妹| 白玉琴\r白唐瑶 --\u003e|女友| 莫长逍\rend\rsubgraph 女主角的亲戚\r白正恩 --\u003e|父亲| 白唐瑶\r唐淑清 --\u003e|母亲| 白唐瑶\r白唐文 --\u003e|弟弟| 白唐瑶\r白唐灵 --\u003e|妹妹| 白唐瑶\r白正中 --\u003e|堂叔| 白唐瑶\r白玉琴 --\u003e|堂妹| 白唐瑶\rend\rsubgraph 女主角的朋友\r洛翠翠 --\u003e|闺蜜| 白唐瑶\r零思思 --\u003e|闺蜜| 白唐瑶\r敦庞庞 --\u003e|好友| 白唐瑶\r豪盛 --\u003e|好友| 白唐瑶\rend\rsubgraph 女主角的同学\r王自福 --\u003e|同学| 白唐瑶\r图雅丹特 --\u003e|同学| 白唐瑶\r婉湘玲 --\u003e|同学| 白唐瑶\r马思雨 --\u003e|同学| 白唐瑶\rend\rsubgraph 男主角的亲戚\r莫天行 --\u003e|父亲| 莫长逍\r李婉清 --\u003e|母亲| 莫长逍\r莫长乐 --\u003e|弟弟| 莫长逍\r莫丽华 --\u003e|姑姑| 莫长逍\r莫文轩 --\u003e|表哥| 莫长逍\rend\rsubgraph 喜欢男主角的女性角色\r苏婉儿 --\u003e|情敌| 白唐瑶\r赵思琪 --\u003e|情敌| 白唐瑶\rend\rsubgraph 喜欢女主角的男性角色\r陈逸飞 --\u003e|情敌| 莫长逍\r周子墨 --\u003e|情敌| 莫长逍\rend\rsubgraph 情敌角色的亲戚\r苏婉清 --\u003e|姐姐| 苏婉儿\r赵思远 --\u003e|弟弟| 赵思琪\r陈逸翔 --\u003e|哥哥| 陈逸飞\r周小雅 --\u003e|表妹| 周子墨\rend\rsubgraph 情敌角色的朋友\r林雨柔 --\u003e|好友| 苏婉儿\r韩梅梅 --\u003e|好友| 赵思琪\r徐浩 --\u003e|好友| 陈逸飞\r张伟 --\u003e|好友| 周子墨\rend\rsubgraph 情敌角色的情敌\r刘晓晓 --\u003e|情敌| 苏婉儿\r刘晓晓 --\u003e|情敌| 赵思琪\r高远 --\u003e|情敌| 陈逸飞\r高远 --\u003e|情敌| 周子墨\rend\rsubgraph 情敌角色的情敌的亲戚和朋友\r刘晓梦 --\u003e|表姐| 刘晓晓\r高强 --\u003e|叔叔| 高远\r钱多多 --\u003e|好友| 刘晓晓\r孙雷 --\u003e|好友| 高远\rend“时间的真的存在吗？”\n我很意外王妈为什么会问我这样的问题，王妈小时候家境不好，没有机会上学，她对我说过，去学校上学的次数十个手指都数得过来。王妈的问题是显而易见的——时间是存在的，我想这么说，但还是如此回答了她：“王妈您怎么突然问我这个？” “没有嘛，你们读书嘛！”她啊了一声，好像对我的答案有些失望，说道：“就想问问你，看你懂不懂。”\n“时间是存在的，你看每天时间都在走，太阳升起，太阳西落……”我有些难受的说道，不知道为什么自己不知不觉的也编不下去了，觉得这个话题是不是太哲学了呢？\n“从前呢，天上有个管理太阳升起，落下的神仙，人们管他叫乍，本来人死后去的地方也是有太阳的，后来就没有了，说是有一天乍在水边叫太阳下山的时候，看到一个老奶奶在水边哭，他就上去问，你怎么在这哭得这么伤心。那个老奶奶回答道，我不想离开我的丈夫，因为他一个人生活会很辛苦。这个时候乍才知道这个老奶奶是一个鬼魂，乍听完说，他在地上活得好好的，你应该高兴。老奶奶还在哭，边哭边抹着泪说，要是你每天让太阳晚点出来，晚点下山，人们就不会死那么早，我也会多陪陪自己的丈夫。乍听完那个老奶奶说完，慢慢的坐下来，跟老奶奶说，每个人心里都有一个太阳，如果把这个太阳丢掉，你就不会再说那样的话，你也就不会那么伤心了。说完乍把太阳收了回去就走了，从那以后死去的人生活的地方再也没有太阳，心里也没有了。”\n听王妈娓娓道来的故事，我内心五味杂陈，我顺意点了点头，早已把王妈刚才的问题丢掉，后来又调皮的和王妈吐槽这个故事，为什么老奶奶不知道一天时间其实是一样的，即使白天变久了，一天还是二十四小时！王妈也只是笑笑，没在说什么，继续自己手里的针线活。\n暑假漫长而又炎热，特别是在东州这一带地方，一天不开空调自己无法在房间里待下去，外面也是闷热，空气划过脸脖，抽离着细小的汗珠和油脂，黏着皮肤的汗珠让人不禁想抓一抓，今天的太阳也是同样的毒辣，闷热的大地烘烤着水面上的水葫芦，可水葫芦似乎未伤分毫，到是蒸熟了一旁的芭蕉——龇牙咧嘴的。\n王妈家住在工厂旁不远处，每每早上六七点和晚上十或十一点就会看到许多打工人出现在小区楼下，他们总是拖着疲惫的身体上班，拖着疲惫的身体下班，在学校我总能看到一些人精神饱满的过着每一天，过着充裕的生活，想到这我不禁感叹：还是待在学校好啊！\n自己来东州游玩也有些许天了，闲下来的时候总要睡午觉，因为住在工厂旁边，午觉的时候总能听到远处工厂传来的“轰隆”声，不是被惊醒，就是与梦境“重影”，构建着一些奇怪的梦境，前些天到处跑，也许是玩的太疯了，现在对外面的美食，风景一点兴趣都没有，只想静静地躺下，午觉醒后在阳台看到王妈在做针线活，于是便上前与她聊了会儿天，关于王妈提出的时间是否存在这一话题，我想大部分人都会回答“是的”吧，想想拿掉后人生活的一切岂不是都失去了本有的意义，不知道什么时候醒，那个点该吃饭，出去玩多久等等，涉及到时间的话题太多，没了时间概念的世界会很无聊的吧！\n“王妈，我爸说我们明天就回家了，您要和我们回宁云吗？”我说道：“去我家玩几天呗！” “明天就走了？”王妈停住了手里的针线活看着我问道。\n“对啊，我爸说出来太久，没钱了。”后面一句是自己对父亲的调侃。\n“哎，你爸打不准蒙你的呐！他呀哪是没钱，估计也是像你玩累了，”她一边朝着我笑，一边继续自己的针线活——转而问道，“你爸还是在你外公那个木厂吗？”\n“早就不在了，几个月前的事情了。”\n“你爸也是不容易，”她叹气道，我回答“也是”后，她继续道：“赘婿呢就是这样了，做什么都得看丈母娘家的脸色，你妈妈家也是呀……想想以前我从村里出来的时候，你妈妈家来的礼就是最贵的，那玩样现在还在我那木箱里呢？” “是个什么东西呀，王妈？”\n“是个织布机。”\n“织布机是那个时候最贵的吗？”\n“你不知道，那个时候我们苗家的姑娘衣服都是自己做的，街上也有卖，但穷人家哪买得起哦,织布机可以做嫁妆，可以做新年衣服……”\n“那岂不是每家都得有才行？不然他们就没新衣服了。”\n“是喽，是喽！”王妈笑着回答道：“那时候有的人来件衣服，来套棉被，还有的是直接给钱的……那时候家家都是得有个织布机，对我们苗族人来说要有的，有嘛都好喔，没有嘛叫人做都要做出来，所以织布机一对比起来就不一样了，你妈妈送我那件做得很好，听说是一个很厉害的木匠做的。”\n“那等你忙完，带我去看看呗。”我倒要看看是什么高档货，王妈这么多年还留着。\n从阳台往里走是大厅，大厅左边有两个房间，两个房子之间隔着上二层楼的楼梯，楼梯下有一道木门通往地下室，打开木门，随着一声喀吱的声音感觉自己走入封存已久的宝库，仓库楼梯扶手是钢焊接不久，下楼梯时能闻到焊接时留下的味道，其间夹杂着木质发霉的味道，沿着台阶往下走，右边挂着一些画和幼儿园、小学的奖状，奖状估计是大厅那边放不下而移到了这里的，奖状上写有王思芳和王季远姐弟两的，还有那个我熟悉的名字杨——白唐，在这边。王妈叫住了我，示意我往下走，我小跑下了楼梯，右拐再下一次楼梯就到了地下室的仓库，地下室就在大厅的下面，被一堵墙分成两半，另一半则是车库，走到楼下刚才木质发霉的味道很快就消散了，地下室灰尘很少，打扫的也很干净，从楼梯下来右手边堆积着许多破旧的书籍，在红色的书架上高高堆叠，远远看着给人一种难以接近的感觉，下边堆积的是一些工具和木质器件，洋枪的枪柄，木凳子，木长椅，甑子，锄头镰刀柄等等，还有很多我都不认识，在靠近车库的右下角就放着织布机，由于常年使用有些地方光滑亮泽，好像刚被涂上树脂漆一样，又好像一个精神抖擞的老奶奶。织布机一共有两台，王妈告诉我小的那一台是后来王爷爷自己做的，属于是织布机的改小版本，而小织布机旁边就是父母送王妈的织布机，现在去网上搜也能找到这种老款的木质织布机，唯一不同的是这台留存着王妈从出嫁到现在的种种回忆，梭子上的光泽，打纬中间因每次缝制衣服都会拉一下而有所磨损，这些也许就是勾起记忆的痕迹吧！雨落红花谢了春，莫熵增！日月颠倒长河归，同与故人醉。织布机上贴着贴纸，贴纸上写着一首这样的诗歌，虽我字字都认识，但古诗赏析什么的绝非我强项。\n“王妈，这首诗是谁写的？”\n“那里……哦，说不定是季远他们胡闹贴上去的，”她小心的撕下贴纸，又小声的骂了季远一通，接着说：“这就是那台织布机，你要是想学王妈教你，打不准那天自己给自己做嫁衣呢！”\n“我吗？还是算了，我针线活也就那样，平时能缝缝补补自己的衣服就好了，至于做嫁衣……算了算了。”\n“多会一样对自己也好的，但是现在人家都用机器弄了，什么衣服都可以弄出来，所以你们这群小鬼把老祖宗的东西都忘干净了。”\n“新时代了嘛，不一样了王妈！”我尬笑的说道。\n王妈笑了笑，似乎准备给我介绍什么，突然手机响了起来，王妈出去接了电话，我便独自一人看着织布机，怎么看也看不出它的高档所在，以及工艺精湛，或许我是我对这方面了解太少，想到这真为自己堪忧，自己到底该了解，该知道什么，越是深入思考这个问题自己就会陷入“无解”的死循环。\n看到刚才的贴纸被王妈丢到了地上，我半蹲拾起贴纸，心里又默默念了一遍，王妈家会写诗的人，除了姐弟两还有谁呢，他吗，可他的语文水平不咋地呢，要写出诗来——一万个不可能！估计是在哪里摘抄的。我起身去看了上边的书籍，一些幼儿园到高中的课本七七八八的叠堆在一起，地上放着各个科目的习题试卷，还有一些配套资料，看到这些我也不禁想起自己的初中生活，想不到这么快就初中毕业了，不论是美好的，还是难过的事就这么过去，一去不复返了，我有时候会不经意间想起某个人，某件事，即使令人难过，那些画面还是会不间断的脑海里浮现，说“忘记那些痛苦难过的事，这些都过去了”的人一定是自欺欺人吧!我想恰恰是这些痛苦难过的事难以忘记，让我们学会珍惜现在，珍惜现在的每一天。\n写于2023年7月\n第一章：遗物中的时光之谜 白唐在整理外祖母的遗物时，意外发现了一块古老的手表和一本泛黄的日记。日记中记载了家族成员曾经进行的一项关于时间的实验，以及实验带来的灾难性后果。这块手表不仅是一件珍贵的传家宝，似乎还隐藏着不可思议的力量。白唐对手表的起源和能力产生了浓厚的兴趣，决定揭开这个秘密。\n第二章：校园里的时空传说 白唐和莫长逍是学校探险俱乐部的活跃分子。一天，他们听说了一个关于学校废弃实验室的神秘传说，据说那里隐藏着一台能够操控时间的机器。好奇心驱使下，在一次探险活动中，他们找到了这个秘密实验室的入口，开启了一场未知的冒险。\n第三章：时光机的觉醒 进入实验室后，两人被眼前复杂的机械装置震撼了。这台装置上刻有爱因斯坦相对论公式，暗示着它与双生子悖论之间的联系。出于好奇，白唐按下了启动按钮，瞬间，整个房间充满了奇异的光芒，仿佛连空气都开始震动起来。\n第四章：扭曲的时间线 随着装置的激活，周围环境出现了异常变化。时间在他们面前变得不稳定，二人经历了多次时间跳跃，目睹了一些物品凭空消失又突然出现于另一个时刻。这种超自然现象让他们意识到自己可能触及到了某种宇宙真理。\n第五章：薛定谔的迷宫 为了验证手表是否真的具有改变现实的能力，白唐和莫长逍设计了一个类似“薛定谔的猫”的思想实验。然而，当实验结果出乎意料地证实了他们的猜想时，两人却陷入了更深的困惑之中——如果一切皆有可能，那么什么才是真实？\n第六章：熵增的警示 实验之后，白唐开始深入研究熵增理论与时间箭头的概念，逐渐明白到每一次对过去或未来的干预都会导致不可预测的变化。她担心自己的行为可能会对整个时间线造成不可逆转的影响，而这一切似乎都与那块神秘的手表息息相关。\n第七章：拉普拉斯的预言 在探索过程中，一个名为“拉普拉斯妖”的存在浮出水面，它似乎能预知未来并试图阻止白唐等人继续挖掘真相。面对这样一个强大的敌人，两人心中既充满恐惧也满怀斗志。\n第八章：彭加莱的轮回 一次不小心触发了时间循环机制，让白唐和莫长逍陷入了无尽重复的一天之中。只有解开背后隐藏的秘密才能打破这一诅咒，否则他们将永远困在这个无限循环里。\n第九章：家族秘史 随着调查深入，白唐发现自己曾祖父也曾涉足过类似的领域，并因此神秘失踪。这段尘封已久的历史或许正是解开当前困境的关键所在。\n第十章：心结难解 共同经历的危险加深了白唐与莫长逍之间的情感纽带，但也使得彼此间的关系变得更加复杂微妙。如何在保护对方的同时追求真相成为摆在他们面前的一大难题。\n第十一章：守护者的使命 意识到手中掌握的力量一旦落入恶人之手将带来巨大灾难，白唐和莫长逍决定肩负起守护者的重任。通过不断学习与实践，他们希望能够更好地控制这份力量，并阻止其被滥用。\n第十二章：抉择时刻 面对是否继续探寻时间奥秘的重大决策，白唐内心十分挣扎。继续前行意味着要承担更大的风险；放弃则意味着回归平凡但安全的生活。无论选择哪条路，都将深刻影响她及身边人的命运轨迹。\n第十三章：永恒之旅 经过无数挑战与考验，最终白唐和莫长逍不仅解开了所有谜团，更明白了自身存在的意义。准备好迎接新旅程的二人，将以更加坚定的步伐迈向未知，勇敢面对时间赋予的一切可能。\n",
    "description": "",
    "tags": "悬疑",
    "title": "白唐战绛",
    "uri": "/textbook/2.%E7%99%BD%E5%94%90%E6%88%98%E7%BB%9B/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 悬疑",
    "uri": "/tags/%E6%82%AC%E7%96%91/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r牛村与花村仅隔一片红树林，深秋里，满山的红叶铺天盖地，牛村的村尾是个好地方，常聚着城里来的人，就是离阿牛家远了些。\n“嘿！ 阿牛。你要老婆不……不，只要你开……开……金口……”阿牛理着枯萎的草，寻声一看，是那跑腿的阿光，阿光无力地扶着杆，面红耳赤。\n阿牛生硬地答道：“老婆？不要。”\n阿光一身酒气，吐字不清，阿牛手头又忙着，便不再想理他，正要离开，不想阿光一把扯住他，断断续续的说道：“村尾……有靓妹哩！啊哈……看看去，保你……保你……爱。”\n阿牛无奈道：“行了行了，我嘚去花村，忙着呢！”便离开了，而阿光还在牛槽旁自言自语，暗自欢喜着什么。\n乌云渐渐压向红树林，此刻花村也许已倾盆大雨了吧，想到这阿牛便想回家拿伞，正要离开，一声声熟悉的笑声拉住了他的步子，寻声向桥下俯视，那寸头高鼻梁，小眼尖脸蛋，黝黑黄皮肤，臂粗高大个，影子印于桥头，此景定格于此时。\n那熟悉的背影，那熟悉的声音，没错，她就是阿牛的青梅竹马——阿花，还有从小到大一直欺负他的阿狗。\n“哎呀，你轻点……”说话的是阿花，她往前，阿光紧挨着，她手一拣，他手一搭；她手一捻，他手一抓。桥下，一男一女，你前我后，我左你右，动作形如流水，相当娴熟，此刻阿花的声音传到安流这儿，都是嗲里嗲气，而阿光的举止在阿牛眼里，那就是讥笑。\n阿牛气得肝疼，怒骂道：“靠！这厮的真扫兴，呵。”把手里将给未来岳父大人的酒摔了一地，扭头不知将去哪里。一路上阿牛又气，又百思不得其解，他不明白，从小到大，阿花便是自己的玩伴，实打实的青梅竹马，渐渐的她成了阿牛的中意人，阿牛追阿花这些年也没有三心二意，她哭，阿牛安慰；她闹，阿牛捧哄；她病，阿牛照顾。为给她买生日礼物，阿牛千里迢迢，去城里挑玩偶，对于阿牛而言，他愿为阿花上刀山下火海，拼死拼命也要护着他，可是现在她却和别的男人在一起，还是自己憎恨，厌恶的男人。\n阿花听到远处山林“哗哗”作响，又看了天气，便道：“哎，阿狗，要下雨了，咱们回家吧！说不准阿牛哥已经到花村了。”\n“唉！花妹妹，”阿狗忙着收东西，向阿花追去，道：“你别急嘛。”又嘀咕了句，道：”整日阿牛哥，阿牛哥，你眼里就只有他吗？”\n阿花在前边督促道：“狗子，你快点呀，雨要来了。”\n“来了。”\n自那后，阿牛觉得阿花已不再喜欢自己，但自己终又放不下她，可阿牛越想头脑子越乱，越想心里越烦，不久他便同阿光去了村尾。\n那日大雨唏哩哗啦地下后，花村口也不见阿牛哥的踪影，阿花在自家门口，盼着盼着，盼了个寂寞。突然眼前一个身影，“阿牛哥——”她叫道，那人回头——咦！是阿狗，阿狗见了阿花大喜，道：“花……”还没说妹妹，阿花已关了门。阿花爸见她一脸愁，问问咋啦！她唉声叹气，她爸看着庭院外道：“你这娃儿……阿牛怕是这段都不来喽！”\n阿花疑问道：“不来，为啥子嘛！”\n阿花爸笑眯眯的道：“年轻人的那些事我哪懂得嘛！听隔壁张姨说，那天看到阿牛把酒摔在了桥头那哩。”\n阿花愣了一愣，这才想：难不成……呀！阿花起身回了房，不一会儿便带门出去了。\n她爸在院里喊道：“天快黑了，哪去……不吃饭啊！”\n“不吃了，晚点会回来。”回声渐渐从远处传来，此时灯火已经渐渐亮起了。\n一路上，阿花的回忆伴着喘气声，一段一段的在脑子里浮现。那天，“哎呀，你轻点，别把鱼给吓跑了。”阿花说道， 阿狗往阿花那靠了一靠说：“你现在这声音不就把他给吓跑了吗。”阿花无语反驳，一把推开了阿狗。她手一拣，阿狗手一搭，阿华厌恶地瞪了他眼；她手一捻，阿狗手一抓，阿花像抓狂的狒狒一样，怒斥道：“狗子，我告诉你，你最好给我老实点……男女授受亲，你不懂吗！”阿狗摸着后脑勺表示明白。可此景在按钮眼里，似乎是“别样”的风景。\n然后一边跑心里还一边默念：二牛哥不是你想的那样，不是你看到的那样……你……你不要……\n炎炎夏日，一天，阿牛上山背马草，午时正要回阿光家，在田道上遇到几个小伙子在偷窥田间的姑娘，路过时，听到他们议论那姑娘，且尽说些低下话，阿牛听不惯，这烦还在心头，二话不说，上去就是一拳，他们还没反应过来，阿牛又一勾拳，打得那些人七窍流血，这才停手。\n姑娘见有动静，便前来阻止，阿牛呵斥道：“再见到你们说姑娘坏话，我就捆你们去犁田，打断你们的狗腿子……”\n那些人见不妙，便纷纷离开。\n“干嘛打他们……”\n说话的正是田头头的姑娘——瑶妹，蓬松刘海，大麻花长辫，玉颜黛眉，肤白胜雪，水汪汪大眼，娇小玲珑，袅娜丰满，蔚蓝花衣，青黑长裤——真是乡间仙女。阿牛一辈子还真没见过这样的美女人，若不是心里住着阿花，或许此刻他内心早已小鹿也乱撞。他脸颊泛红又低了头。\n突然严肃道：“那些混蛋偷看你还说你坏话，我……我听不惯低下的话，就揍了他们。”\n瑶妹微微笑，绽出两个酒窝，道：“听不惯？是讨厌那样的人吧！”\n“讨厌？”阿牛嘻嘻道：“姑娘看不是本地人，是外地来的吧！”\n瑶妹答道：“不是噢！我的家……老家就在这的。”\n阿牛接过瑶妹，端来的茶水望着瑶妹 ……\n说着，瑶妹便要阿牛回家喝口茶，以表感谢，阿牛也不好回拒，便去了。\n阿花那日去阿牛村找阿牛，没找着，探到阿牛已去了村尾，这天才早早从家里匆匆赶来，正午烈日灼心，阿花看到村尾就在半山腰上，这才为自己捏了把汗，心中也不由得欣喜了些。\n“阿牛哥，你……你……”阿花盘扶在村口门柱上，道：“你这个负心汉啊，我以为你不来家吃饭，是咱们有误会了，不想你是有别的女人了。”\n瑶妹一边揕着茶水，一边道：“还不知道你的名字呢？”\n阿牛：“哦，我叫阿牛。”\n瑶妹迟疑了会儿，说：“是阿牛村的牛哥哥吗？”\n阿牛心一暖，笑咪咪道：“是的，牛村就只有我一个叫阿牛。”\n“我刚从城里回来，真想去村里看看红叶林。”瑶妹看着村外，一面期待地道：“还有去花村划竹排……真的好想你去呢。”\n“这离村里也不是很远，有时间你可以去看看，红叶林，花……”阿牛愣了一会儿才道：“花村那条江也很漂亮的……”\n瑶妹看了看阿牛哥笑了笑，端茶水递给了阿牛哥。\n他正要接过茶水，不想一阵“阿牛哥”，让一下他停住的手。\n他一看——阿花。阿花边走边说，道：\n“阿牛哥，你……你……”\n阿花不小心摔倒在地，叫喊道：“你这个负心汉啊，我以为你不来家吃饭，是咱们那个误会，不想你是有别的女人了。”接着就是一阵哭。\n阿牛急忙跑去扶阿花，那黄油脸，黏着土，蓬乱发，携着泥，小眼肿鼻，淡须大嘴，红色大花衣，黑色大长裤，无不散发着咸味，那猪腩大粗腿，墩墩似柱肚， 瑶妹见了大惊，但又觉得没有哪里不适。\n阿牛正要扶阿花，不想一只手把他推开，那人道：“走开！你个负心汉，枉费花妹妹对你一片痴情。”\n瑶妹对那人骂道：“哥，你干嘛推他……阿牛哥，你没事吧！”\n阿花见到此景怒气冲天，立马起身，阿狗担心道：“唉！花妹妹……”\n瑶妹一边扶起阿牛 ，一边询问他，没事吧，阿牛道：“阿花你怎么来。”阿花看到瑶妹扶着阿牛，欲说的因果一之间烟消云散，不经意间泪流满面，她哭着说 ：“阿牛你口口声声说喜欢我，可你离开就是为了见……见这样的女孩。”\n瑶妹连忙解释：“花姐姐，我想这里面有什么误会。阿牛哥他……”\n“住口！死厚脸皮你个婆娘，”阿花口吐碎沫怒斥道：“牛哥……那么喜欢我，你为什么要抢走他，你个毒辣女……”\n瑶妹一脸委屈，说不出什么话来。\n那流氓出来打断道：“阿花你够了！这是咱俩的事，跟她没关系。”\n阿狗道：“啊，你又看不出啊，你是这样的人，脚踏两条船胆够肥的呀，我看你对阿花好是为了他家那几亩地吧，唉，话都说到这份上了，前些年他娘死也是跟这有关的吧”\n阿牛大怒道：“你不乱说，行吗，没这回事，我对阿花好真心实意，不是图他家那几亩地。”\n阿狗道：“呵呵，谁知道呢，人心难测，况且你现在对阿花移情别恋，呵我看你就不是个好东西，你就是馋他身子下贱！”\n听到这阿牛更怒了，他道：“你说什么……”正说着，阿牛正想给他一拳，不想这个时候，阿花一脚，阿狗伏倒在地，\n阿花大叫道：“放你娘狗屁，阿牛哥对我怎么样？用不着你左一个右一个。”\n阿花转回头，对着阿牛说道：“阿牛哥，我一直觉得那天在桥上那件事是个误会，但是……”\n阿狗一听到桥上，立马机灵了起来，抢在阿花前说道：“哦！我终于明白了，那天你摔酒在桥上是故意的吧，你就是想趁这个机会把阿花给甩了，听说那天不久，你就和阿光去了阿光家，阿光的姐姐一直中意你，这全村人都知道……呵！阿牛你够狠啊！”\n阿花听了，声带似乎打了结，望向阿狗。\n阿牛气头上来，便一拳打在了阿狗脸上，他两在地上狰狞不休，围观者左右难劝，突然，阿花大吼道：“行了！”一时间地上的他俩也停住了手。\n阿花对着阿牛道：“我一直以为那天在桥头上的是个误会，但现在我觉得这确实不是个误会，你所看到的都是真的。阿狗对我比你好多了。”\n说完阿花哭着跑回了村，阿牛坐在地上沉默了很久很久。\n（上篇完）\n写于2020年\n",
    "description": "",
    "tags": [
      "爱情",
      "民风"
    ],
    "title": "阿牛和阿花的爱情故事",
    "uri": "/textbook/1.%E9%98%BF%E7%89%9B%E9%98%BF%E8%8A%B1/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 民风",
    "uri": "/tags/%E6%B0%91%E9%A3%8E/"
  },
  {
    "breadcrumb": "Maloudown \u003e 二、小 说",
    "content": "\r第一章 序 火车站往东，沿着才华路步行约十分钟，便能抵达衡岭财经学院。这条路王肖一年会走五六次——多半是回家或返校。每当他踏上这条熟悉的道路，心中总是五味杂陈。两旁的行道树在微风中轻轻摇曳，仿佛在诉说着过往的故事。路灯洒下柔和的光芒，照亮了他的脚步，也映照出他内心的复杂情绪。\n他的理想大学是南国大学，虽然最终与之擦肩而过，但南国大学也在衡岭这座城市里。每当想到这一点，王肖的心中便多了一丝慰藉。尽管未能如愿进入梦寐以求的学府，但他依然觉得，能够在同一座城市继续学业，也是一种不错的选择。毕竟，这里依旧承载着他对未来的无限憧憬和希望。\n夜幕降临，昏黄的路灯光晕洒在空旷的街道上，给这条熟悉的路增添了几分温暖。王肖背着书包，脚步匆匆地走在路上，心中既有对未来的憧憬，也有对现实的无奈。他一直梦想着进入南国大学，但命运似乎另有安排。不过，能在同一座城市继续学业，也算是一种安慰吧。\n回到宿舍，舍友们正围坐在桌前聊天。看到王肖进来，舍友小杰立刻问道：“王肖，你参加社团了吗？要不要来我们财经社团？”\n“话说王肖你参加什么社团了吗？”舍长小声问道，语气中带着一丝好奇。\n王肖放下手中的游戏机，抬头看了看舍友们，眼神有些迷茫。“农户养殖协会。”他生硬地说道。大伙都没听清，于是他又重复了一遍：“农户养殖协会。”\n这句话引得另一位舍友小李讥笑道：“还得是你啊，这才是我们水产品专业该去的地方。”\n“平时都干些什么？”小杰认真地问道。\n王肖听到这个问题，显得有些不耐烦，“我怎么知道，加了个会员就不见动静了。”他回答道，随即又继续玩起了游戏。过了一会儿，他补充道：“好像要当干事这些才会有活干，我嘛，就是去混学分的。”\n宿舍里一阵沉默，只有键盘敲击的声音和窗外偶尔传来的车流声。这时，一向寡言的何天宇笑了笑，试图缓解尴尬的气氛。然而，这个笑容却引起了大家的好奇心，他们开始讨论起何天宇为什么笑。\n王肖却不再想接收任何信息，对于这种场面他已经痛恨自己很多次了。他感到一种深深的无力感，仿佛无论怎么努力，都无法融入这个群体。他低下头，继续沉浸在自己的游戏中，希望借此逃避现实中的困扰。\n晚饭过后，王肖独自一人漫步在热闹的商业街上。他点了一杯烤奶，又买了一份炸鸡，边走边吃是他的习惯。果然，当他走到宿舍楼下时，手中仅剩半杯烤奶。今晚没有课，舍友们都在宿舍里打游戏，王肖也不例外。为了冲击王者段位，他打算拼一晚。他已经做好了通宵奋战的准备。\n夜色渐浓，白云缓缓擦拭着月亮，月光也渐渐变得皎洁明亮。在学校能听到公鸡打鸣是件难得的事，但对王肖来说，这却是习以为常的声音。有时候，熬夜到四五点，困意仿佛被钉在大脑中，伴随着疼痛，然后与似乎垂至暮年的心肝一起迎接那抹刺痛双眼的朝阳。\n第二天清晨，王肖早早起床洗漱，然后安安静静地离开宿舍，前往校园那片似乎要撑破天际的松林。盛夏遗留下来的鸟鸣声此起彼伏，还有新闻广播专业同学们清亮的嗓音，一切听起来如此动听，宛若圣洁的教堂。只是，他的教堂与众不同。\n离上课还有十几分钟，他起身拎包往教学楼走去。然而，当他走进教室时，发现里面空无一人。王肖心中闪过一丝疑惑：“大家都这么懒吗？就我一个先到，不会吧？”他不想表露这份心情，但洋溢在脸上的微笑却出卖了他的真实感受。紧接着，他开始感到不安，已经快上课了，一个人也没有。他掏出手机看了看宿舍群——一片死寂。\n“你们知道教室在哪吗？”这则消息在他指尖乱窜，几乎快要隔空点在键盘上。他犹豫了一下，不知道什么样的勇气才能让这样的消息同时背负希望与耻辱。想到发出去后可能会遭到舍友的嘲笑，王肖最终还是作罢。\n就在他纠结之际，一位女同学推门而入，提醒道：“同学，这间教室被征用了！”\n王肖应了一声，快速离开了教室。走到楼梯口，他再次查看班级群，才发现昨晚有一条消息通知教室改了。顿时，王肖的心情跌落谷底，摔得很痛。\n一天中午。\n“又打包？！”何天宇推开门，惊讶地说道，“这小子，空调也不开。”\n“是啊！”王肖小声应道，似乎是在自言自语，“不是很冷。”\n“以前校运会没见这么冷的。”一位舍友插话道。\n“昨晚又到几点啊？”另一位舍友问道，目光投向王肖。\n“两点左右吧。”王肖知道问的是他。\n“我昨晚上厕所还看见他在玩，三点多呢！”何天宇补充道，“小心点，小子，身体撑不住的时候才知道错。”听到这话，王肖心里微微一颤。熬夜对他来说，从来不看时间，只看身体能坚持多久。\n“妈的，你们知道吗！我们学校实验楼一楼男女厕所一样，上次我去上厕所，出来一个女生，吓我一跳。”何天宇突然转换话题。\n“我靠，真的假的……那哪个是女厕呢？”一位舍友好奇地问道。\n“谁知道，反正我以后不去了。”何天宇边调空调边说。\n……\n晚饭过后，王肖去剪头发时发现自己的发量比以前少了很多。看来最近的担忧是对的。上次献血时，医生告诉他肺部可能感染了，希望他能尽早去医院检查。这件事这次才真正放在他心上。\n秋去冬来，远看青山戴着白云草帽，不由让人觉得冬天已经来临。\n“喂，能听到吗？”电话那头传来父亲的声音。听到这边应了一声，那边接着问道：“医生怎么说？”\n“肺部感染，还有胆红素过高，叫我过几天再去检查。”王肖回答。\n“嗯，那你一定要去做检查，务必把病治好。钱还够不够啊？”\n“没多少了。”\n“我待会微信转你，叫你妈妈过去看看你吧……”\n“不用了，爸！”王肖打断道，“那样太麻烦……阿……姨了”他从心底里不愿意被一个外来人可怜。父亲批评了几句后，他挂断电话，扯了扯帽子，往公交站走去。\n上周，王肖去医院做了检查，疑似患了乙肝病毒，但具体结果还需进一步确认。医生让他不要过于担心，注意休息。走出医院的他不敢把这个消息告诉舍友，害怕传染给他们。仿佛这个病能否患上，能否真的传染，全由他说了算。\n从学校大门直走是学校的图书馆，图书馆面朝东方，其后面是一片松林。穿过松林就到了学校的教学楼，为迎接八十年校庆，教学楼也翻新了，远远可以闻到涂漆的味道。早上的专业课还没有结束，王肖穿过人群，上楼赶往教室，终于赶上了三四节课。进门后，他发现后排早早坐满了人，唯独前排只有寥寥几人。王肖默默地坐在了黑板前面，低着头听完了上午的课。\n下课后，等所有人都离开后，他才慢慢起身离开教室。现在食堂一定挤满了人，他朝着图书馆走去，步伐渐渐加快。在图书馆里找了十几分钟的书籍，始终没有抽出一本。就这样不知道过了多久，他从海量书籍中借了几本小说，离开了图书馆。从图书馆往右走，经过一片桃林，再穿过一条小街，就到了南苑。此时已打铃睡觉，路上的人少之又少。一层喜悦蒙上了一层凄凉，王肖走进食堂，安静地坐在角落吃完了螺蛳粉，便去教学楼打盹了。\n周五下午，王肖顶着一顶鸭舌帽往南苑走去。上台阶时风太大，刮走了他的帽子，他顿时感觉头顶一阵凉意，但并没有理会，急忙去捡起自己的帽子。最近掉发太厉害，而且自己也不想剃寸头，于是先买个帽子遮遮丑。从楼梯下来是一楼的饭堂，饭堂两侧开满鲜花，看到王肖不顾一切的样子，花儿仿佛笑得前仰后合。风开始大声高歌，远远可以看见一丝丝细发在空中欢快地舞动，好像人群中有个鹤立鸡群、金光闪闪的人物出现了。同学们都遮头避面，狂风似乎在大声高歌，声音能震碎金光一样。大家都看到了站立中央的王肖，他像一只瘦弱的猴子——抓耳挠腮，四处寻找的动作不禁惹人发笑。\n一位女同学捡起他的帽子，递给了他。王肖看见她面容平静得吓人，好像什么吓人的表情刚被埋葬一样。他接过帽子，那一瞬间那害怕的嘴脸破土而出——好像死人复活一样。接着他看清了在场所有人的面容，他习惯性地低声说了声“谢谢”，然后带上帽子含着泪水逃离了这个让他感到尴尬的现场。远远还可以听见他们与狂风的高歌。\n王肖跑到了实验楼一楼，差点进错了厕所。他慢慢摘下自己的帽子，目光看向镜子中的自己。尖形的头型两侧残存着一处又一处头发，真似马儿啃过的一样。地中海一条条可以数清楚的毛发，好像自身有千斤重，摇摇欲坠。细细看看吧——那浓眉大眼，臃肿的大鼻，小嘴肥厚的下颌，一切都显得那么不搭。慢慢地，他自己也笑了起来，泪水随着从眼角流出，渗入味蕾，诉说着自身奇怪的委屈。\n一天早上，王肖向班主任请了假，理由是自己要外出就医。但班主任告诉他小病就在校医室看，大病得有校医室的检查证明。王肖心想，自己的乙肝学校也查不出什么吧！而且他也不愿意和老师说这件事。于是下午，他在办公室又编了一个理由——外出考驾照。老师问：“下午的课是专业课还是公选课？”王肖诚实地说：“是专业课。”老师严厉地告诉他下次不许挑专业课外出，王肖点了点头，恨不得马上离开这个地方。那一刻，他觉得自己不属于这里，这里的一切看起来都那么讨厌。自己的门没有紧闭，为什么没人前来敲门？\n离开学校后，王肖去医院做了检查，然后给父亲打了电话说明了自己的情况。挂断电话后，他不自觉地走到了国际大厦。大厦旁边有个广告牌，上面印着“乌鸡山欢迎您的攀登！”几个大字。想来也不想回学校，不如去爬山放松一下吧！\n王肖扯了扯帽子，往公交站走去，消失在街道的人海里。\n不久，公交车到达了乌鸡山旅游景点。因为没带学生证，王肖没办法享受学生价，不得不付高额的原价。乘坐游览车抵达山脚下后，王肖没有多想便开始了登山。历经几个小时，他终于到达了乌鸡山山顶。乌鸡山是衡岭最高的山峰，一千八百八十八米的海拔让王肖觉得此刻自己也有杜甫“一览众山小”的心境。由于爬山前没准备食物，等到山顶时，王肖早已饥肠辘辘。无奈之下，他找了一处没人的地方休息，随后竟然睡了起来。在他的家乡流传着这样的说法：人在野外犯困，不能在地上睡觉，否则容易招来地狱的黑白无常。但王肖怎么会相信这些呢！\n太阳渐渐脱下发着毒辣光芒的衣服，奔向西边的白云，惹得白云脸上红扑扑的，像一个害羞的小姑娘。王肖醒来看了手机，发现已经很晚了，于是准备下山。乌鸡山南北边路段都可以下山，只是王肖来时是从南边上的山。现在他不知为什么竟产生了一个奇怪的想法——去涉足自己未曾涉足的地方，去走自己从未走过的路。想到这里，他为自己接下来的做法不禁感到自豪，心情也好了许多。\n冬季太阳南回归线移动，山的北面往往会比南面稍暗些。对于乌鸡山这样高树众多的山来说更为明显。对黑暗的惧怕也许是人类的天性，当这种天性遇到人类所建立起来的理想准则时，一切的反应都显得那么真实。\n往北走先绕过一个弯，在下一段陡峭的路段，然后经过一座座灰白色的水泥亭。准备到第一座亭子时，由于树木渐渐变多，夕阳也渐渐袭来，森林里也渐渐地暗淡下来，一种恐怖气氛由之而生。王肖边走边加快脚步，差点摔了个跟头。他一抬头，远远看到一个穿着白色衣服的女子扶着亭子在那边摇扇，仪态端庄高雅，就像是古代富贵门第出来的淑女。但由于近视严重，王肖看不清她的样貌。起初他觉得那并不是什么女子，可他越是走近，样子越是清晰。突然，后林哗啦一声，王肖大叫一声：“妈呀！”紧接着他回头一看，刚才的那个白色女子已经消失不见了。王肖发出颤抖的呼吸声，急忙往山上跑去。\n在山顶上还算是明亮，他站在今天“一览众山小”的地方，还没等他缓过气来，一声“轰隆”，山顶坍塌，他随着山石掉了下去。\n第二章 乌鸡山神庙 在乌鸡山山脚下流淌着一股清泉，泉水从乌鸡山主峰——鹊连山一座池塘里冒出，池子四周长着各种奇花异草，高大古木，池子流下山脚在一处低洼形成一小滩池子，池子长着碧绿的荷叶，过了花期的池子虽少了几分姿色，但热闹却从未消停。\n柏月每次来到这里除了捣衣外，还会观赏观赏清凉的池子，不管秋去冬来，池子外的世界都是热闹的，清晨的鸟鸣，晌午的嬉闹，傍晚的虫鸣，这些声音都在呼唤着这自认为孤寂的池子。\n“月儿，看什么呢？”\n“六娘，你看这池子多清凉啊！开满荷花的时候，美极了，要是学些诗词歌赋，多想为之吟唱。”\n“月儿啊，荷花也就开花的时候，有人来看看，像这样的地方可能就只有你了，而且过了花期你还不忘。”\n“不早了，我该回去了，不然爹爹又骂了。”\n六娘点了点头，下了石坡，把衣服又过了一遍水，同柏月回了家。\n“爹，女儿把您的衣服取回来了”柏月边进门边说道。\n老郭爷子从卧榻上起了身，月儿见了想阻止，但他摇了摇手，他从木板上取来了草鞋，又在木板堆砌起的炉火上架了铁锅，顺手抽了对筷子，一手放在瓷器上。\n“会不会太麻烦。”郭老接过月儿递过来的衣物，转身放在了卧榻上，接着说道：“下次晒家下面便好。”\n“没事的爹，这地儿像个盆似的，如今日落也是来得快，石坡那却非这般，您最近又急着用，还是多备些衣物为好。”\n“好好好，来，先吃饭吧！”\n不巧此时六娘来到屋外，喊了几声月儿，声也是大，怕是出了事，月儿急忙从屋里走了出来，下了木梯，问道：“六娘出了什么事。”\n“月儿，我家那老头的衣服还落在石坡上，现在离不开，他明又急着用……”\n“六娘放心，月儿明白，我这就去取来，您安心去忙吧！”\n六娘拜谢后便离开了，月儿告诉老郭后，一人便独自前往荷花池边的石坡，出门沿着小河一路向西走，过一座独木桥，在翻过一座山岗，便可见到石坡，沿着曲折蜿蜒的山路，可以看到远处高耸入云的乌鸡山。\n虽然海拔仅有一千多米，但站在底处却依然能感受到其威严之势，还有那风雨雕琢的美丽风光，得天独厚的喀斯特地貌与之雅丹地貌相互碰撞，相互囊嵌，孕育出了这美丽的乌鸡山。\n乌鸡山远远的看去像一条鲸鱼头上顶着一座似鸡的岛屿，因其色泽以灰黑色为多，古代帝王将之成为“乌鸡”山，但生活于当地的百姓则认为这是乌仙下饭的征兆，在其传说中，乌仙坐骑是只由鸡羽化为凤的仙兽，乌仙骑之游历四方，不想一日仙兽在凡间一处产下一子，从此便定居下来，没有再回到仙界，仙兽因其独特，常替百姓驱赶妖魔，百姓们为了感谢仙兽，便在他的山脚下建立一座庙以共答谢。\n柏月从石坡取回衣物，正要往回赶，就在这时，林中蹿出了一头野猪，吓了柏月一跳，急得她手中的衣服也掉了下来，柏月快速拾起衣服。 野猪见到人后，没有跑反而放慢了脚步——突然，迅猛的朝柏月袭来，柏月惊慌之下翻落水中，平时也只是在水浅处洗衣，不像六娘她们那般水性很好，像只卷曲的虫也是害苦了她呀！\n月亮渐渐攀上高空，披上明亮的银黄色外衣。\n石坡四周举满了一根根火把，月儿能否找到便要看看这火光了，有人在水边发现了掉落的衣服，他们还发现了野猪的脚印，一时间各种猜疑打成一片，老郭第一站了出来。\n“虽月儿平日安静，不善走动，但对付野猪还是有法子，可别忘了咋家的独门绝技。”老郭说道。\n“老郭说的是，可如果没被野猪衔去，柏月又去了哪呢？”\n众人皆疑惑，就在这时一人发现衣服不远处的河水岸上有人的脚印。\n“这恐怕是挣扎时留下的，不像是野兽的足迹。”\n“不好，快随我往下游找。”众人同老郭一同赶往了下游。\n可往下找了许久依旧不见尸体，众人边走边喊也不见柏月回应。\n王肖远远听到有人叫喊，心想有救了有救了，从刚才手机没信号，到尝试各种呼叫，再到现在有人，王肖此刻才知道在荒郊野外，没网没信号手机被削得这么厉害，好不容易找到了一个山洞落脚，奈何贝爷技能学太少，什么野外求生的知识都没有，现在好饿啊，真的要饿死了！\n他长吸了一口气，这才大声喊到“救命啊！救命啊！”\n老郭等人一会人顿了一下，细细一听——一路人喊救命——可怎么是个男儿声。\n“老郭，你听到了吧！”\n“嗯，听到了，叫得如此震耳，想必是有大麻烦，你们先一行人前去看看，我得先找到月儿。”\n众人赞同后便兵分两路，王肖看到火把正快速想他靠近，于是他也迈开腿奔向了火把——那一定是希望之光了——“刚才便是你在喊救命？”王肖与村民们见面会，带头的大胡子疑惑的说道。\n王肖一惊，啊！搁这cosplay还是拍戏呐？\n“叔叔阿姨你好！我爬山不小心摔了，迷路了不知道怎么回去了。”王肖说道。\n“啊，爬山？！”一人疑惑道。\n“不知兄台方才为何大声喊救命，想是遇到什么麻烦了，原来便是这是？”\n“是的，不好意思。”王肖说道。\n村民决定现代他下山，往后在想办法送他回去，而王肖只想马上下山，然后坐公交离开。\n正要走时，王肖说道：“对了，我今天傍晚的时候，在河边看到了一个女孩……”\n“啊！难不成是月儿。”\n众人来到山洞里，一看——果真是月儿，一位老者上前摸了摸脉象，点了点头，众人这才舒了口气，胡子大哥说道：“快，把这个消息告诉老郭？”\n一人跑了出去，看来是报消息的，奇怪了，这帮人是拍戏吗？话里话外奇奇怪怪的，还有“老郭”，这是什么人呢？\n下山洞的时候，王肖本来想问是不是在拍戏，走多久可以走到门票口，这么晚了还有没有游览车送下山……但他一句都没问上。\n走到河边后，老郭在岸边来回踱步，看到胡子大哥一行人后，急忙上前。\n“月儿呢？月儿呢？”老郭急忙问道。\n“子佩背着的。”胡子大哥说道。\n老郭重重的说了声“多谢！”胡子大哥告诉他是王肖救了月儿，老郭在王肖前又再次道谢。\n“多谢这位公子救小女一命。”老郭说道。\n听着很奇怪，但王肖还是回了一句，不客气。从见面到现在王肖都觉得怪怪的，但自己又没处说。\n回去的路上，子佩后的一位男子问道：“不知兄台是哪方人士，为何到此处游山玩水，还迷了路l”\n“我是百泽那边的人，在衡岭这边读书，”王肖淹了咽口水，不由自主的表现出无语的表情：“想来乌鸡山散散心，下山的时候山塌了，醒来就在河边了。”\n“百泽？是何地，怎没听说过。”男子问了问子佩：“子佩，你读书多，你知道吗？”\n子佩摇了摇头，有说自己不知道这个地方。\n“此处确实是衡岭，只不过你放才说在次处读书……此处多山石野兽，难不成你拜在刘夫子门下吗？”\n“比起这个，我更想问他为何衣着异样，怕是乡外人士吧？”胡子大哥说道。\n“我确实是外地的，只是在这个地方读书。”王肖说道，王肖像多说一句但还是咽了下去。\n“你这衣物看来制作精良，怕是贵门弟子吧！怎会在这穷乡僻壤读书？”那男子有问道。\n“乡檀，怎能如此无礼，这位小兄弟救了月儿，我们该感谢他，你怎在这一股劲盘问，有失礼数。”子佩说道。\n乡檀见子佩如此说道，虽有些不服气，却也在理，于是便没有多问什么。\n其实，王肖刚想问来着，子佩这么说，他又抛掉了刚才的想法，只想快点回家。\n回到村子后，王肖在想着怎么没带他下山，反而还带回了这么简陋的村子——应该说是这剧组搭建的，这时候村民们都在想着，怎么给王肖安排住宿，众人商讨后决定先留在胡子大哥家，正要带王肖过去。\n“唉！你们不带我下山吗？或者说给我指条路我自己下山。”王肖问道。\n众人投来疑惑的目光，“小兄弟，这便是山下了，不是山下那水又怎会如此平静”胡子大哥说道。\n火把远远可以找到远处的河水，河水在火把的照耀下，波光粼粼，宛若金鱼的鳞片。\n展开 预知后事如何……等我更新吧！ ",
    "description": "",
    "tags": "时空旅行",
    "title": "时空国度-木尸王朝",
    "uri": "/textbook/3.%E6%AE%8B%E6%9C%A8%E5%90%BC/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 时空旅行",
    "uri": "/tags/%E6%97%B6%E7%A9%BA%E6%97%85%E8%A1%8C/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 2.AndroidStudio",
    "content": "第一章 配置开发环境： 1.安装JDK “安装连接” 2.安装AndroidStudio “安装连接” 3.安装SDK 4.AndroidStudio汉化 https://www.bilibili.com/video/BV1Hz4y1K7Tc/ 第二章 Gradle():自动构建 日志输出工具：查看报错 Run（运行）\n工程结构： （清单文件）：对Activity，service，re广播等进行注册的文件 Java目录： 后缀为 .class drawable目录：资源文件，放图片、图标、背景资源的文件 Layout目录：放页面布局文件 放图片和.xml文件，适配不同分辨率的文件夹 values目录：颜色、数组、字符串、样式\nAndroid基本原理 Android体系结构 Android 用用程序核心组件 Activity 第四章 Activity、Fragment以及Intent通信机制 Activity生命周期 四种状态的转换\n布局的特点：\n第八章 数据存储和提供器 SharedPreference 使用键值对关系来获取文件\nSQLite 轻量级占用内存小，支持基本的MySQL语言。 创建过程：\nContentPreference（应用存储） 通过暴露URL让软件之间可以共享文件 好比一般使用文件时，软件会要求需要访问你手机文件权限。\n文件存储 网络通信编程 网络访问方式 网络状态码，例如404表示什么？\n数据解析 1.JSON格式解析： 以类对象的方式进行相应，以数组的方式进行相应，也可以二者混合。\n网络状态 JavaScript与Java交互 webView的使用\n在简单的使用webview过程中可能无法进入指定的网页，而且AndroidStudio模拟机上还会弹出如下错误：\n**Webpage not available** The webpage at http://www.baidu.comi could not beloaded because: net::ERR_CLEARTEXT_NOT_PERMITTED解决的办法： 请在AndroidManifest.xml文件下添加代码： .xml文件 添加代码 \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /\u003e 如果添加上面的还不可以，请在manifest中添加如下代码：\n.xml文件 添加代码 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest ...\u003e \u003capplication ... android:usesCleartextTraffic=\"true\"\u003e ... \u003c/application\u003e \u003c/manifest\u003e “原文章链接”\ngetwebSetting\n附件 ",
    "description": "",
    "tags": "安卓",
    "title": "AndroidStudio笔记",
    "uri": "/branch-bundle-1/2.androidstudio/%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B2-笔记",
    "uri": "/categories/b2-%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": " 附件 一、为什么要创建属于自己博客网站 自从进入大三的学习，自己接触了许多开发板、以及七七八八的软件，个人记忆力又不咋地，平时很容易把重要或者重复的知识忘记，所以我希望做一个网站记录自己所学的知识，方便查找，但我没学JS，深入学又耗费时间，如果你也有我的一些情况，想自己创建一个网站“玩玩”，那么请看下去，希望自己的一些分享能对想短期内创建静态网站、且没学过网站设计的朋友有所帮助。\n二、选择静态网站布局工具以及远程仓库 1、工具的选择 在这里我就只推荐hugo，因为本人用的就是hugo，其他的并不是很了解（如果你有更好的方法还请通过留言告诉我，谢谢！），首先确定自己要装在哪个系统上，比如装在Windows、Linux或者Mac（苹果系统），确定好这个后你就去网上搜安装方法即可，一定要搜和自己电脑系统有关的安装方法，不然安装会走很多坑的。 Windows系统。我建议使用choco工具在终端上安装，如果电脑没安装choco工具，还请自行安装。 Linux系统。首先确定自己的Linux的发行版本，举个例子，像红帽公司的和ContentOS的，这两个发行版本使用的工具可能就不一样，像ContentOS使用的是工具Yum工具安装的，还请你在网上自行搜索。 Mac系统。使用brew工具进行安装，不知道怎么用brew还请网上搜一下。 下载好后使用如下命令检查是否安装成功。\nhugo verser2、远程仓库的选择 因为要把网站的相关信息放到网上，一遍搜索查找，我们需要一个远程的仓库来装这些数据，无疑github是比较好的选择，当然Gitee、gitLab这些应该也可以（本人没有过）。至于为什么选github我想你只要稍微了解一点IT这行的，多少都知道其原因，不知道也没关系，只要能存放我们的网站数据就行。 首先你需要去注册一个github账号，并掌握在线创建、删除、导入和下载仓库，以及文件的上传、删除修改等操作，这些其实并不是很难，刚开始需要你换一点时间，详细请上网搜索。\n当我们hugo下载好和仓库创建等操作都学会后我们就可以开始操作了。\n三、仓库创建与静态网站布局 仓库创建最好是和自己github的账户名字一样，且都是小写，然后后面跟着 .github.io,例如：\nwang32.github.io\r这是比较稳妥的做法，如果你不想这么做还请自己花时间去琢磨别的方法。接着我么创建一个空项目，什么都不需要哦!\n下一步是静态网站的部署，首先你需要下载一个hugo的主题，也就是用别人的网页主题作为自己网站的基础，这样呢我们及时没学过JS也可以部署自己的网站。 创建一个目录，比如myblog，接着用code打开这个目录，在code编译器中打开终端窗口监视器，在里面输入命令\nhugo new site这个时候myblog目录下会生成一个theme的目录，用来放主题，把下载好的hugo主题放在该目录下，在使用如下命令：\nhugo --theme=\u003c主题名字\u003e --baseURL=\"\u003c你github仓库的路径\u003e\" --buildDrafts举个例子：\nhugo --theme=m10c --baseURL=\"https://wung32.github.io/\" --buildDrafts上面m10c是主题的名字，也就是你下载的hugo主题名字，而https://wung32.github.io/仓库路径。\n在这你需要注意：如果不是Windows系统这的baseURL可能写为baseUrl,要确定这件事就去看hugo.tolm文件，有的主题写为config.tolm,里面的第一二行就会提到baseURL，注意这里的要去主题目录里找。而不是在你创建的目录myblog下找。 运行上面的代码没问题就会在你创建的myblog目录下产生一个public的目录，里面装的就是你的网页信息。\n接着使用git命令把这个文件推送到远程的仓库，一般的步骤如下：\ngit init #初始化：本地建库（即文件夹）\rgit add #添加到仓库：代码文件放入本地库，\rgit commit -m “注释内容” #提交时要给注释\rgit remote add origin https://github.com/xu-xiaoya/Elegent.git #远程仓库关联\rgit push (-u) origin master #本地仓库的代码推送到远程仓库Github上如果报错：\nerror: RPC failed; HTTP 504 curl 18 HTTP/2 stream 7 was reset\rsend-pack: unexpected disconnect while reading sideband packet\rfatal: the remote end hung up unexpectedly\rEverything up-to-date\r那么加一句：\ngit config --global http.postBuffer 524288000接着继续推送就是了。\n然后去自己的仓库，点击设置，找到Page选项，有个Custom domain，在那里写上你的网站名称。\n四、买一个域名 我在没买之前网页一直加载不出来，自己也不知道为什么（如果你知道不用买域名也可以实现网站部署还请告诉我，谢谢啦！）。所以我自己是买了一个六块钱的域名的，试用期一年；当你买一个域名后要记得去解析域名，然后把解析的域名写到上面说的Custom domain那个地方，比如你解析得到的域名是：myblog.wang32.com,那么你就写这个上去。\n如果不知道怎么买。怎么解析，那么——是的，一样上网查一下。\n五、网站的优化 这个我不建议你一个人慢慢磨，慢慢的去网上找方法，其实制作主题的作者已经把怎么基于他的主题做出自己的网站的方法了，所以你老老实实的跟着作者的文档走就是了，实在有些地方不懂的在查一查看。\n补充 1、为什么我插入的图片无法显示？ 图片的显示：首先要看你的主题是基于什么语言写的，比如我的是markdown,对于这个语言只需要使用：\n![nihao](../../../public/webfonts/fa-brands-400.svg)上面的这个方法就可以让图片显示，但实际上不一定能可以，因为hugo有个目录创建规则——Page Bundles(连接：https://www.rectcircle.cn/series/hugo/content-management/page-bundles/)，如果不按照这个规则创建，那么你使用别人的主题，插入图片时可能无法显示。\n光是上面这点我就搞了一个星期，所以还是希望你好好看一下Page Bundles文档。\n今天先到这了…… 2023年12月11日\n",
    "description": "",
    "tags": [
      "网站",
      "前端"
    ],
    "title": "创建hugo静态网站的经历",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/experimence/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: C1-CC2530",
    "uri": "/categories/c1-cc2530/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: D1-点灯实验",
    "uri": "/categories/d1-%E7%82%B9%E7%81%AF%E5%AE%9E%E9%AA%8C/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 5.CC2530_ZigBee",
    "content": "实验2 IO端口输出实验 1、实验要求： 利用实验箱的基础板，实现八盏灯的点亮，下面是八盏灯的位置图： 在实际中我们可能没有实验箱，往往需要自己做一个八盏灯的板子，这个时候了解本次实验挤出实验板的八盏灯连接原理是很重要的，了解原理后你就可以自己做出自己的LED板子，并用cc2530控制它。\n2、LED灯驱动芯片 由于CC2530 单片机端口驱动能力有限，所以我们可以用ULN2003芯片做驱动，但使用uln2003需要使用到八个端口，为了不浪费端口，我们可以使用74HC595，该芯片只需要用到三个端口就可以控制八盏灯的亮灭，下面提供两块芯片的原理图： 如果你想用ULN2003还请查看相关手册，此处对74HC595进行详细说明。 74HC595 是 8 位输出锁存移位寄存器，数据输入由三个引脚组合控制，分别是数据输入引脚 SER、数据输入控制引脚 SRCK 和数据输出锁存引脚 RCK SER 引脚上的数据在 SRCK 引脚的上升沿信号保存到 QA 引脚，同时 QA 位上的数据移位到 QB位，QB 位的数据移位到 QC 位……，依次类推，所有数据向后串行移动一位，QH 位的数据被送到QH’位。所有位的数据在 RCK 引脚的上升沿信号被所存到输出端。 一下是我的个人理解： 这里我们用输入数据1001 0101，使第1、3、5、8盏灯亮（假设高电平有效）为例解释说明，首先，实际上数据输入74HC595是串行输入，所以可以数据输入时是在打开SER端口后，按照从高位到低位依次输入数据1001 0101，如上图的下面所示；接着打开SRCK，先把最高位1输入数据寄存器低位b0，接着输入次高位的0,通过0把1挤到b1，以此类推；接着再打开RCK显示灯的亮灭。\n3、IO端口输出控制 要使用CC2530的IO端口，我们需要对PxDIR、PxSEL、Px进行设置，PxDIR用来控制端口的输入输出模式，1表示输出模式，SEL为0时，表示通用IO端口，详细参照下表： 而这里的x可以取0、1、2，其实就是端口P0、P1、P2的意思,在端口下设8个端口0~7，例如P0_1,但是端口2只有0~4可用;\n下面是一个详细的例子： 当I/OP1_0~P1_7 各I/O端口输出高低电平时，设置方法如表 1.2所示： 了解以上知识后我们就可以写工程代码了。\n.xml文件 PrintfLED.h Delaye.h Initial.h 全码 //led输出设置 #include \u003cPrintfLED.h\u003e #define SER P1_0 #define SRCK P1_2 #define RCK P1_1 #define LOW 0 #define HIGE 1 void printfLED(unsigned char data,unsigned char byte){ SRCK = LOW; RCK = LOW; P1 = byte; //定义参考位 unsigned char getbit = 0x80; unsigned char i; for(i=8;i\u003e=1;i--){ if(data \u0026 getbit){ SER=1; } else{ SER=0; } SRCK = HIGE; getbit \u003e\u003e= 1; SRCK =LOW; } RCK = HIGE; } # include \"Delaye.h\" //延迟函数 void delaye() { int i,j,k; for(i=0;i\u003c5;i++) for(j=0;j\u003c200;j++) for(k=0;k\u003c255;k++) ; } #include \"Initial.h\" //初始化函数 void initial(){ P1SEL = 0x00; P1DIR = 0xFF; P1=0x00; } #include \"ioCC2530.h\" #include \"Initial.h\" #include \"Delaye.h\" #include \"PrintfLED.h\" #define Byte5 0x80 unsigned char btn[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; unsigned char btn1[8]={0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff}; unsigned char btn2[8]={0x81,0xc3,0xe7,0xff,0xe7,0xc3,0x81,0x00}; void main(void) { initial(); int i; while (1){ //1.发光二极管的循环点亮 for(i=0;i\u003c8;i++) { printfLED(btn[i],Byte5); delaye(); } printfLED(0x00,Byte5); delayed(); //2.流水灯正向流动随后反向流动 for(i=0;i\u003c8;i++) { printfLED(btn1[i],Byte5); delaye(); } for(i=7;i\u003c8\u0026 i\u003e=0;i--){ printfLED(btn1[i],Byte5); delaye(); } //3.流水灯两端逐步点亮，然后从中间向两边逐步熄灭 for(i=0;i\u003c8;i++){ printfLED(btn2[i],Byte5); delaye(); } } } 在使用时请建好一个外设文件专门放Initial.c、Initial.c、Delaye.c，然后在这些问阿金中引用与他们名字一样的.h文件，当然.h文件你自己也要先写好。 附件 ",
    "description": "",
    "tags": "硬件",
    "title": "实验2 IO端口输出实验",
    "uri": "/branch-bundle-1/5.cc2530_zigbee/experiment2/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: 硬件",
    "uri": "/tags/%E7%A1%AC%E4%BB%B6/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "代码分制表 以\u003c tabs title=\"file name\" \u003e，\u003c /tabs \u003e结尾； 然后里面写以% tab title=\"code name\" style=\"info\" color=\"blue \" %，% /tab %结尾 他们都需要用{{}}括起来 ​ 代码 {{\u003c tabs title=\"hello.\" \u003e}} //代码块一 {{% tab title=\"py\" %}} ```markdown **这里写代码** ``` {{% /tab %}} //代码块二 {{% tab title=\"sh\" %}} ```markdown **这里写代码** ``` {{% /tab %}} {{\u003c /tabs \u003e}} 附件 在双花括号里写：attachments color=\"fuchsia\" icon=\"fab fa-hackerrank\"，即可，\n{{% attachments color=\"fuchsia\" icon=\"fab fa-hackerrank\" %}}效果如下： 附件 ",
    "description": "",
    "tags": [
      "网站优化",
      "网站",
      "前端"
    ],
    "title": "网站内常用到的模版",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/1.%E5%B8%B8%E7%94%A8%E6%A8%A1%E7%89%88/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 2.AndroidStudio",
    "content": "Toolbar是什么？ 简单理解就是页面的上的菜单栏，或者叫工具栏，在AndroidStudio的页面布局中使用Toolbar，\nmenu文件的创建 在创建menu这个目录前，请看查看res/目录下是否包含该目录，如果没有则创建。 接着在该目录下创建xml文件，此处文件名为content_menu。在该content_menu使用\u003citem,如下为部分代码： .xml文件 简码 全码 \u003citem android:id=\"@+id/content_menu_group_chat\" android:title=\"发起群聊\" android:orderInCategory=\"1\" /\u003e \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:id=\"@+id/content_menu_group_chat\" android:title=\"发起群聊\" android:orderInCategory=\"1\" /\u003e \u003citem android:id=\"@+id/content_menu_add_friend\" android:title=\"添加朋友\" android:orderInCategory=\"2\" /\u003e \u003citem android:id=\"@+id/content_menu_add_RichScan\" android:title=\"扫一扫\" android:orderInCategory=\"3\" /\u003e \u003citem android:id=\"@+id/content_menu_add_QRcode\" android:title=\"扫码\" android:orderInCategory=\"4\" /\u003e \u003c/menu\u003e 在代码中orderInCategory属性是用来控制该item权重的，权重越小等级越高，该标题就会靠前显示， 结果 创建布局页面 详细代码如下： .xml文件 简码 全码 \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/options_menu_toolbar\" android:layout_width=\"409dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/options_menu_toolbar\" android:layout_width=\"409dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Activity.java1文件中 此处创建类的步骤，继承AppCompatActivity方法就不再赘述。\n在onCreate获取Toolbar的id，这个过程也叫实例化； 接着使用方法setSupportActionBar; 在onCreate外重写onCreateOptionsMenu和onOptionsItemSelected方法。 .java文件 onCreate onCreateOptionsMenu onOptionsItemSelected 全码 @SuppressLint(\"MissingInflatedId\") @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.opetions_menu); toolbar = findViewById(R.id.options_menu_toolbar); setSupportActionBar(toolbar); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.content_menu,menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { //获取menu目录中content_menu.xml文件里item的id int id = item.getItemId(); //判断id是否被点击，被点击就执行相应的动作，比如页面跳转 if(id == R.id.content_menu_add_friend){ Intent intent = new Intent(OpetionsMenu.this,ListDialogActivity.class); startActivity(intent); }else if(id == R.id.content_menu_group_chat){ return super.onContextItemSelected(item); } return false; } package com.example.practiceapplication; import android.annotation.SuppressLint; import android.content.Intent; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; public class OpetionsMenu extends AppCompatActivity { private Toolbar toolbar; @SuppressLint(\"MissingInflatedId\") @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.opetions_menu); toolbar = findViewById(R.id.options_menu_toolbar); setSupportActionBar(toolbar); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.content_menu,menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { int id = item.getItemId(); if(id == R.id.content_menu_add_friend){ Intent intent = new Intent(OpetionsMenu.this,ListDialogActivity.class); startActivity(intent); }else if(id == R.id.content_menu_group_chat){ return super.onContextItemSelected(item); } return false; } } 最终结果 结果 展开 详细知识等我更新…… Activity.java这个文件的一般就是我们所说的主程序，类似与C语言中的包含main入口的文件。 ↩︎\n",
    "description": "",
    "tags": [
      "安卓",
      "UI设计"
    ],
    "title": "2-1.Toolbar工具栏",
    "uri": "/branch-bundle-1/2.androidstudio/toolbar/"
  },
  {
    "breadcrumb": "Maloudown \u003e Categories",
    "content": "",
    "description": "",
    "tags": null,
    "title": "类别 :: B3-课堂笔记",
    "uri": "/categories/b3-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "Maloudown \u003e Tags",
    "content": "",
    "description": "",
    "tags": null,
    "title": "标签 :: UI设计",
    "uri": "/tags/ui%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "Maloudown \u003e 一、博客文章 \u003e 1.文章",
    "content": "不论是创建首页页面，还是左边框的选项，归根结底它们都是“目录”，从根上说，你需要创建一个目录然后在目录里面创建一个.md文件来装这个目录或说显示这个目录的内容。\n首页的创建 创建首页使用了命令\nhugo new –kind home _index.md\n而后产生的页面，它自动生成头文件\n+++ archetype = \"home\" title = \"\" +++ 值得注意的是，如果你用命令\nhugo new site myblog\n创建了一个myblog的目录，那么你在里面操作 hugo new –kind home _index.md 的时候,用于显示首页的文件_index.md会自动产生在content文件里。\n创建章节的方法 使用命令：\nhugo new \u003cchapter\u003e/\u003cname\u003e/_index.md 或者：\nhugo new \u003cchapter\u003e/\u003cname\u003e.md 在创建章节的时候需要加上alwaysopen = false,如下面的例子：\n+++ alwaysopen = false archetype = \"chapter\" title = \"2.AndroidStudio\" weight = 20 +++ 附件 ",
    "description": "",
    "tags": [
      "网站优化",
      "网站",
      "前端"
    ],
    "title": "网站的目录与子目录创建",
    "uri": "/branch-bundle-1/1.%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/2.%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA/"
  }
]
