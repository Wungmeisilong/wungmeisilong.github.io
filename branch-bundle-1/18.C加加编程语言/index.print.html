<!DOCTYPE html>
<html lang="zh" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.120.4">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="18.C&#43;&#43;编程语言 :: Maloudown">
    <meta name="twitter:description" content="">
    <meta property="og:title" content="18.C&#43;&#43;编程语言 :: Maloudown">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://wungmeisilong.github.io/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
    <meta property="og:site_name" content="Maloudown">
    <title>18.C&#43;&#43;编程语言 :: Maloudown</title>
    <link href="https://wungmeisilong.github.io/branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="canonical" type="text/html" title="18.C++编程语言 :: Maloudown">
    <link href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="alternate" type="application/rss+xml" title="18.C++编程语言 :: Maloudown">
    <link href="../../images/favicon.png?1732203431" rel="icon" type="image/png">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../css/fontawesome-all.min.css?1732203432" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fontawesome-all.min.css?1732203432" rel="stylesheet"></noscript>
    <link href="../../css/nucleus.css?1732203432" rel="stylesheet">
    <link href="../../css/auto-complete.css?1732203432" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/auto-complete.css?1732203432" rel="stylesheet"></noscript>
    <link href="../../css/perfect-scrollbar.min.css?1732203432" rel="stylesheet">
    <link href="../../css/fonts.css?1732203432" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fonts.css?1732203432" rel="stylesheet"></noscript>
    <link href="../../css/theme.css?1732203432" rel="stylesheet">
    <link href="../../css/theme-auto.css?1732203432" rel="stylesheet" id="R-variant-style">
    <link href="../../css/variant.css?1732203432" rel="stylesheet">
    <link href="../../css/print.css?1732203432" rel="stylesheet" media="print">
    <link href="../../css/format-print.css?1732203432" rel="stylesheet">
    <link href="../../css/ie.css?1732203432" rel="stylesheet">
    <script src="../../js/url.js?1732203432"></script>
    <script src="../../js/variant.js?1732203432"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../index.search.js";
      var root_url="../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/wungmeisilong.github.io/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'neon', 'zen-light' ] );
      // translations
      window.T_Copy_to_clipboard = `复制到剪贴板`;
      window.T_Copied_to_clipboard = `复制到剪贴板！`;
      window.T_Copy_link_to_clipboard = `将链接复制到剪贴板`;
      window.T_Link_copied_to_clipboard = `链接复制到剪贴板！`;
      window.T_Reset_view = `重置视图`;
      window.T_View_reset = `查看重置！`;
      window.T_No_results_found = `找不到"{0}"的结果`;
      window.T_N_results_found = `为"{0}"找到 {1} 个结果`;
    </script>
  </head>
  <body class="mobile-support print" data-url="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="导航 (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../"><span itemprop="name">Maloudown</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../branch-bundle-1/"><span itemprop="name">一、博客文章</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">18.C&#43;&#43;编程语言</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>
<div class="article-subheading">目录 18</div>
<h1 id="18c编程语言">18.C&#43;&#43;编程语言</h1>


<ul class="children children-li children-sort-">
	
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">14.新标准C加加程序设计</a><p>内联函数、函数重载和缺省函数 类和对象的基本概念 抽象 将事物所能进行的的行为归纳出来，形成函数，这些函数可以操作事物归纳后的数据结构。 封装 将事物</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/">13.从C到C&#43;&#43;</a><p>指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量 指的是用 &ldquo;&ldquo;括</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/">12.其他库的介绍</a><p>为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括： 数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/">11.STL库学习之适配器</a><p>整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/">10.STL库学习之仿函数</a><p>仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了op</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/">9.STL库学习之迭代器与算法</a><p>标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/">8.STL库学习之容器</a><p>list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/">7.STL库学习之分配器</a><p>分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/6.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AD%91%E5%9F%BA%E6%A6%82%E8%A6%81/">6.STL库学习之筑基概要</a><p>STL程序源代码位置 了解自身编译器STL程序源代码位置。 OOP 与 GP 面向对象编程（OOP）： 面向对象编程是一种编程范式，它将数据和处理这些数据的方</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">5.STL库之观其大略</a><p>一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/">4.C&#43;&#43;2.0特性的使用</a><p>VS 2022的设置 首先你可以先用下面的代码测试使用可以执行： #include &lt;iostream&gt; void printTypes() { } template &lt;typename T, typename... U&gt; void printTypes(const T&amp; t, const U&amp;... u) { std::cout &lt;&lt; t &lt;&lt; std::endl; printTypes(u...); } int main() { printTypes(&#39;a&#39;, 1.5, &#39;b&#39;); }如果报错了，如t</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/">3.导读</a><p>书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard libra</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/">2.组合与继承</a><p>类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构</p></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">1.代码编写规范</a><p>如何写一个标准的.h文件 以下内容来自B站。 接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码： class complex { private: /* data */ double re,im; friend complex&amp; __doapl (complex*,const</p></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">18.C&#43;&#43;编程语言 的子部分</h1>
          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
    <li><a class="term-link" href="../../tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</a></li>
    <li><a class="term-link" href="../../tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>
  </ul>
</div>
            </header>
<h1 id="14新标准c加加程序设计">14.新标准C加加程序设计</h1>

<h2 id="内联函数函数重载和缺省函数">内联函数、函数重载和缺省函数</h2>
<h2 id="类和对象的基本概念">类和对象的基本概念</h2>
<h3 id="抽象">抽象</h3>
<p>将事物所能进行的的行为归纳出来，形成函数，这些函数可以操作事物归纳后的数据结构。</p>
<h3 id="封装">封装</h3>
<p>将事物归纳的数据结构和操作该数据结构的算法呈现显而易见的紧密关系，叫封装。</p>
<h3 id="继承">继承</h3>
<h3 id="多态">多态</h3>
<h3 id="类">类</h3>
<p>将数据结构和操作该数据结构的函数捆绑在一起形成一个类。</p>
<h3 id="在类中使用缺省函数">在类中使用缺省函数</h3>
<p>需要注意避免二义性：
<a href="#R-image-2bbc3f65b07ccaa9463969722327c5f0" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-5.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2bbc3f65b07ccaa9463969722327c5f0"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-5.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="构造函数">构造函数</h2>
<h3 id="类中为什么需要构造函数">类中为什么需要构造函数</h3>
<p><a href="#R-image-05a8dbc8326bb19cd4572c914406fcbe" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-6.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05a8dbc8326bb19cd4572c914406fcbe"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-6.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="构造函数在数组中的使用">构造函数在数组中的使用</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        A(){std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;}<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        A(<span style="color:#66d9ef">int</span> b){std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;value: &#34;</span><span style="color:#f92672">&lt;&lt;</span>b<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;}<span style="color:#75715e">//2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    A arr[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>上面的语句就调用了第1，2个构造函数，首先数据里的1会调用2，而数组的第二个是空值那么就会调用第1个。</p>
<h2 id="复制构造函数-copy-constructor">复制构造函数-copy constructor</h2>
<p>函数名与类名相同，参数为A(A&amp; a)或A(const A&amp; a)（二选一）。</p>
<p>三种情况下复制构造函数起作用</p>
<ul>
<li>同类对象a,b，将a的值初始化b；
<ul>
<li>A a; A b(a);</li>
</ul>
</li>
<li>将类当作参数传入函数；</li>
<li>将类作为返回值；</li>
</ul>
<p>注意：对象之间的复制是不会导致复制构造函数的</p>
<h2 id="转换构造函数">转换构造函数</h2>
<p>什么是转换构造函数
<a href="#R-image-2ba56dda71a30403c3bd083e3f32f151" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-7.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ba56dda71a30403c3bd083e3f32f151"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-7.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>示例代码：
<a href="#R-image-330bdc86bfb7f179e4521bd7dee72187" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-8.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-330bdc86bfb7f179e4521bd7dee72187"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-8.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
在上面的例子当中，<code>c1 = 9;</code>会被自动转换为调用转换构造函数，如果不想让这样的事情发生，可以在转换构造函数前面加上修饰字段 <code>explicit</code>，这样再次使用<code>c1 = 9;</code>时程序会报错。</p>
<h2 id="析构函数-destructors">析构函数-destructors</h2>
<p>这里补充几点，一个类只能有一个析构函数；</p>
<p><strong>析构函数与数组：</strong></p>
<p>数组成员的每一次结束时都会调用析构函数，假设类A数组array[2]，则生命周期结束时会调用两次析构函数。</p>
<p><strong>析构函数什么时候被调用呢？</strong></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMyclass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>CMyclass() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    CMyclass obj;
</span></span><span style="display:flex;"><span>    CMyclass <span style="color:#a6e22e">fun</span>(CMyclass sobj ) { <span style="color:#75715e">//参数对象消亡也会导致析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//构函数被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> sobj; <span style="color:#75715e">//函数调用返回时生成临时对象返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    obj <span style="color:#f92672">=</span> fun(obj); <span style="color:#75715e">//函数调用的返回值（临时对象）被
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//用过后，该临时对象析构函数被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div><p>上面结果输出三个destructor，在<code>fun(CMyclass sobj)</code>参数对象消亡调用析构函数（具体可以联想复制构造函数），会调用一次析构函数；当函数返回赋值给obj后，再次调用析构函数；整个程序结束再次调用析构函数。
<a href="#R-image-c68c4e58ffd02b90dbd0042dc4b09fc0" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-9.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c68c4e58ffd02b90dbd0042dc4b09fc0"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-9.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="this指针">this指针</h2>
<p><a href="#R-image-f1d7e736217c5aba81340963b5ce8ddd" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-10.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f1d7e736217c5aba81340963b5ce8ddd"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-10.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>静态成员函数中可以直接使用this指针来代表指向该函数作用的对象的指针</p>
<p>示例1：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> real, imag;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> real <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> imag ; }
</span></span><span style="display:flex;"><span>Complex(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)<span style="color:#f92672">:</span>real(r),imag(i)
</span></span><span style="display:flex;"><span>{ }
</span></span><span style="display:flex;"><span>Complex <span style="color:#a6e22e">AddOne</span>() {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>real <span style="color:#f92672">++</span>; <span style="color:#75715e">//等价于 real ++;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Print(); <span style="color:#75715e">//等价于 Print
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>Complex c1(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>),c2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>c2 <span style="color:#f92672">=</span> c1.AddOne();<span style="color:#75715e">//调用AddOne函数后内部this指针变为c1，所以是c1中的read++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">//输出 2,1
</span></span></span></code></pre></div><p>示例2：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Hello() { cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>}; <span style="color:#75715e">// 翻译为void Hello(A * this ) { cout &lt;&lt; this-&gt;i &lt;&lt; &#34;hello&#34;&lt;&lt; endl; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>Hello(); <span style="color:#75715e">//翻译为Hello(p);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">//编译报错
</span></span></span></code></pre></div><p>报错的原因是p指针式一个空指针，它并不指向任何A的对象，所以编译到 <code>this-&gt;i</code> 会报错。</p>
<h2 id="静态成员变量和函数">静态成员变量和函数</h2>
<p><strong>基本特点：</strong></p>
<ul>
<li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。</li>
<li>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问。</li>
</ul>
<p>对第二句话的理解，如下代码示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 普通成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> bark() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Woof!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 静态成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string getSpecies() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Canine&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><p>要调用bark我们需要先创建一个Dog的类对象，然后通过 <code>.</code> 调用，也就是非静态成员作用于对象的意思，但是对于 <code>getSpecies</code> 就不需要，可以直接 <code>Dog::getSpecies</code>调用。</p>
<p><strong>如何访问静态成员？</strong></p>
<ol>
<li>
<p>类名::成员名
CRectangle::PrintTotal();</p>
</li>
<li>
<p>对象名.成员名
CRectangle r; r.PrintTotal();</p>
</li>
<li>
<p>指针-&gt;成员名
CRectangle * p = &amp;r; p-&gt;PrintTotal();</p>
</li>
<li>
<p>引用.成员名
CRectangle &amp; ref = r; int n = ref.nTotalNumber;</p>
</li>
</ol>
<p><strong>设置静态成员变量的目的是什么？</strong></p>
<p>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。比如，考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，用静态成员将这两个变量封装进类中，就更容易理解和维护。</p>
<p>注意事项：</p>
<ul>
<li>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。</li>
<li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<h2 id="成员对象和封闭类">成员对象和封闭类</h2>
<ul>
<li>有成员对象的类叫 封闭(enclosing)类。</li>
<li>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。具体的做法就是：通过封闭类的构造函数的初始化列表。</li>
</ul>
<p><strong>封闭类的复制构造函数:</strong></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    A(A <span style="color:#f92672">&amp;</span> a) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;copy&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> { A a; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    B b1,b2(b1);<span style="color:#75715e">//b2调用自生默认复制构造函数，而内部的A a也会调用默认的复制构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h2 id="友元">友元</h2>
<ol>
<li>友元函数: 一个类的友元函数可以访问该类的私有成员。</li>
<li>可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。</li>
<li>友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。</li>
<li>友元类之间的关系不能传递，不能继承。</li>
</ol>
<h2 id="常量成员">常量成员</h2>
<p>常量成员函数：内部不能改变属性的值，也不能调用非常量成员函数。</p>
<p>**注意：**如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么，最好将其写成常量成员函数。
mutable成员变量
可以在const成员函数中修改的成员变量</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CTest</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> GetData() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    m_n1<span style="color:#f92672">++</span>;<span style="color:#75715e">//这个值更可以更改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> m_b2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> m_n1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> m_b2;
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div><h2 id="运算符重载函数">运算符重载函数</h2>
<p><strong>浅拷贝与深拷贝：</strong>
<a href="#R-image-1b73ae6aa60a3ad565ed7157361991b6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1b73ae6aa60a3ad565ed7157361991b6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>为解决这个问题，我们需要修改赋值运算符重载：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    String <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> String <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span> s)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] str;
</span></span><span style="display:flex;"><span>        str <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(s.str)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy( str,s.str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="自增自减运算法重载">自增自减运算法重载</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDemo</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>CDemo(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span>n(i) { }
</span></span><span style="display:flex;"><span>CDemo <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(); <span style="color:#75715e">//用于前置形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CDemo <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>( <span style="color:#66d9ef">int</span> ); <span style="color:#75715e">//用于后置形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">int</span> ( ) { <span style="color:#66d9ef">return</span> n; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">friend</span> CDemo <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">--</span>(CDemo <span style="color:#f92672">&amp;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">friend</span> CDemo <span style="color:#66d9ef">operator</span><span style="color:#f92672">--</span>(CDemo <span style="color:#f92672">&amp;</span> ,<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><code>operator int ( ) {return n;}</code></p>
<p>这里，int 作为一个类型强制转换运算符被重载, 此后</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Demo s;
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">int</span>) s ; <span style="color:#75715e">//等效于 s.int();
</span></span></span></code></pre></div><p>类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型。</p>
<h2 id="继承和派生">继承和派生</h2>
<p>**注意：**在派生类的各个成员函数中，不能访问基类中的private成员。</p>
<h3 id="派生类的内存空间">派生类的内存空间</h3>
<p><a href="#R-image-ffa8f4318affb1613973604e9bd1ff00" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ffa8f4318affb1613973604e9bd1ff00"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="类之间的关系">类之间的关系</h3>
<p><strong>继承：“是”关系。</strong></p>
<ul>
<li>基类 A，B是基类A的派生类。</li>
<li>逻辑上要求：“一个B对象也是一个A对象”。</li>
</ul>
<p><strong>复合：“有”关系。</strong></p>
<ul>
<li>类C中“有”成员变量k，k是类D的对象，则C和D是复合
关系</li>
<li>一般逻辑上要求：“D对象是C对象的固有属性或组成部
分”</li>
</ul>
<p>复合关系的示例：
<a href="#R-image-008fd8bc0aadabea327b021db4cce69d" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-008fd8bc0aadabea327b021db4cce69d"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="基类与派生类名字重名的情况">基类与派生类名字重名的情况</h3>
<p>一般来说，基类和派生类不定义同名成员变量。但如果要方位可以使用<code>基类::基类成员</code>来访问。</p>
<h3 id="访问权限">访问权限</h3>
<p><strong>• 基类的private成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
</ul>
<p><strong>• 基类的public成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数</li>
<li>派生类的友元函数</li>
<li>其他的函数</li>
</ul>
<p><strong>• 基类的protected成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数可以访问当前对象和其它对象的基类的保护成</li>
</ul>
<p>举一个例子：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Father</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nPrivate; <span style="color:#75715e">//私有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nPublic; <span style="color:#75715e">//公有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nProtected; <span style="color:#75715e">// 保护成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Father{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AccessFather</span> () {
</span></span><span style="display:flex;"><span>nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// ok;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// wrong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// OK，访问从基类继承的protected成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Son f;
</span></span><span style="display:flex;"><span>f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//ok，派生类的成员函数可以访问当前对象和其它对象的基类的保护成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    Father f;
</span></span><span style="display:flex;"><span>    Son s;
</span></span><span style="display:flex;"><span>    f.nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error，因为只能在派生类（或友元类）中访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f.nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="派生类构造函数中包含成员变量时该如何写">派生类构造函数中包含成员变量时该如何写？</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bug</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nLegs; <span style="color:#66d9ef">int</span> nColor;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nType;
</span></span><span style="display:flex;"><span>    Bug ( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintBug</span> (){ };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Skill</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Skill(<span style="color:#66d9ef">int</span> n) { }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlyBug</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Bug {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nWings;
</span></span><span style="display:flex;"><span>    Skill sk1, sk2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    FlyBug( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color, <span style="color:#66d9ef">int</span> wings);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FlyBug<span style="color:#f92672">::</span>FlyBug( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color, <span style="color:#66d9ef">int</span> wings)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Bug(legs,color),sk1(<span style="color:#ae81ff">5</span>),sk2(color) ,nWings(wings) { }<span style="color:#75715e">//注意这种写法。
</span></span></span></code></pre></div><h3 id="private-和-protected的继承">private 和 protected的继承</h3>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。
• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成
为派生类的不可访问成员。
• protected和private继承不是“是”的关系。</p>
<p><strong>问题：</strong></p>
<p>即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。</p>
<p><strong>解决办法：</strong></p>
<p>通过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span> ptrBase <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>objDerived;
</span></span><span style="display:flex;"><span>    Derived <span style="color:#f92672">*</span>ptrDerived <span style="color:#f92672">=</span> (Derived <span style="color:#f92672">*</span> ) ptrBase;</span></span></code></pre></div><p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。</p>
<h2 id="虚函数和多态">虚函数和多态</h2>
<h3 id="多态的表现形式">多态的表现形式</h3>
<ul>
<li>派生类的指针（或引用）可以给基类赋值。</li>
<li>当指针指向基类时调用，基类的函数，当指针指向派生类时，调用调用派生类的函数，这叫做多态。</li>
<li>另外，在非虚函数和非构造、析构函数中调用虚函数，也叫做多态。
例子：
<a href="#R-image-a57645a03b6e4d2f76cc42dc698216c3" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a57645a03b6e4d2f76cc42dc698216c3"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></li>
</ul>
<p>如果在构造、析构函数中调用虚函数，那么会怎么样呢？</p>
<p>如果这么做，那么编译器只会调用当前的虚函数，如果当前没有重写虚函数，则会从基类中找进行调用，为什么要这么做呢？其实这是为了防止未初始化就调用派生类的虚函数的情况。</p>
<p>你想想啊，一类的初始化先从基类的构造函数开始，如果这个时候构造函数具有多态性，那么此时将调用派生类的对应虚函数，但是派生类这个时候都还没有初始化。</p>
<p>例子：
<a href="#R-image-fdd5d99df955b76233edd27aca6b9626" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdd5d99df955b76233edd27aca6b9626"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>`</p>
<ul>
<li>补充：在上面的图例子中，派生类写了与基类虚函数相同的名字，但是没有在前面加修饰符virtual，这种情况编译器认为是虚函数。</li>
</ul>
<h3 id="多态的作用">多态的作用</h3>
<p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
<h3 id="虚函数的访问权限">虚函数的访问权限</h3>
<p><a href="#R-image-25b313e6f7f5f02112e4c672d089d607" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-11.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-25b313e6f7f5f02112e4c672d089d607"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-11.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="动态联编的实现机制">动态联编的实现机制</h3>
<p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 &mdash;- 这叫“动态联编”。</p>
<p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。
<a href="#R-image-52a0917a5c19aa03ad3c46d456132fc6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-12.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-52a0917a5c19aa03ad3c46d456132fc6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-12.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>下面一段代码将验证，对象的首地址是存了虚函数表的地址的：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    A a;
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">*</span> pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B();
</span></span><span style="display:flex;"><span>    pa<span style="color:#f92672">-&gt;</span>Func();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//64位程序指针为8字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> ) <span style="color:#f92672">&amp;</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> ) pa;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span> p1;
</span></span><span style="display:flex;"><span>    pa<span style="color:#f92672">-&gt;</span>Func();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：有纯虚函数的类</li>
</ul>
<p>注意：</p>
<ul>
<li>包含纯虚函数的类叫抽象类
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建独立的抽象类的对象</li>
<li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li>
</ul>
</li>
</ul>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    A a ; <span style="color:#75715e">// 错，A 是抽象类，不能创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    A <span style="color:#f92672">*</span> pa ; <span style="color:#75715e">// ok,可以定义抽象类的指针和引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A ; <span style="color:#75715e">//错误, A 是抽象类，不能创建对象
</span></span></span></code></pre></div><ul>
<li><strong>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</strong></li>
<li>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。</li>
</ul>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
    <li><a class="term-link" href="../../tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</a></li>
    <li><a class="term-link" href="../../tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>
  </ul>
</div>
            </header>
<h1 id="13从c到c">13.从C到C&#43;&#43;</h1>

<h2 id="指针">指针</h2>
<p>指针的声明：
<a href="#R-image-3e9559c67037943d7c401572b73bb32d" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e9559c67037943d7c401572b73bb32d"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="数组">数组</h2>
<p>数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义：
<a href="#R-image-ade3be64d4e92a6181c867e84552adce" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ade3be64d4e92a6181c867e84552adce"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>2.字符串文字量</p>
<p>指的是用 &ldquo;&ldquo;括起来的字符串。</p>
<ul>
<li>长字符串编写：
<a href="#R-image-251b092ebf5b11e851a5ee1ed3ea38f4" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-251b092ebf5b11e851a5ee1ed3ea38f4"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></li>
<li>带有L的字符是宽字符，如L&quot;sddsf&rdquo;，类型是const wchar_t.</li>
</ul>
<p>3.指向数组的指针</p>
<p>4.常量
<a href="#R-image-08244fa07c8d776c59b9b7c4fa6a7c32" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-08244fa07c8d776c59b9b7c4fa6a7c32"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>5.指针和常量</p>
<p>使用一个指针时涉及到两个对象:该指针本身和被它所指的对象。将一个指针的声明用cons“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，我们必须使用声明运算符*const，而不能只用简单的const。</p>
<p>定义常量指针的声明运算符是<em>const。并没有cons** 声明符，所以出现在</em>之前的conr是作为基础类型的一部分。例如</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 到char的hconst指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> cp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> pc;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 到const char的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pc2;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//到const char的指针
</span></span></span></code></pre></div><p>有人发现从右向左读这种定义很有帮助。例如，&ldquo;cp是一个conse指针到char&rdquo;，以及“pe2是一个指针措到const chor&rdquo;</p>
<h2 id="引用">引用</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ii<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>rr <span style="color:#f92672">=</span> ii;
</span></span><span style="display:flex;"><span>    rr<span style="color:#f92672">++</span>;<span style="color:#75715e">//实际上是ii++,rr不能像指针一样操作。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ii;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><a href="#R-image-2061563fd2226a89e11558df9ca42b80" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2061563fd2226a89e11558df9ca42b80"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="12其他库的介绍">12.其他库的介绍</h1>

<h3 id="为什么需要哈希函数">为什么需要哈希函数？</h3>
<p>哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：</p>
<ol>
<li>
<p><strong>数据检索</strong>：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 <code>std::unordered_map</code> 和 <code>std::unordered_set</code>）的基础。</p>
</li>
<li>
<p><strong>快速比较</strong>：在数据库和各种数据结构中，哈希函数可以快速比较字符串或对象，常用于检查两个字符串是否相等。</p>
</li>
<li>
<p><strong>数据分布</strong>：在分布式系统中，哈希函数可以将数据均匀地分布到多个节点上，以实现负载均衡。</p>
</li>
<li>
<p><strong>密码学应用</strong>：在密码学中，哈希函数用于生成数据的摘要，用于数据完整性验证和数字签名。</p>
</li>
<li>
<p><strong>缓存实现</strong>：哈希函数可以用于实现缓存机制，通过快速定位缓存中的数据。</p>
</li>
<li>
<p><strong>负载均衡</strong>：在网络流量管理中，哈希函数可以用于将请求分配到不同的服务器上。</p>
</li>
</ol>
<h3 id="c-库中哈希函数的实现和底层逻辑">C++ 库中哈希函数的实现和底层逻辑</h3>
<p>在 C++11 及以后的版本中，标准库提供了一个专门的哈希函数库 <code>&lt;functional&gt;</code>，其中包含了 <code>std::hash</code> 模板类。<code>std::hash</code> 为基本数据类型（如 <code>int</code>、<code>double</code>、<code>std::string</code> 等）提供了特化版本。</p>
<h4 id="实现底层逻辑">实现底层逻辑：</h4>
<ol>
<li>
<p><strong>整数类型</strong>：对于整数类型，<code>std::hash</code> 直接返回数值本身或其变体。例如，对于 <code>int</code> 类型，<code>std::hash&lt;int&gt;()(10)</code> 可能直接返回 10 或者 10 的一个简单变换。</p>
</li>
<li>
<p><strong>浮点类型</strong>：对于浮点类型，<code>std::hash</code> 通常会将浮点数的位表示转换为整数，然后应用整数的哈希函数。</p>
</li>
<li>
<p><strong>字符串类型</strong>：对于字符串，<code>std::hash</code> 通常会遍历字符串中的每个字符，将每个字符的哈希值组合起来，生成最终的哈希值。这可以通过位操作和数学函数（如乘法、加法、异或等）来实现。</p>
</li>
<li>
<p><strong>自定义类型</strong>：对于自定义类型，如果需要使用 <code>std::hash</code>，则需要为该类型提供自定义的哈希函数。</p>
</li>
<li>
<p><strong>组合哈希</strong>：对于复合类型（如结构体或类），哈希函数需要将各个成员的哈希值组合起来。这通常通过将成员的哈希值进行某种形式的数学运算（如加权求和、异或等）来实现。</p>
</li>
<li>
<p><strong>均匀分布</strong>：一个好的哈希函数应该能够产生均匀分布的哈希值，以减少哈希冲突。</p>
</li>
<li>
<p><strong>确定性</strong>：哈希函数应该是确定性的，即对于同一个输入总是产生相同的哈希值。</p>
</li>
<li>
<p><strong>快速计算</strong>：哈希函数的计算应该尽可能快，以减少对性能的影响。</p>
</li>
</ol>
<p>在 C++ 中，<code>std::hash</code> 的实现可能因编译器和平台而异，但基本原理是相似的。正确实现哈希函数对于哈希表的性能至关重要，因为它直接影响到哈希表的冲突率和检索效率。</p>
<h2 id="hash-function-哈希函数">hash function-哈希函数</h2>
<p>如果要自己给自己的数据写一个哈希函数，那又该怎么写呢？能否基于这些数据计算出hash code的呢？</p>
<h3 id="编写模版规范">编写模版规范</h3>
<div class="tab-panel" data-tab-group="488496ca848fddd2b4e9f802e51f33bf">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="类型1fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('488496ca848fddd2b4e9f802e51f33bf','类型1fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型1</span>
    </button>
    <button
      data-tab-item="类型1示例fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('488496ca848fddd2b4e9f802e51f33bf','类型1示例fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型1示例</span>
    </button>
    <button
      data-tab-item="类型2fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('488496ca848fddd2b4e9f802e51f33bf','类型2fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型2</span>
    </button>
    <button
      data-tab-item="类型3fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('488496ca848fddd2b4e9f802e51f33bf','类型3fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型3</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="类型1fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {<span style="color:#75715e">//需要重载==
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>size_t <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> ...;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span>Customer, CustromerHash<span style="color:#f92672">&gt;</span> custsct;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="类型1示例fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>   <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_combine(size_t<span style="color:#f92672">&amp;</span> seed, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>            seed <span style="color:#f92672">^=</span> hash<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()(val) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ae81ff">0x9e3779b9</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                (seed <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                (seed <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_val(size_t<span style="color:#f92672">&amp;</span> seed, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>            hash_combine(seed, val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... Types<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_val(	size_t<span style="color:#f92672">&amp;</span> seed,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">const</span> Types<span style="color:#f92672">&amp;</span>... args) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            hash_combine(seed, val);
</span></span><span style="display:flex;"><span>            hash_val(seed, args...);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Types<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> size_t hash_val(<span style="color:#66d9ef">const</span> Types<span style="color:#f92672">&amp;</span>... args) {
</span></span><span style="display:flex;"><span>            size_t seed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            hash_val(seed, args...);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> seed;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            size_t <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hash_val</span>(c.fname, c.lname, c.on);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            unordered_set<span style="color:#f92672">&lt;</span>Customer, CustomerHash<span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Asd&#34;</span>, <span style="color:#e6db74">&#34;dfw&#34;</span>, <span style="color:#ae81ff">1L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Dfg&#34;</span>, <span style="color:#e6db74">&#34;kjt&#34;</span>, <span style="color:#ae81ff">2L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;VVB&#34;</span>, <span style="color:#e6db74">&#34;ert&#34;</span>, <span style="color:#ae81ff">3L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;TgR&#34;</span>, <span style="color:#e6db74">&#34;uik&#34;</span>, <span style="color:#ae81ff">4L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">5L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">6L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">7L</span>));<span style="color:#75715e">//8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> s.bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            CustomerHash hh;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Asd&#34;</span>, <span style="color:#e6db74">&#34;dfw&#34;</span>, <span style="color:#ae81ff">1L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Dfg&#34;</span>, <span style="color:#e6db74">&#34;kjt&#34;</span>, <span style="color:#ae81ff">2L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;VVB&#34;</span>, <span style="color:#e6db74">&#34;ert&#34;</span>, <span style="color:#ae81ff">3L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;TgR&#34;</span>, <span style="color:#e6db74">&#34;uik&#34;</span>, <span style="color:#ae81ff">4L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">5L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">6L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">7L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.bucket_count(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bucked #&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;has&#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.bucket_size(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;element</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// bucked #0has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #1has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #2has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #3has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #4has2element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #5has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #6has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #7has2element
</span></span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="类型2fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {<span style="color:#75715e">//需要重载==
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            size_t customer_hash_func(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> ...;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span>Customer, size_t(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">const</span> Custromer<span style="color:#f92672">&amp;</span>)<span style="color:#f92672">&gt;</span> custsct(<span style="color:#ae81ff">20</span>,customer_hash_func);<span style="color:#75715e">//注意与类型1的不同写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="类型3fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<p>第三种方式是对类里面的hash进行偏特化，比如你使用了unordered_set那么对于它的Hash，可以单独进行偏特化。
<a href="#R-image-b69098dca682287fbc43217ccbbb81fa" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b69098dca682287fbc43217ccbbb81fa"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
</div>
    </div>
  </div>
</div>
<h2 id="tuple">tuple</h2>
<p>在C++中，tuple 是一个标准库模板类，它提供了一种方式来存储不同类型数据的集合。tuple 类似于一个固定大小的数组，但是数组中的每个元素可以是不同的类型。这个特性使得 tuple 非常灵活，可以用于多种场景。</p>
<p><a href="#R-image-59dd7e557ac927136ba3eff243c1cf40" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59dd7e557ac927136ba3eff243c1cf40"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="11stl库学习之适配器">11.STL库学习之适配器</h1>

<h2 id="整体框架的回顾">整体框架的回顾</h2>
<p><a href="#R-image-d362bf9a9450bf68d68b2397674012cd" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d362bf9a9450bf68d68b2397674012cd"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="存在多种适配器-adapters">存在多种适配器-adapters</h2>
<p>一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。</p>
<p>下面做一个模拟问答，来加以了解：</p>
<p>&mdash;c
模拟问答
算法：你好，vector的迭代器，我需要知道你的迭代器类别，这样我才能正确地进行操作。</p>
<pre><code>vector的迭代器：好的，我先问一下我的适配器。

vector的迭代器：适配器，算法想知道 iterator_traits&lt;InputIterator&gt;::iterator_category 是什么类型的迭代器？

vector_iterator的适配器：你好，我们这里是随机访问迭代器（Random Access Iterator）。

算法：太好了，随机访问迭代器可以让我进行更高效的操作。那么，如果我想访问第8个元素，我该怎么做？

vector_iterator的适配器：很简单，你可以直接通过加上偏移量来访问第8个元素。比如，如果你有一个指向第一个元素的迭代器 first，那么 first + 7（因为迭代器是从0开始计数的）就会给你第8个元素的迭代器。

算法：明白了，那我可以直接使用 *(first + 7) 来获取第8个元素的值了。

vector_iterator的适配器：是的，完全正确。

算法：如果我需要反向迭代器，或者插入迭代器，你们能提供吗？

vector_iterator的适配器：当然可以。我们 vector 提供了多种迭代器适配器，包括反向迭代器（reverse_iterator）、插入迭代器（insert_iterator）等，以满足不同的需求。

算法：那太好了，这样我可以更灵活地处理 vector 中的数据了。谢谢你的帮助！
</code></pre>
<hr>
<h2 id="stl中适配器的重要特性">STL中适配器的重要特性</h2>
<p>对于容器、迭代器和仿函数它们第二次迭代器都有一个重要的特性，就是适配器会包含（也有继承）对应的类，比如stack包含了deque，然后使用了deque的某些功能，屏蔽了deque的某些某能，实现了先进后出的功能。</p>
<h2 id="仿函数适配器">仿函数适配器</h2>
<h3 id="binder2nd适配器">binder2nd适配器</h3>
<p>该适配器是用于绑定的，比如对于一个容器，需要操作比88小于数，这使用可以用binder2nd，第一个参数可以传入比较大小的less仿函数，第二个传入比较的数值x，本质上在binder2nd中，less的第二个参数传入就是x,这样就达到比较的目的了。
<a href="#R-image-f7fbced572817c0008a8b7ff1c79afb0" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7fbced572817c0008a8b7ff1c79afb0"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
小结：把A类和数值a传入另一个类B中，在B中再操作A和a.这样就实现了绑定。</p>
<h3 id="not1">not1</h3>
<p>对结果取反
<a href="#R-image-c9846c9b5225f579a891c8050d233f1f" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c9846c9b5225f579a891c8050d233f1f"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="一些新的适配器">一些新的适配器</h3>
<p><a href="#R-image-c7b4761f3d9093ce67edcf9e453badc3" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7b4761f3d9093ce67edcf9e453badc3"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="bind">bind</h3>
<p><a href="#R-image-1ef6bb8ead020c0a73ce93b0375d418c" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ef6bb8ead020c0a73ce93b0375d418c"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="迭代器适配器">迭代器适配器</h2>
<h3 id="reverseiterator">reverse——iterator</h3>
<p>三个细节：</p>
<ul>
<li>1.begin=rend,end=rbigin</li>
<li>2.取值是取后一个，所以内部实现的*是做&ndash;操作；</li>
<li>3.operate ++()操作重载后内部实现为&ndash;，operate &ndash;()重载后内部实现++操作。</li>
</ul>
<p>具体图下图所示
<a href="#R-image-7f1f2a8434440fad53a7ad9604add64b" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-6.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f1f2a8434440fad53a7ad9604add64b"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-6.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="insert_iterator">insert_iterator</h3>
<p>在下面的案例中<code>copy(bar.begin(),bar.end(),inserter(foo,it));</code>欲将list的bar数据从it指向的位置
开始插入，但是foo的空间不够，为什么还能成功？</p>
<p>设计的小技巧，当传入copy中时，因为inserter对operate =()做了重载，重载中调用了insert()该函数能决绝以上问题，
因此不会因为foo的内存不足导致插入失败。
<a href="#R-image-f7294d6925cdfc86e2e242ef9f8a36fb" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-7.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7294d6925cdfc86e2e242ef9f8a36fb"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-7.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="ostream_iterator">ostream_iterator</h3>
<p>下面通过一个案例说明该迭代器的一些特性和使用方法：</p>
<p>1.当执行初始化操作std::ostream_iterator<int> out_it(std::cout,&quot;,&quot;)时调用构造函数，并初始化。
2.执行copy操作时，因为ostream_iterator对operate =()重载，所以会将值value传给*out_stream，通过这个方法把数据打印在屏幕上。
<a href="#R-image-f18624fe104b3dab120848ec726e7eba" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-5.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f18624fe104b3dab120848ec726e7eba"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-5.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="istream_iterator">istream_iterator</h3>
<p>下面也是两个例子说明istream_iterator的特性：</p>
<p>1.<code>std::istream_iterator&lt;double&gt; iit(std::cin);</code>时同样会调用对应的构造函数，并且此处会调用<code>operate ++()</code>重载，在该重载中，<code>*in_stream</code>接收按键输入的一个值，也就是说才定义时，就已经在准备接收一个值，如果此时在该语句下写一段打印操作没见无法看到输出！
<a href="#R-image-92c164574325d78e132feea61ee550ed" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-8.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-92c164574325d78e132feea61ee550ed"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-8.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>2.下面是<code>copy</code>操作，对于这个操作，我们可以观察是否有对<code>*</code>和<code>=</code>的操作符进行重载，对于<code>=</code>的重载上述已经介绍， <code>*</code>的重载是将value返回，也就是 <code>*first</code>的操作取得的是容器中的值。
<a href="#R-image-293ca0137225e3deba75a7fbd39b17be" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-9.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-293ca0137225e3deba75a7fbd39b17be"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-9.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="10stl库学习之仿函数">10.STL库学习之仿函数</h1>

<h2 id="仿函数的个人理解">仿函数的个人理解</h2>
<p>仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。</p>
<p>你的理解是正确的，仿函数（functor）是 C++ 中的一个概念，它指的是那些可以像函数一样被调用的对象。这些对象通常重载了函数调用操作符 <code>operator()</code>，使得对象可以被当作函数来使用。以下是对你描述的一些补充说明：</p>
<h3 id="仿函数的特点">仿函数的特点</h3>
<ol>
<li>
<p><strong>重载 <code>operator()</code></strong>：仿函数类必须重载函数调用操作符 <code>operator()</code>，这样对象就可以被像函数那样调用。</p>
</li>
<li>
<p><strong>可以携带状态</strong>：与普通函数不同，仿函数可以拥有成员变量，这意味着它们可以携带状态。这些状态可以是私有的，也可以是公开的，取决于仿函数的设计。</p>
</li>
<li>
<p><strong>可以进行重载</strong>：仿函数可以重载 <code>operator()</code>，以接受不同数量和类型的参数。</p>
</li>
<li>
<p><strong>可以定义在类中</strong>：仿函数可以是类的成员函数，也可以是独立的类。</p>
</li>
<li>
<p><strong>可以有返回值</strong>：当仿函数被调用时，可以返回一个值，就像普通函数那样。</p>
</li>
<li>
<p><strong>可以作为参数传递</strong>：由于仿函数可以像函数一样被调用，它们可以作为参数传递给接受函数作为参数的函数。</p>
</li>
</ol>
<h3 id="仿函数的应用">仿函数的应用</h3>
<ol>
<li>
<p><strong>算法的参数</strong>：仿函数经常用作 STL 算法的参数，例如 <code>std::sort</code> 和 <code>std::find_if</code>，因为这些算法需要一个可以被调用的实体来比较元素或测试条件。</p>
</li>
<li>
<p><strong>回调函数</strong>：在事件驱动的编程中，仿函数可以作为回调函数，响应特定的事件。</p>
</li>
<li>
<p><strong>策略模式</strong>：在设计模式中，仿函数可以用于实现策略模式，允许算法的行为在运行时动态改变。</p>
</li>
<li>
<p><strong>简化代码</strong>：通过使用仿函数，可以减少函数指针和全局函数的使用，使得代码更加简洁和易于管理。</p>
</li>
</ol>
<h3 id="示例代码">示例代码</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Max</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重载()操作符，使其可以被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (a <span style="color:#f92672">&gt;</span> b) <span style="color:#f92672">?</span> a : b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Max max_functor;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> max_functor(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>); <span style="color:#75715e">// 使用仿函数对象调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Max value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>在这个例子中，<code>Max</code> 是一个仿函数，它重载了 <code>operator()</code> 来比较两个整数并返回最大值。然后，我们可以像调用函数一样调用 <code>max_functor</code> 对象。</p>
<h2 id="仿函数内部一般设计什么">仿函数内部一般设计什么？</h2>
<p>仿函数一般重载operate()后，会在内部设计运算操作，如算数、逻辑、相对关系等运算。如下图所示。
<a href="#R-image-4318f7a670bd4ccdc72bdf0212f1d954" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4318f7a670bd4ccdc72bdf0212f1d954"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
从上面一张图也可以发现，plus,minus,logical_and,equal_to,less类都集成了binary_function，该类的作用是什么呢？</p>
<p><code>std::binary_function</code> 的主要作用是：</p>
<ol>
<li><strong>泛型框架</strong>：提供一个泛型框架，允许函数对象接受任意类型的参数。</li>
<li><strong>类型转换</strong>：允许参数类型和返回类型的转换，使得函数对象可以用于不同的数据类型。</li>
<li><strong>模板编程</strong>：支持模板编程，使得可以创建通用的算法和函数。</li>
</ol>
<ul>
<li><strong>原型</strong></li>
</ul>
<p><code>std::binary_function</code> 的原型如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Arg1Type</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Arg2Type</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResultType</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_function</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> Arg1Type first_argument_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> Arg2Type second_argument_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> ResultType result_type;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><ul>
<li>
<p><code>Arg1Type</code>：第一个参数的类型。</p>
</li>
<li>
<p><code>Arg2Type</code>：第二个参数的类型。</p>
</li>
<li>
<p><code>ResultType</code>：函数返回值的类型。</p>
</li>
<li>
<p><strong>继承和使用</strong></p>
</li>
</ul>
<p>函数对象如 <code>std::plus</code>, <code>std::minus</code>, <code>std::logical_and</code>, <code>std::equal_to</code>, <code>std::less</code> 等都继承自 <code>std::binary_function</code>。这意味着这些函数对象都定义了 <code>first_argument_type</code>, <code>second_argument_type</code>, 和 <code>result_type</code> 这三个类型别名，它们分别表示函数对象接受的第一个参数类型、第二个参数类型和返回值类型。</p>
<p>关于 <code>std::binary_function</code>的具体细节在适配器一节会重点讲到。</p>
<p>下图是是否继承binary_function的一些示例，如果不继承会怎么样呢？以我个人的理解，继承会让仿函数的扩展性更高，它将来可以扩展出更好的功能。如下图所示。
<a href="#R-image-1c76ee0dc373fa1cabd6ccd9fb082371" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1c76ee0dc373fa1cabd6ccd9fb082371"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>除了上面讲到的binary_function还有unary_function，该类是针对单个变量的操作，比如取反，加加。如下图：
<a href="#R-image-80d8dbd583f2d5cce0a4737783f048f6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-80d8dbd583f2d5cce0a4737783f048f6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>关于binary_function的细节此处先不介绍，下一节将着重说明。</p>
<p>对于仿函数，鲜明的特点就是对operate()做了重载，这样的类创建出来的对象叫仿函数对象，具有函数的行为。如果要对重载做更多操作需要结合一些仿函数适配器，比如相面讲到的binary_function和unary_funtion。</p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="9stl库学习之迭代器与算法">9.STL库学习之迭代器与算法</h1>

<h2 id="标准库常用算法">标准库常用算法</h2>
<p><a href="#R-image-f6816616ef7556fdd4fddc4e6ccf58f0" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f6816616ef7556fdd4fddc4e6ccf58f0"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="迭代器">迭代器</h2>
<h3 id="迭代器-的分类">迭代器-的分类</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">input_iterator_tag</span> {}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">output_iterator_tag</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">forward_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> input_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bidirectional_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> forward_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">random_access_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> bidirectional_iterator_tag {};</span></span></code></pre></div><p>以上5中迭代器的继承关系，如下图所示。
<a href="#R-image-57e03bd2b70b00c1dde7f559f3d37e6d" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-57e03bd2b70b00c1dde7f559f3d37e6d"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>1.Input Iterator（输入迭代器）：
输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。</p>
<p>用法示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>input_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> vec.begin();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> vec.end()) {
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div><p>2.Forward Iterator（前向迭代器）：
前向迭代器支持双向遍历，可以向前和向后移动。</p>
<p>用法示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lst <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>forward_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> lst.begin();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> lst.end()) {
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div><p>3.Output Iterator（输出迭代器）：
输出迭代器允许对容器中的元素进行写操作，但不支持读操作。</p>
<p>用法示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>back_insert_iterator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> it(vec);
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">*</span>it <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 写操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">*</span>it <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 写操作
</span></span></span></code></pre></div><p>4.Bidirectional Iterator（双向迭代器）：
双向迭代器支持双向遍历，可以向前和向后移动。</p>
<p>用法示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lst <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>bidirectional_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> lst.end();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> lst.begin()) {
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">--</span>it;
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div><p>5.Random Access Iterator（随机访问迭代器）：
随机访问迭代器支持任意位置的快速访问，类似于指针操作。</p>
<p>用法示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>random_access_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> vec.begin();
</span></span><span style="display:flex;"><span>     it <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 随机访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;</span></span></code></pre></div><h2 id="各种容器的迭代器类型">各种容器的迭代器类型</h2>
<p>测试代码：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e"> 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_iterator_category
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> display_category(T itr) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>iterator_category cagy; <span style="color:#75715e">// 使用 std::iterator_traits 获取迭代器类别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 这里不需要递归调用 display_iterator 函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">typeid</span>(cagy).name() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_iterator_category....................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            display_category(array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(forward_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            display_category(set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(multiset<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(multiset<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            display_category(istream_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>            display_category(ostream_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(cout,<span style="color:#e6db74">&#34;&#34;</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>此处可以参考一下<code>display_category(array&lt;int, 10&gt;::iterator());</code>中传递<code>array&lt;int, 10&gt;::iterator()</code>的方法。</p>
<p>测试结果：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>test_iterator_category....................
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>forward_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>input_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>output_iterator_tag</span></span></code></pre></div><h2 id="迭代器对算法的影响">迭代器对算法的影响</h2>
<h3 id="例子1-distance">例子1-distance</h3>
<p>迭代器如何计算容器元素之间的距离呢？当调用迭代器时，迭代器是如何操作以协助算法完成后续的增删改查的？</p>
<p>在计算距离方面，我们可以看到调用接口需要传入容器的头，以及容器尾部，接着使用：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>InputIterator<span style="color:#f92672">&gt;::</span>itrerator_category category;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__distance</span>(first,last, category);</span></span></code></pre></div><p><code>typedef typename iterator_traits&lt;InputIterator&gt;::itrerator_category category;</code>这一句会判断迭代器的类型，进而执行加操作或一步一步加操作。详细如下图所示。
<a href="#R-image-aed3634bf46bb756d00d03c3c7d646b9" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aed3634bf46bb756d00d03c3c7d646b9"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="例子2-copy">例子2-copy</h3>
<p>copy的动作也不仅仅是对迭代器类型的判断，还做了许多特化、偏特化。如下图所示。
<a href="#R-image-c832c315188656c2599511b464bc9e53" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c832c315188656c2599511b464bc9e53"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="例子3-destroy">例子3-destroy</h3>
<p><a href="#R-image-98e236bc0ca029545ffd7c244835ac52" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-98e236bc0ca029545ffd7c244835ac52"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="例子4-__unique_copy">例子4-__unique_copy</h3>
<p><a href="#R-image-7029f853ca37eb15b06644ed68fa2cbe" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-5.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7029f853ca37eb15b06644ed68fa2cbe"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-5.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="对传入的迭代器类型的暗示">对传入的迭代器类型的暗示</h2>
<p>在调用一些需要传入迭代器的函数时，从函数的形参名可以判断传入的迭代器类型，如InputIterator，由于forward_iterator_tag、bidirection_iterator_tag、random_asccess_iterator_tag与input_iterator的继承关系可知，前三者都可以传入，以此类推如果形参是forward_iterator_tag那么除了其本身，bidirection_iterator_tag、random_asccess_iterator_tag也可传入。</p>
<p><a href="#R-image-ffbef9f4526bed862f1a2aa3b87eb2a5" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-6.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ffbef9f4526bed862f1a2aa3b87eb2a5"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-6.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="算法源码剖析">算法源码剖析</h2>
<h3 id="accumulate-累计">accumulate-累计</h3>
<p><a href="#R-image-95432befa3f460f41350ea7086db8545" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-7.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-95432befa3f460f41350ea7086db8545"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-7.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>测试用例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">//std::minus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt;</span><span style="color:#75715e">//std::accumulate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_accumulate
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">myfcn</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) { <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> y; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">myclass</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) { <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> y; }
</span></span><span style="display:flex;"><span>        } myobj;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> init <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nums[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>};
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init)<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init, test_accumulate<span style="color:#f92672">::</span>myfcn)<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//70
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init, test_accumulate<span style="color:#f92672">::</span>myobj) <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div><h3 id="for_each">for_each</h3>
<p>拿到每一个元素时都对该元素执行某一操作。
<a href="#R-image-be472ee8aae05a250d43ddbca6ff37d3" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-8.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be472ee8aae05a250d43ddbca6ff37d3"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-8.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>测试用例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> test_for_each
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myfcn</span>(<span style="color:#66d9ef">int</span> i) { cout<span style="color:#f92672">&lt;&lt;</span>i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;-&#34;</span>; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">myclass</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;] &#34;</span>; }
</span></span><span style="display:flex;"><span>        } myobj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>            for_each(c.begin(), c.end(), test_for_each<span style="color:#f92672">::</span>myfcn);<span style="color:#75715e">//10-20-30-
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            for_each(c.begin(), c.end(), test_for_each<span style="color:#f92672">::</span>myobj);<span style="color:#75715e">//[10] [20] [30]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="replacereplace_ifrreplace_copy">replace,replace_if,rreplace_copy</h3>
<p>replace用于将新值替换为旧值，例如将数组中所有的8替换为9.详细源码如下图所示。
<a href="#R-image-d4968fed4a24c8fba98f0aafb7a3cc99" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-9.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4968fed4a24c8fba98f0aafb7a3cc99"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-9.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p><code>replace</code>、<code>replace_if</code> 和 <code>replace_copy</code> 是 C++ 标准库中的算法，它们用于在容器或数组中替换元素。这些函数属于 <code>&lt;algorithm&gt;</code> 头文件。下面是每个函数的详细介绍和作用：</p>
<h3 id="1-replace">1. <code>replace</code></h3>
<p><code>replace</code> 函数用于将容器中所有满足特定条件的元素替换为另一个值。这个函数直接在原容器上操作，不创建新的容器。</p>
<p><strong>函数原型</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">replace</span>(ForwardIterator first, ForwardIterator last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> old_value, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div><ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>old_value</code>：要被替换的值。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>replace(v.begin(), v.end(), <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div><h3 id="2-replace_if">2. <code>replace_if</code></h3>
<p><code>replace_if</code> 函数用于将容器中满足特定条件的元素替换为另一个值。与 <code>replace</code> 不同，<code>replace_if</code> 需要一个谓词（条件函数），只有满足这个条件的元素才会被替换。这个函数也直接在原容器上操作。</p>
<p><strong>函数原型</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">replace_if</span>(ForwardIterator first, ForwardIterator last, Predicate pred, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div><ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>pred</code>：一个谓词函数，返回 <code>true</code> 表示替换，<code>false</code> 表示不替换。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>replace_if(v.begin(), v.end(), [](<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>; }, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div><h3 id="3-replace_copy">3. <code>replace_copy</code></h3>
<p><code>replace_copy</code> 函数用于将容器中所有满足特定条件的元素复制到另一个容器中，并替换为另一个值。这个函数不会改变原容器，而是创建一个新的容器，其中包含替换后的元素。</p>
<p><strong>函数原型</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIterator</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OutputIterator</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> old_value, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div><ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>result</code>：指向目标容器的迭代器，用于存储替换后的元素。</li>
<li><code>old_value</code>：要被替换的值。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2(v.size());
</span></span><span style="display:flex;"><span>replace_copy(v.begin(), v.end(), v2.begin(), <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 保持不变，v2 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div><h3 id="countcount_if">count，count_if</h3>
<p>源代码如下：
<a href="#R-image-2f41d5fc4e8031a18647c962de9f2f47" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-10.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f41d5fc4e8031a18647c962de9f2f47"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-10.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>小结：
<a href="#R-image-77e317a14110702349b636ee9bfa8756" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-11.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-77e317a14110702349b636ee9bfa8756"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-11.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="findfind_if">find，find_if</h3>
<p><a href="#R-image-4f8244576d906bc05e37ef9050b0d154" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-12.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4f8244576d906bc05e37ef9050b0d154"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-12.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="sort">sort</h3>
<p><a href="#R-image-4ab4a4c91994fbb4ce298066aa0cb9ad" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-13.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4ab4a4c91994fbb4ce298066aa0cb9ad"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-13.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="binary_search">binary_search</h3>
<p><a href="#R-image-0a23f4dccb0fe71da8ffe8ac36f00531" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-14.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0a23f4dccb0fe71da8ffe8ac36f00531"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-14.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p><strong>算法原理：</strong></p>
<p>二分查找的基本思想是将一个有序序列分为两半，通过比较中间元素和目标值来缩小搜索范围。如果中间元素正好是目标值，则查找成功；如果目标值小于中间元素，则在序列的左半部分继续查找；如果目标值大于中间元素，则在右半部分继续查找。这个过程不断重复，直到找到目标值或搜索范围为空。</p>
<p><strong>函数原型：</strong></p>
<p><code>binary_search</code> 的函数原型如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForwardIterator</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> binary_search(ForwardIterator first,
</span></span><span style="display:flex;"><span>                   ForwardIterator last,
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value);</span></span></code></pre></div><ul>
<li><code>first</code>, <code>last</code>：定义了要搜索的范围，<code>first</code> 是序列的开始迭代器，<code>last</code> 是序列的结束迭代器（指向序列末尾的下一个位置）。</li>
<li><code>value</code>：要查找的值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果在序列中找到 <code>value</code>，则返回 <code>true</code>。</li>
<li>如果没有找到，则返回 <code>false</code>。</li>
</ul>
<p><strong>示例代码：</strong></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> data <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> found <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>binary_search(data.begin(), data.end(), target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (found) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Element found in the array.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Element not found in the array.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><strong>注意事项：</strong></p>
<ol>
<li><strong>有序序列</strong>：<code>binary_search</code> 要求序列必须是有序的，否则查找结果将不可预测。</li>
<li><strong>效率</strong>：二分查找的时间复杂度为 O(log n)，其中 n 是序列中的元素数量。这使得它比线性查找（O(n)）更高效，尤其是在大数据集上。</li>
<li><strong>稳定性</strong>：如果存在多个相同的目标值，<code>binary_search</code> 将返回第一个匹配的位置。如果需要找到所有匹配项，可能需要使用其他方法。</li>
</ol>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="8stl库学习之容器">8.STL库学习之容器</h1>

<h2 id="list">list</h2>
<h2 id="vector">vector</h2>
<h2 id="deque">deque</h2>
<p><a href="#R-image-c8801ee69ecf869d544451fd90611748" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c8801ee69ecf869d544451fd90611748"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>deque的迭代器
<a href="#R-image-39edfa28f2197228a6b8141ff0a92569" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39edfa28f2197228a6b8141ff0a92569"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用<code>push_front()</code>（<code>push_back()</code>）,否则借助<code>insert_aux()</code>迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。</p>
<p>deque中+=的实现：1.先计算+=后是否超过缓冲区，如果没有则直接+=，否则需要判断需要跨几个缓冲区，然后再去确定前进几个缓冲区。
<a href="#R-image-6bb611a87f7d0a2e37a5832b15de2890" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-2.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6bb611a87f7d0a2e37a5832b15de2890"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-2.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p><strong>Vector的内存扩充：</strong></p>
<p>std::vector 在需要更多空间时，通常会将容量增加到当前大小的两倍（这是最常见的增长策略，但不是唯一的，具体实现可能有所不同）。</p>
<p>当发生扩充时，std::vector 会分配一个新的更大的内存块，然后将所有元素从旧内存块复制到新内存块，最后释放旧内存块。</p>
<p><strong>Deque的内存扩充：</strong></p>
<p>std::deque（双端队列）的内存管理机制与 std::vector 不同。std::deque 是一个使用多个固定大小的内存块来存储元素的容器，这些内存块被称为“chunks”或“maps”。</p>
<p>当 std::deque 需要更多空间时，它可能会在已有的内存块之后添加新的内存块，或者在前面添加，这取决于哪个方向上的空间更紧张。
std::deque 不会像 std::vector 那样将所有元素复制到一个新的连续内存块中，而是在多个内存块之间分配元素。</p>
<h2 id="stack和queue">stack和queue</h2>
<p>stack和queue默认使用deque的功能来分别实现先进后出和先进先出的功能，除此之外还可以使用list，stack还可以使用vector，但是deque就不能用vector，以我的理解，是因为vector不提供后端操作。</p>
<h2 id="rb-tree">Rb-tree</h2>
<p>在C++中，set和map的底层实现都是基于红黑树（RB-tree）。红黑树是一种自平衡的二叉搜索树，能够保证在最坏情况下，插入、删除和查找操作的时间复杂度均为O(log n)。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>  <span style="color:#66d9ef">int</span> key,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> value,
</span></span><span style="display:flex;"><span>                identity<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>                less<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>                alloc
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">rb_tree</span>;</span></span></code></pre></div><p><strong>set 和 map 的区别：</strong></p>
<p>set：set中的元素是唯一的键值，即Key和Value是同一个。插入时使用insert_unique()方法，确保键值不重复。</p>
<p>map：map中的元素是键值对（Key-Value），键值用于索引，值表示与索引相关联的数据。插入时使用insert_equal()方法，允许键值重复。</p>
<p><strong>红黑树的结构：</strong></p>
<p>红黑树的结构包括节点、根节点、最左节点和最右节点等。根节点通过header.parent保存，最左节点通过header.left保存，最右节点通过header.right保存。</p>
<ul>
<li>插入操作
<ul>
<li>set：插入操作调用insert_unique()，确保键值唯一。</li>
<li>map：插入操作调用insert_equal()，允许键值重复。</li>
</ul>
</li>
<li>迭代器
<ul>
<li>set：迭代器是RB-tree的const_iterator，不允许修改元素值。</li>
<li>map：迭代器也是RB-tree的const_iterator，但允许修改元素的值（因为值部分不是键）。</li>
</ul>
</li>
</ul>
<h2 id="set和multiset">set和multiset</h2>
<p>set与map的底层实现基本可以参考下面的源码图，</p>
<p><a href="#R-image-333dc6c0481418026061b8e3405565e4" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-3.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-333dc6c0481418026061b8e3405565e4"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-3.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>需要说明的一点是，在不允许更改键值上，二者的设计还是有区别，主要体现在set使用const_iterator,这样迭代器指向的键值就无法更改，而map在设计上在传进来的Key设置为const，确保键值不会被更改。</p>
<h2 id="hashtable-哈希表">hashtable-哈希表</h2>
<p>在C++中，hash_set、hash_map、hash_multiset和hash_multimap等数据结构的底层实现确实采用了哈希表的思想。具体来说，这些数据结构的设计核心是通过哈希函数将键（key）映射到数组的索引位置，从而实现高效的插入、删除和查找操作。</p>
<h3 id="数据存储的设计思想">数据存储的设计思想</h3>
<p>每个键值通过一个哈希函数计算出一个哈希值。这个哈希值通常是一个整数，用于确定键值在数组中的存储位置。例如，对于一个整数键值12，哈希函数可能会直接返回12，这样12就会被存储在数组的第12个位置。</p>
<p>哈希表的核心是一个数组（通常是一个vector），数组的每个元素（即每个位置）可以存储一个指针。这个指针指向一个单向链表的头节点。如果多个键值通过哈希函数计算出相同的哈希值，它们会被存储在同一个位置的链表中。参考下图：
<a href="#R-image-1c436efffa20593ae318c5514b966207" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-4.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1c436efffa20593ae318c5514b966207"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-4.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a>
当多个键值映射到同一个哈希值时，这些键值会被存储在一个链表中。链表的每个节点包含一个键值和指向下一个节点的指针。这种设计允许在发生哈希冲突时，通过遍历链表来查找或插入特定的键值。
<a href="#R-image-8f94f77e30d81790f973232bb5cdaa36" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-5.png?height=350px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 350px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8f94f77e30d81790f973232bb5cdaa36"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-5.png?height=350px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a>
为了保持高效的性能，哈希表通常会有一个动态扩容机制。当哈希表中的元素数量超过一定阈值时，哈希表会自动重新分配更大的数组，并重新计算所有键值的哈希值，以减少链表的长度，从而提高查找效率。</p>
<p>在实际应用中，哈希函数可能会导致不同的键值计算出相同的哈希值，这种现象称为哈希冲突。常见的解决策略包括链地址法（即使用链表存储冲突的元素）和开放地址法（即在数组中寻找下一个空闲位置）。</p>
<h3 id="具体实现过程">具体实现过程</h3>
<ul>
<li>当插入一个新键值时，首先通过哈希函数计算出其哈希值，然后根据哈希值找到对应的数组位置。如果该位置已经有元素（即发生冲突），则将新元素插入到该位置的链表中。</li>
<li>查找操作同样通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，直到找到匹配的键值或链表结束。</li>
<li>删除操作首先通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，找到并删除匹配的键值。</li>
</ul>
<h3 id="实现代码">实现代码</h3>
<p>hashtable类的实现提供了六个模板参数。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">key</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">hashFcn</span>,<span style="color:#75715e">//计算编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">extractKey</span>,<span style="color:#75715e">//取出键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualKey</span>,<span style="color:#75715e">//判断类型是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Alloc</span><span style="color:#f92672">=</span>alloc
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&gt;</span></span></span></code></pre></div><p><a href="#R-image-549072a2f859fdca854d2fe34e67301e" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-6.png?height=300px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 300px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-549072a2f859fdca854d2fe34e67301e"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-6.png?height=300px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>如果要自己使用这个哈希表，需要写hashFcn()的重载，对齐进行偏特化等操作,如下图：
<a href="#R-image-ecb6197686a6ce97a163dd8c4cff9fba" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-7.png?height=300px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 300px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ecb6197686a6ce97a163dd8c4cff9fba"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-7.png?height=300px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>如果传入的是字符串，那么字符串的编号计算可以参考下图计算方法：
<a href="#R-image-44d70b9371a57507fd8b389a5a544fac" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-8.png?height=300px&amp;width=600px" alt="alt text" class="figure-image        " style="height: 300px; width: 600px;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-44d70b9371a57507fd8b389a5a544fac"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-8.png?height=300px&amp;width=600px" alt="alt text" class="lightbox-image        " loading="lazy"></a>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="7stl库学习之分配器">7.STL库学习之分配器</h1>

<h2 id="分配器源代码位置xmemoryh">分配器源代码位置：xmemory.h</h2>
<p><a href="#R-image-2ff9bc8d7c4b2285d74730076ab947f8" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ff9bc8d7c4b2285d74730076ab947f8"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>除了array和vector外，其他容器的适配器必须是一个类，

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="6stl库学习之筑基概要">6.STL库学习之筑基概要</h1>

<h2 id="stl程序源代码位置">STL程序源代码位置</h2>
<p>了解自身编译器STL程序源代码位置。</p>
<h2 id="oop-与-gp">OOP 与 GP</h2>
<p>面向对象编程（OOP）：</p>
<p>面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。</p>
<p>补充说明：OOP 通过类（Class）来定义对象的蓝图，支持继承、封装和多态等特性，从而提高代码的重用性和灵活性。例如list中有自己的sort()函数，专门为list而设计，比::sort()的算法更优。</p>
<p>泛型编程（GP）：</p>
<p>泛型编程是一种编程范式，它允许开发者定义操作类型数据结构的函数和类，而不需要在编译时指定具体的数据类型。这种方法强调了数据和处理方法的分离，提供了更高的代码复用性和类型安全性。</p>
<p>补充说明：GP 通过模板（Templates）或泛型容器（如 std::vector、std::map）来实现，允许开发者写出与数据类型无关的代码，从而在不同的数据类型间共享相同的算法逻辑。例如vector和deque没有为自身设计sort(),在做排序操作时，需要调用::sort()来实现。</p>
<h2 id="操作符重载">操作符重载</h2>
<p>STL源码程序中会包含很多的操作符重载，一般你会看到operate修饰符，后面就紧跟着操作符。注意：<code>::</code>、<code>.</code>、<code>.*</code>和 <code>:?</code>不能进行操作符重载。</p>
<p>在我看来操作符重载是一个重要的特性，它可以让你实现任何类的运算法则，这些法则有你自己规定，操作空间还是比较宽泛。</p>
<h2 id="模版-template">模版-template</h2>
<p>最常见的写法如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FOO</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="类模板">类模板</h3>
<p>最常见的写法如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FOO</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="成员模版">成员模版</h3>
<h3 id="泛化特化和偏特化">泛化、特化和偏特化</h3>
<p>以我个人的理解，泛化是为了应对大部分的情况，特化是为了应对特殊的情况，或使用单独的方法处理对某些情况而言更好，偏特化比偏特化更近一步，把处理的手段限定在一定范围内，举个简单的例子，假设为设计计算两种情况的相加做如下定义：</p>
<p>1.泛化</p>
<p>泛化编程在C++中通过模板实现。以下是一个泛化编程的示例，其中 AND 类是一个模板类，可以处理任何类型的数据。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>2.特化</p>
<p>特化是对模板类或函数的特定实例化。以下是特化的示例，其中 AND 类被特化为处理 string 和 Text 类型：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的泛型实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span><span style="color:#f92672">&lt;</span>string, Text<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的特化实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };</span></span></code></pre></div><p>3.偏特化</p>
<p>偏特化允许对模板类的部分参数进行特化。以下是偏特化的示例，其中 AND 类被偏特化为处理第一个类型为 int 的情况：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的泛型实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的偏特化实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };</span></span></code></pre></div>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
    <li><a class="term-link" href="../../tags/stl%E5%BA%93/">STL库</a></li>
  </ul>
</div>
            </header>
<h1 id="5stl库之观其大略">5.STL库之观其大略</h1>

<h2 id="一下主要讲stl组件的测试用例特别是容器的测试">一下主要讲STL组件的测试用例，特别是容器的测试</h2>
<h2 id="学习资料">学习资料</h2>
<ul>
<li>CPLusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
<li>《STL源码剖析》</li>
</ul>
<h2 id="stl六大组件">STL六大组件</h2>
<ul>
<li>容器-Containers，申请内存用于存储数据</li>
<li>分配器-Allocators，配合容器分配内存</li>
<li>算法- Algorithms，处理某一数据的最优办法</li>
<li>迭代器-  Iterators，指针的泛型，本质与指针类似</li>
<li>适配器- Adapters，</li>
<li>仿函数-Functors，类似函数。</li>
</ul>
<p>六者的关系</p>
<p><a href="#R-image-c1b47780624e1067b777c1f3f193bc40" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1b47780624e1067b777c1f3f193bc40"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="begin和end">begin()和end()</h2>
<p>以迭代器为例，begin()指向迭代器的首地址，而end()指向迭代器尾地址的下一位，可以用前闭后开区间来表示，即**[ )**</p>
<h2 id="容器的分类">容器的分类</h2>
<p><a href="#R-image-6bbb406dfacc81f1bc1f200c13b74376" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6bbb406dfacc81f1bc1f200c13b74376"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-891beeb78f462f1a6ef639ebd1896617" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-891beeb78f462f1a6ef639ebd1896617"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="数组容器的使用">数组容器的使用</h2>
<h3 id="array-的使用">array 的使用</h3>
<div class="tab-panel" data-tab-group="f3808e8c78fb5561a415f4104d1af246">
  <div class="tab-nav">
    <div class="tab-nav-title">示例1</div>
    <button
      data-tab-item="h文件"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('f3808e8c78fb5561a415f4104d1af246','h文件')"
    >
      <span class="tab-nav-text">.h文件</span>
    </button>
    <button
      data-tab-item="testcode"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f3808e8c78fb5561a415f4104d1af246','testcode')"
    >
      <span class="tab-nav-text">testCode</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f3808e8c78fb5561a415f4104d1af246','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="h文件"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#75715e">#ifndef __AUXFUN__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#define __AUXFUN__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#define RAMD_MAX 32767
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">get_a_target_long</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;target (0--&#34;</span> <span style="color:#f92672">&lt;&lt;</span> RAMD_MAX <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;):&#34;</span>;
</span></span><span style="display:flex;"><span>            cin <span style="color:#f92672">&gt;&gt;</span> target;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将数值转为string，这样可以测试类似object的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        string <span style="color:#a6e22e">get_a_target_string</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;target (0--&#34;</span> <span style="color:#f92672">&lt;&lt;</span> RAMD_MAX <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;):&#34;</span>;
</span></span><span style="display:flex;"><span>            cin <span style="color:#f92672">&gt;&gt;</span> target;
</span></span><span style="display:flex;"><span>            snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> string(buf);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareLongs</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> b)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            1.类型转换：因为参数是const void* 类型，你需要将它们转换为具体的数据类型指针（在这个例子中是long* ），以便可以解引用并获取它们的值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            2.解引用：在转换之后，通过在类型转换的结果前使用* 操作符来获取指针指向的实际值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            3.强制转换的结果：* (long*)a实际上是一个long值，它是通过解引用转换后的指针得到的。*/</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareString</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> b)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#endif </span><span style="color:#75715e">// !__ENTRY__
</span></span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="testcode"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;TestHeardFiles/AuxFun.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">//qsort()、 bsearch()、 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> size_t ASIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">50000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> t01
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_array</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_array().............. </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, ASIZE<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//使用数组容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ASIZE; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                c[i] <span style="color:#f92672">=</span> rand();<span style="color:#75715e">//可以产生随机数的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli_seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回数组最后一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.data: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.data() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回第一个数的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            timeStart <span style="color:#f92672">=</span> clock();<span style="color:#75715e">//clock()返回毫秒数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            qsort(c.data(), ASIZE, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>), compareLongs);<span style="color:#75715e">//数组排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)bsearch(<span style="color:#f92672">&amp;</span>target, (c.data()), ASIZE, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>), compareLongs);<span style="color:#75715e">//数组查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;qsort()+bsearch(),milli-seconds:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> clock() <span style="color:#f92672">-</span> timeStart <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        t01<span style="color:#f92672">::</span>test_array();
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<p><a href="#R-image-2cfe7c58e82e3ece66fad33e7a315afd" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2cfe7c58e82e3ece66fad33e7a315afd"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
</div>
    </div>
  </div>
</div>
<h3 id="vector-的使用">vector 的使用</h3>
<p>vector是一种向后自动以2次方增加的内存的容器，一般使用push_back向后添加数据；</p>
<p>vector也有一定的缺点，假设我只需要5个内存空间，但是vector分配的是8个，剩下的3个后面如果不使用就会浪费。</p>
<div class="tab-panel" data-tab-group="99c36f06981adc7eadfa4deed1500a99">
  <div class="tab-nav">
    <div class="tab-nav-title">示例2</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('99c36f06981adc7eadfa4deed1500a99','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('99c36f06981adc7eadfa4deed1500a99','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e"> </span><span style="color:#75715e">//obort()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">	</span><span style="color:#75715e">//snprintf()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">//sort()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t02
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_vector</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_vector()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.data(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.data() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.capacity(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回的是向量当前分配的存储空间可以容纳的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//进行排序后使用bsearch查找。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                sort(c.begin(), c.end());<span style="color:#75715e">//该算法将任何类型进行排序，需要提供相应的比较函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                string<span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> (string<span style="color:#f92672">*</span>)bsearch(<span style="color:#f92672">&amp;</span>target, (c.data()), c.size(), <span style="color:#66d9ef">sizeof</span>(string), compareString);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sort()+bsearch(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<p><a href="#R-image-1b7010b457b6ed07a9d7af5637634c4c" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1b7010b457b6ed07a9d7af5637634c4c"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
</div>
    </div>
  </div>
</div>
<p>从上面的结果来看，排序后使用二分查找反而比循环查找慢，原因在于排序话费了很多时间，因为string类型是一个object，其本身大小比较大，所以面对一个object进行查找时不建议使用排序后二分查找。</p>
<p>在实际应用中，选择排序加二分查找还是直接线性查找，需要根据具体情况来决定：</p>
<ul>
<li>如果容器已经排序，或者数据量不大，直接使用二分查找可能更简单、更快。</li>
<li>如果容器未排序，且数据量很大，那么可能需要考虑是否值得为了一次查找而进行排序，或者是否可以通过其他方式（如使用更高效的数据结构，如哈希表）来提高查找效率。</li>
<li>如果查找操作非常频繁，而插入和删除操作不频繁，那么维护一个已排序的容器可能是合理的，这样每次查找都可以利用二分查找的效率。</li>
</ul>
<p>总之，选择哪种方法取决于具体的应用场景和性能要求。在某些情况下，可能需要通过实验或性能分析来确定最佳的策略。</p>
<h3 id="链表容器-list">链表容器-list</h3>
<p>std::list 是 C++ 标准库中的一个容器，它提供了双向链表的实现。</p>
<p><strong>std::list 容器的特点：</strong></p>
<ul>
<li>双向链表结构：std::list 由一系列节点组成，每个节点包含一个元素和两个指针，分别指向前一个节点和后一个节点。</li>
<li>动态内存分配：std::list 中的每个节点都是独立分配内存的。这意味着当你添加或删除元素时，std::list 会为新元素分配内存，或释放不再使用的元素所占用的内存。</li>
<li>内存空间利用：由于 std::list 的元素是单独分配的，因此不存在像 std::vector 那样的连续内存块，也就不会有额外的内存浪费。每个元素恰好占用它所需的空间，加上一些指针存储开销。</li>
</ul>
<p><strong>查询操作效率：</strong></p>
<ul>
<li>查询效率较低：与 std::vector 或 std::array 这样的随机访问容器相比，std::list 的查询操作通常较慢。这是因为 std::list 没有提供快速的随机访问能力。</li>
<li>顺序访问：在 std::list 中，要访问一个特定位置的元素，你需要从头开始遍历，直到到达那个位置。这意味着访问时间与列表的大小成正比，最坏情况下的时间复杂度为 O(n)。</li>
<li>没有跳跃访问：与数组或 std::vector 不同，std::list 没有提供直接跳到任意位置的能力。在数组中，你可以通过简单的指针算术来访问任意位置的元素，而在 std::list 中，你必须遍历链表。</li>
</ul>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="0b4189b124f9ba5ba485442b3b0af19b">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('0b4189b124f9ba5ba485442b3b0af19b','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('0b4189b124f9ba5ba485442b3b0af19b','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t03
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1073</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">329406144173384850</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">41</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1611</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<p><strong>总结：</strong>
std::list 的优点在于它的灵活性和高效的插入/删除操作，这些操作可以在 O(1) 时间内完成，因为它们只需要修改几个指针。然而，这种灵活性的代价是牺牲了快速随机访问的能力。因此，如果你的应用场景中需要频繁地在序列中间插入或删除元素，而不太关心随机访问性能，std::list 是一个很好的选择。反之，如果随机访问是一个关键操作，那么可能需要考虑使用其他类型的容器。</p>
<h3 id="链表容器-forward_list">链表容器-forward_list</h3>
<p>std::forward_list 是 C++ 标准库中的一个容器，它提供了单向链表的实现。</p>
<p><strong>std::forward_list 容器的特点：</strong></p>
<ul>
<li>单向链表结构：std::forward_list 由一系列节点组成，每个节点包含一个元素和一个指向下一个节点的指针。</li>
<li>内存分配：与 std::list 类似，std::forward_list 的元素也是动态分配内存的。但是，由于它是单向链表，所以只能从链表的前端（头部）开始进行内存分配。</li>
<li>操作限制：由于 std::forward_list 的单向特性，它只提供了 push_front() 和 pop_front() 操作来在链表的前端添加或删除元素。不支持快速的随机访问，也不支持在链表的中间或末尾进行插入和删除操作。</li>
</ul>
<p><strong>内存使用效率：</strong></p>
<ul>
<li>无尾插法：std::forward_list 没有 push_back() 方法，只能使用 push_front() 在链表的头部插入元素。这意味着，如果你需要在链表的末尾添加元素，你将不得不遍历整个链表以到达末尾，这在大型数据集中可能效率较低。</li>
<li>节省空间：与 std::list 相比，std::forward_list 每个节点只需要存储一个指向下一个节点的指针，因此它的内存开销比 std::list 小。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>空间敏感的应用：如果你的应用对内存使用非常敏感，且需要从链表的前端进行频繁的插入和删除操作，std::forward_list 是一个不错的选择。</li>
<li>单向遍历：如果你的应用只需要从链表的前端开始遍历元素，那么 std::forward_list 可以提供良好的性能。</li>
</ul>
<p><strong>测试代码</strong></p>
<div class="tab-panel" data-tab-group="af260ebafb31ad4cb0b201d9c9eb2d69">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('af260ebafb31ad4cb0b201d9c9eb2d69','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('af260ebafb31ad4cb0b201d9c9eb2d69','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;forward_list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t04
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_forward_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">forward_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            forward_list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_front(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.back(): &#34; &lt;&lt; c.back() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.size(): &#34; &lt;&lt; c.size() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">forward_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">965</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">384307168202282325</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1595</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<p>值得注意的是：
std::forward_list 专为高效的前端插入和删除操作设计，std::forward_list 没有 push_back() 是因为它是单向链表，
只能高效地从前面操作。它没有 size() 函数，因为计算链表长度需要遍历整个链表，这与它优化前端操作的设计目标不符。</p>
<p><strong>总结：</strong></p>
<p>std::forward_list 是一个轻量级的容器，它在内存使用上比 std::list 更为高效，但在功能上也更为有限。它适合于那些只需要单向遍历和操作的场景。由于其单向链表的特性，std::forward_list 在进行元素插入和删除时，只能从链表的前端进行，这限制了它的使用场景。在选择 std::forward_list 时，需要根据应用的具体需求来权衡其优势和局限性。</p>
<h3 id="链表容器-slist">链表容器-slist</h3>
<p>slist容器与forward_list容器一样，只是slis容器存在于ext\slist头文件中。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="2051d66298f89fe6e28a58a5dde25556">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('2051d66298f89fe6e28a58a5dde25556','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('2051d66298f89fe6e28a58a5dde25556','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;forward_list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t04
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_forward_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">forward_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            forward_list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_front(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.back(): &#34; &lt;&lt; c.back() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.size(): &#34; &lt;&lt; c.size() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">forward_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">965</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">384307168202282325</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1595</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="双向容器-deque">双向容器-deque</h2>
<p><a href="#R-image-d00c4cfb4aeb1fa1fe51b7fbd928b002" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d00c4cfb4aeb1fa1fe51b7fbd928b002"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>std::deque（双端队列）是一种容器，它允许在序列的前端和后端快速插入和删除元素。尽管从概念图上看，
std::deque 似乎是一个连续的存储空间，但实际上它并不是连续的。std::deque 的实现通常是由一个或多个固定大小的连续内存块
（通常称为“节点”或“块”）组成的，这些块通过指针连接在一起。</p>
<p>以下是对您提供内容的整理：</p>
<ul>
<li>存储机制：std::deque 由多个指针组成，每个指针指向一个具有一定容量的连续内存块。这些内存块被组织在一起，形成一个能够从两端快速增长的容器。</li>
<li>内存管理：当 std::deque 中的一个内存块满了，需要更多的空间时，它会“自动跳转”到下一个空闲的内存块的开始位置。如果所有现有的内存块都已满，std::deque 会分配一个新的内存块，并更新指针以指向这个新的块。</li>
<li>内存效率：使用固定容量的内存块可以减少内存浪费。例如，如果每个内存块的大小为8个元素，那么即使只存储一个元素，也只会浪费7个元素的空间（因为第一个块始终被使用）。这与 std::vector 相比，后者可能会因为频繁的内存重新分配而导致更多的内存浪费。</li>
<li>动态增长：当 std::deque 需要更多内存时，它会动态地增加新的内存块。这种设计使得 std::deque 能够在不牺牲太多内存的情况下，提供快速的插入和删除操作。</li>
<li>连续性：尽管 std::deque 在内部不是完全连续的，但它提供了随机访问的能力，这意味着你可以像访问 std::vector 或数组一样，通过索引来访问 std::deque 中的任何元素。</li>
</ul>
<p>总的来说，std::deque 是一个灵活且高效的容器，适用于需要在序列的两端进行频繁插入和删除操作的场景。它的设计既考虑了性能，
也考虑了内存使用效率。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="f5da33922ece90dcdfc703006ec39f1c">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('f5da33922ece90dcdfc703006ec39f1c','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f5da33922ece90dcdfc703006ec39f1c','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;deque&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t05
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_deque</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_deque()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            deque<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                sort(c.begin(), c.end());<span style="color:#75715e">//使用全局的sort,deque没有自己的sort。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_deque</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1055</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">461168601842738790</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">41</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3838</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="特殊容器-stack和queue">特殊容器-stack和queue</h2>
<h3 id="stdstack栈">std::stack（栈）</h3>
<p><strong>定义：</strong></p>
<p>std::stack 是一个遵循后进先出（LIFO，Last In First Out）原则的容器适配器。它只能在序列的一端（栈顶）进行添加（push）和移除（pop）操作。</p>
<p><strong>主要操作：</strong></p>
<ul>
<li>push()：在栈顶添加一个元素。</li>
<li>pop()：移除栈顶元素。</li>
<li>top()：返回栈顶元素的引用，不移除它。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>只能单端操作，即只能在栈顶进行操作。</li>
<li>没有提供直接的迭代器支持，但提供了 top() 方法来访问栈顶元素。</li>
</ul>
<h3 id="stdqueue队列">std::queue（队列）</h3>
<p><strong>定义：</strong></p>
<p>std::queue 是一个遵循先进先出（FIFO，First In First Out）原则的容器适配器。它只能在序列的一端（队尾）进行添加（push）操作，在另一端（队首）进行移除（pop）操作。</p>
<p><strong>主要操作：</strong></p>
<ul>
<li>push()：在队尾添加一个元素。</li>
<li>pop()：移除队首元素。</li>
<li>front()：返回队首元素的引用，不移除它。</li>
<li>back()：返回队尾元素的引用，不移除它。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>双端操作，即在队首进行移除操作，在队尾进行添加操作。</li>
<li>提供了迭代器支持，允许遍历队列中的所有元素。</li>
</ul>
<p><strong>与 std::deque 的不同.</strong></p>
<ul>
<li>操作限制：std::stack 和 std::queue 限制了操作的位置，而 std::deque 允许在两端自由操作。</li>
<li>迭代器支持：std::stack 不支持迭代器，std::queue 支持迭代器但只能访问队列中的元素，而 std::deque 提供了随机访问迭代器，可以高效地访问序列中的任何位置。</li>
<li>使用场景：如果你需要一个简单的后进先出或先进先出的数据结构，std::stack 或 std::queue 可能更适合。如果你需要一个能够在两端快速操作且支持随机访问的容器，std::deque 是更好的选择。</li>
</ul>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="f793fb14685675a84b70f346d35ac1fa">
  <div class="tab-nav">
    <div class="tab-nav-title">示例4</div>
    <button
      data-tab-item="stack代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('f793fb14685675a84b70f346d35ac1fa','stack代码')"
    >
      <span class="tab-nav-text">stack代码</span>
    </button>
    <button
      data-tab-item="queue代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f793fb14685675a84b70f346d35ac1fa','queue代码')"
    >
      <span class="tab-nav-text">queue代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f793fb14685675a84b70f346d35ac1fa','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="stack代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t06
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_stack</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_stack()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            stack <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//stack又叫栈，特点是先进后出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push()将数据压入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.top(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            c.pop();
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.top(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//与前面的容器不同，stack不可以进行查找操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="queue代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t07
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_queue</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_queue()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            queue <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//queue又叫队列，特点是先进先出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push()将数据压入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            c.pop();
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//与前面的容器不同，queue也不提供查找操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_stack</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1050</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">top</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">999999</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">top</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">17172</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_queue</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1027</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">21384</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1461</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">999999</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">10793</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1461</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="红黑树-multiset容器">红黑树-multiset容器</h2>
<p>multiset容器结构类似二叉树，准确说是红黑树，这种结构的的查找会快很多，但是插入则会耗费一定时间，这些时间都花费在了排序上。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="88756abd2e283cedb577a6aa864a9c40">
  <div class="tab-nav">
    <div class="tab-nav-title">示例8</div>
    <button
      data-tab-item="multiset代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('88756abd2e283cedb577a6aa864a9c40','multiset代码')"
    >
      <span class="tab-nav-text">multiset代码</span>
    </button>
    <button
      data-tab-item="multimap代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('88756abd2e283cedb577a6aa864a9c40','multimap代码')"
    >
      <span class="tab-nav-text">multimap代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('88756abd2e283cedb577a6aa864a9c40','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="multiset代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t08
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_multiset</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_multiset()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multiset <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//multiset结构式红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用insert()将数据存入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multiset.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multiset.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//使用全局::fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);<span style="color:#75715e">//使用multiset自身的fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="multimap代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t09
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_multimap</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_multimap()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multimap <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span>(i,buf));<span style="color:#75715e">//此处使用了pair设置键值对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//值得注意，multimap不可以用[]做insert，这一点可以结合map容器理解,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//另外key是不会重复的，因为接收的是0-1000000，而值可能会重复，因为值是通过随机数函数rand()产生，范围为0-32767
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multimap.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multimap.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, (&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>pItem).first <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">&lt;&lt;</span>pItem<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_multiset</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3235</span>
</span></span><span style="display:flex;"><span>    multiset.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    multiset.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">256204778801521550</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">59</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_multimap</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1843</span>
</span></span><span style="display:flex;"><span>    multimap.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    multimap.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    found, (<span style="color:#ae81ff">23456</span>, <span style="color:#ae81ff">31622</span>)</span></span></code></pre></div></div>
    </div>
  </div>
</div>
<p>从测试结果看，因为不会抛弃重复的值，multiset的元素个数与大小相等，且存值会话费很多时间。
相比之下multimap存值时间会话费少一些。</p>
<h2 id="unordered_multiset和unordered_multimap">unordered_multiset和unordered_multimap</h2>
<p>std::unordered_map 和 std::unordered_set 是 C++ 标准库中的两种容器，它们基于哈希表实现。这两种容器提供平均时间复杂度为 O(1) 的快速访问，插入和删除操作。下面简单解释它们的概念图，包括桶和负载因子的说明。</p>
<p><strong>概念图简述：</strong></p>
<p><strong>桶（Buckets）：</strong></p>
<p>在 std::unordered_map 和 std::unordered_set 中，哈希表被分为多个“桶”。
每个桶存储指向一个链表的指针（在 std::unordered_map 的情况下）或直接存储元素（在 std::unordered_set 的情况下）。
当元素被插入时，它们的哈希值决定了它们将被存储在哪个桶中。</p>
<p><strong>链表（Chaining）：</strong></p>
<p>如果多个元素具有相同的哈希值（哈希冲突），它们将被存储在同一个桶中，并通过链表连接起来。
在 std::unordered_map 中，每个桶可能包含一个链表，链表中的每个节点存储一个键值对。
在 std::unordered_set 中，每个桶可能包含一个链表，链表中的每个节点存储一个元素。</p>
<p><strong>负载因子（Load Factor）：</strong></p>
<p>负载因子是哈希表中已存储元素数量与桶数量的比率。
负载因子影响哈希表的性能。较高的负载因子可能导致更多的哈希冲突，从而增加链表的长度，降低性能。
当负载因子超过一个预设的最大值时，哈希表可能会进行重新哈希（rehashing），即增加桶的数量并重新分配所有元素到新的桶中。</p>
<p><strong>概念图说明：</strong></p>
<p><a href="#R-image-3beda75eccc80ccea31324484f8b16cb" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3beda75eccc80ccea31324484f8b16cb"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<ul>
<li>桶：哈希表被分为多个桶，每个桶可以存储一个链表的头部指针。</li>
<li>指针：在 std::unordered_map 中，每个指针指向一个链表节点，该节点包含一个键值对。在 std::unordered_set 中，每个指针直接指向存储的元素。</li>
<li>元素：链表中的元素，可能是键值对或单个值。</li>
</ul>
<p><strong>负载因子说明：</strong></p>
<p>重新哈希（Rehashing）：当负载因子超过 max_load_factor() 时，哈希表会进行重新哈希，增加桶的数量，并将所有元素重新分配到新的桶中。
动态调整：这种动态调整机制使得 std::unordered_map 和 std::unordered_set 能够根据元素数量的变化自动调整大小，以保持操作的性能。
通过这种结构，std::unordered_map 和 std::unordered_set 能够在大多数情况下提供快速的访问和修改操作，但需要注意，极端情况下（如所有元素哈希到同一个桶中）性能可能会退化到 O(n)。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="fc606ec0ece421a61f9a4b96e23e817d">
  <div class="tab-nav">
    <div class="tab-nav-title">示例9</div>
    <button
      data-tab-item="unordere_multiset代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('fc606ec0ece421a61f9a4b96e23e817d','unordere_multiset代码')"
    >
      <span class="tab-nav-text">unordere_multiset代码</span>
    </button>
    <button
      data-tab-item="unordere_multiset结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('fc606ec0ece421a61f9a4b96e23e817d','unordere_multiset结果')"
    >
      <span class="tab-nav-text">unordere_multiset结果</span>
    </button>
    <button
      data-tab-item="unordere_multimap代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('fc606ec0ece421a61f9a4b96e23e817d','unordere_multimap代码')"
    >
      <span class="tab-nav-text">unordere_multimap代码</span>
    </button>
    <button
      data-tab-item="unordere_multimap结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('fc606ec0ece421a61f9a4b96e23e817d','unordere_multimap结果')"
    >
      <span class="tab-nav-text">unordere_multimap结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="unordere_multiset代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t10
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_unordered_multiset</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_unordered_multiset()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            unordered_multiset <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用insert()将数据存入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 能存储的最大元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.bucket_count(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 中桶的数量，即存储指向一定长度链表的指针的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_load_factor(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_load_factor() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 可以使用的最大负载因子，它影响桶中链表的最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_bucket_count(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 可以使用的最大桶的数量，这个值通常由桶的增长策略和哈希表的容量决定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bucket # &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; has &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.bucket_size(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; element.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//使用全局::fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);<span style="color:#75715e">//使用multiset自身的fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="unordere_multiset结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_unordered_multiset</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1867</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">329406144173384850</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">bucket_count</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1048576</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_load_factor</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_bucket_count</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1152921504606846975</span>
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">0</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">1</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">2</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">3</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">4</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">5</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">6</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">7</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">8</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">9</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">10</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">11</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">12</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">13</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">14</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">15</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">16</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">17</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">18</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">19</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">108</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span></span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="unordere_multimap代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t11
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_unordered_multimap</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_unordered_multimap()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multimap <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, string<span style="color:#f92672">&gt;</span>(i, buf));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multimap.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multimap.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, (&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>pItem).first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pItem<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="unordere_multimap结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_unordered_multimap</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1942</span>
</span></span><span style="display:flex;"><span>    unordered_multimap.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    unordered_multimap.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, (<span style="color:#ae81ff">12345</span>, <span style="color:#ae81ff">5839</span>)</span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="set和map容器">set和map容器</h2>
<p>测试代码：</p>
<div class="tab-panel" data-tab-group="dcf9359ee36abd5eb04b9026ca41b557">
  <div class="tab-nav">
    <div class="tab-nav-title">示例10</div>
    <button
      data-tab-item="set"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('dcf9359ee36abd5eb04b9026ca41b557','set')"
    >
      <span class="tab-nav-text">set</span>
    </button>
    <button
      data-tab-item="map"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('dcf9359ee36abd5eb04b9026ca41b557','map')"
    >
      <span class="tab-nav-text">map</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('dcf9359ee36abd5eb04b9026ca41b557','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="set"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> t12
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_set</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value){
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test-set()............................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            set<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                        c.insert(string(buf));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                        abort();
</span></span><span style="display:flex;"><span>                    } 
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;set.max_size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;set.size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="map"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>   <span style="color:#66d9ef">namespace</span> t13
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_map</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_map()............................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c[i] <span style="color:#f92672">=</span> string(buf);<span style="color:#75715e">//注意这种使用方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;map.max_size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;map.size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found value, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pItem<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount value!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    test<span style="color:#f92672">-</span><span style="color:#a6e22e">set</span>()............................
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">2133</span>
</span></span><span style="display:flex;"><span>    set.<span style="color:#a6e22e">max_size</span>() <span style="color:#ae81ff">256204778801521550</span>
</span></span><span style="display:flex;"><span>    set.<span style="color:#a6e22e">size</span>() <span style="color:#ae81ff">32768</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_map</span>()............................
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1937</span>
</span></span><span style="display:flex;"><span>    map.<span style="color:#a6e22e">max_size</span>() <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    map.<span style="color:#a6e22e">size</span>() <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found value, <span style="color:#ae81ff">5839</span></span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="分配器测试程序">分配器测试程序</h2>
<p><a href="#R-image-f2fd0e8c0316c4ae6be797122e468e71" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f2fd0e8c0316c4ae6be797122e468e71"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="4c20特性的使用">4.C&#43;&#43;2.0特性的使用</h1>

<h2 id="vs-2022的设置">VS 2022的设置</h2>
<p>首先你可以先用下面的代码测试使用可以执行：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTypes</span>() {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... U<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> printTypes(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t, <span style="color:#66d9ef">const</span> U<span style="color:#f92672">&amp;</span>... u) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        printTypes(u...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        printTypes(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">1.5</span>, <span style="color:#e6db74">&#39;b&#39;</span>);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>如果报错了，如typename&hellip;未定义，那么请你按照如下步骤操作，
<a href="#R-image-f71dbeecd4a26603ad683df1f08afdc6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f71dbeecd4a26603ad683df1f08afdc6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<ul>
<li>C++语言标准选择<code>预览 - 最新 C++ 工作草案中的功能 (/std:c++latest)</code></li>
<li>启用实验性C++标准库模块&ndash;<code>是</code></li>
<li>生成ISO C++23标准库模块 &ndash; <code>是</code></li>
</ul>
<h2 id="const补充">const补充</h2>
<table>
<thead>
<tr>
<th></th>
<th>const 参数</th>
<th>non-const 参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>const 函数</td>
<td>可执行</td>
<td>可执行</td>
</tr>
<tr>
<td>non-const 函数</td>
<td>报错</td>
<td>可执行</td>
</tr>
</tbody>
</table>
<p>使用const需要注意两个问题，参数是否需要修改，参数进入函数内后数据是都会修改。解决这两个问题，在需要的地方加上const</p>
<p>还有一种情况，</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        T fooTo(T str) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> str; };
</span></span><span style="display:flex;"><span>        T <span style="color:#a6e22e">fooTo</span>(T str)  {<span style="color:#66d9ef">return</span> str;};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        foo <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">&gt;</span> f;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> y <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span>  f.fooTo(x) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span>  f.fooTo(y) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>运行结果如下:
<a href="#R-image-2e248844d56d8576378505a3f1f695f9" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e248844d56d8576378505a3f1f695f9"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
在这个例子中，带const的参数只会执行带const的函数，而不带const的参数会只会执行不带const的函数，这就是带const和不带const函数出现时的情况。
但是这个结果我并不是很满意，应为我试着在不带const函数内部修改传入的参数，代码执行时将不会以我上面说的结论出现。或许还需要在研究研究……</p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="3导读">3.导读</h1>

<h2 id="书籍推荐">书籍推荐</h2>
<ul>
<li>《C++ Premier》</li>
<li>《C++ Programming Language》</li>
<li>《Effective Modern C++》</li>
<li>《Efficient C++》</li>
<li>《The C++ standard library》</li>
<li>《STL C++》</li>
<li>《STL源码剖析》</li>
<li>《算法+数据结构=程序》</li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/CPLusPlus.com">&ldquo;网站CPLusPlus&rdquo;</a></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/CppReference.com">&ldquo;网站CppReference&rdquo;</a></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/gcc.gnu.org">&ldquo;网站gcc.gnu&rdquo;</a></li>
</ul>
<h2 id="学习路线">学习路线</h2>
<p><a href="#R-image-d6860218e154b5597dd8549d5305c8ba" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-4.png" alt="路线" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d6860218e154b5597dd8549d5305c8ba"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-4.png" alt="路线" class="lightbox-image        " loading="lazy"></a></p>
<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1002029030?tid=1473325453#/learn/content" target="_blank">慕课C++学习</a></li>
<li><a href="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/cxsjsxmooc.openjudge.cn">练习网站</a></li>
</ul>
<h2 id="conversion-function-转换函数">conversion function-转换函数</h2>
<p>接下来以一个分数的代码例子说明转换函数。</p>
<p>情况1：让值转为其他类型</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//使用示例：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f;</span></span></code></pre></div><p>在上述的示例中，<code>d = 4+f;</code>程序会先判断有没有写<code>opertaor +</code>，如果没有会试着将f通过<code>opertaor double()</code>转为double类型。</p>
<p>情况2：<strong>non-explicit-one-argument-ctor</strong>，不带explicit的一个参数的构造函数，将其他类型转为预所写类的类型</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//使用示例：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    Fraction f2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f1;</span></span></code></pre></div><p>同样在这个地方会先将4转为Fraction，然后在进行相加，转换函数使用的是构造函数，构造函数默认第二个参数是1，也就一个参数时也可用，但这个意思并不是说f1(2)你不写第二个参数。</p>
<p>虽然向上面的情况可行，但是当你把两个情况结合在一起时，就会报错，例如你如下写：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Fraction <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Fraction<span style="color:#f92672">&amp;</span> f){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fraction</span>(<span style="color:#960050;background-color:#1e0010">……</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div><p>情况3：<strong>explicit-one-argument-ctor</strong>，带explicit的一个参数的构造函数
这个时候再使用刚才的例子，程序就会报错，因为此时是两种情况的结合，意味着两种情况都可以实现，编译器此时就不知道该使用哪个方法，为了解决这个问题，你可以使用关键字explicit来约束构造函数，让其他类型如法转为所写类，这个时候编译器会报错说无法将double类型转为Fraction。如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">explicit</span> Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Fraction <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Fraction<span style="color:#f92672">&amp;</span> f){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fraction</span>(<span style="color:#960050;background-color:#1e0010">……</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    Fraction f2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f1;</span></span></code></pre></div><h2 id="编写的类大两个大方向">编写的类大两个大方向</h2>
<h3 id="智能指针">智能指针</h3>
<p><a href="#R-image-e3dbb668ff3b7bd46fe159a8512a2f9e" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e3dbb668ff3b7bd46fe159a8512a2f9e"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-49ff315d350fcfc6fd4ffc142ed3f27f" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-49ff315d350fcfc6fd4ffc142ed3f27f"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="伪函数">伪函数</h3>
<p>这样的类会像函数一样接收参数，返回某一类型的值通常会看到类中重载<code>operate() (……){……}</code>函数。</p>
<h2 id="特化">特化</h2>
<p><a href="#R-image-bf1fb077fb6b8a968be6c86fcc675ea9" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf1fb077fb6b8a968be6c86fcc675ea9"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="偏特化--对应泛化">偏特化&ndash;对应泛化</h2>
<ul>
<li>个数上的偏</li>
</ul>
<p>以我的理解就是假设原先设计的模版为</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a, <span style="color:#66d9ef">typename</span> b<span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div><p>现在我使用偏特化，写为</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> b<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">typename</span> b<span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div><p>也就是第一个参数已经确定是bool类型了。（大概先这么理解吧:smile: :smile: :smile:）</p>
<ul>
<li>范围上的偏特化</li>
</ul>
<p>一般我们的类模版你可以任意指定类型，但是现在我想写一个用指针指向的类模板，那么他就被限制在一定的范围内了</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//范围偏特化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">*</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div><h2 id="模板模板类">模板模板类</h2>
<p>假设我要创建一个容器，并指定这个容器内容的类型，这个时候可以使用模版模版类，详细看下图：
<a href="#R-image-14dd7ece36c7e7f243ad8e116c1ab941" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-14dd7ece36c7e7f243ad8e116c1ab941"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.%E5%AF%BC%E8%AF%BB/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="2组合与继承">2.组合与继承</h1>

<h2 id="类与类的三种关系">类与类的三种关系</h2>
<h3 id="composition-复合">Composition-复合</h3>
<p>以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系</p>
<p><a href="#R-image-8c08c180dfcd41ae4095d0a2ad29de11" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8c08c180dfcd41ae4095d0a2ad29de11"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="delegation-委托">delegation-委托</h3>
<p>当一个类欲用一个指针指向另一个类，以达到想使用时就指向这个类的这种关系就叫delegation，假设我要实现一个计算，此时指针指向这个函数，让函数去做这个计算。这有些类似于复合，但是这里重点在于指针的使用。在写一些功能的时候也建议使用这种关系的特性，因为这样就将两者隔开，起到一定的保护作用。参考下图：
<a href="#R-image-d67676a1ff3ffeee8661fefc91dc6305" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d67676a1ff3ffeee8661fefc91dc6305"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="inheritance-继承">Inheritance-继承</h3>
<p>在C++有三种继承方式，其中public是常用的一种，继承表示从一个类中集成某些属性成为 <strong>另外一种</strong> 类。</p>
<p><a href="#R-image-9288d6c46899d2039f36d9ca1258b6f4" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-2.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9288d6c46899d2039f36d9ca1258b6f4"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-2.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>Inheritance关系的两个类它们的构造函数与析构函数执行次序与之前描述复合时一样。如下图是这种关系的表示方法：
<a href="#R-image-57081e65507a18a64c2e4b0ba7aa738d" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-57081e65507a18a64c2e4b0ba7aa738d"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<ul>
<li>构造函数（constructor）：由内到外，代码表示为<code>SunFunction::SunFunction(…):base(){…};</code></li>
<li>析构函数（destructor）：由外到内，代码表示为<code>SunFunction::SunFunction(…){……~base();};</code></li>
</ul>
<p>值得注意的是，如果一个类将来可能是父类，那么需要在析构函数前加<strong>virtual</strong>关键字，否则会报错<code>undefine behavior</code>。</p>
<h2 id="设计模式">设计模式</h2>
<p>**参考书籍：**<em>Design PatternsExplained Simply</em></p>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          <article class="default">
            <header class="headline">
<div class=" taxonomy-tags term-list cstyle  tags" title="Tags" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="../../tags/c/">C</a></li>
  </ul>
</div>
            </header>
<h1 id="1代码编写规范">1.代码编写规范</h1>

<h2 id="如何写一个标准的h文件">如何写一个标准的.h文件</h2>
<p>以下内容来自<a href="https://www.bilibili.com/video/BV1ELHEewEms/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=5e8e4e9e284af3291f1a3addff3fc2c3" target="_blank">B站</a>。</p>
<p>接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span> __doapl (complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span> (complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  <span style="color:#75715e">//这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><h2 id="构造函数的特性">构造函数的特性</h2>
<p>这一点需要关注下面的代码：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};</span></span></code></pre></div><h2 id="关于const修饰符">关于const修饰符</h2>
<p>如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。</p>

<div class="tab-panel" data-tab-group="791b15cd1ad4a1419d5dd29c7d80a8f1">
  <div class="tab-nav">
    <div class="tab-nav-title">const的使用</div>
    <button
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('791b15cd1ad4a1419d5dd29c7d80a8f1','加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 加const</span>
    </button>
    <button
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('791b15cd1ad4a1419d5dd29c7d80a8f1','不加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 不加const</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">

<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div><p>此时做如下两种使用都是正确的</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">

<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> ()  {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> ()  {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div><p>此时做如下两种使用只有第一种可以被执行，第二种会报错。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="函数传递和返回值的两种方式">函数传递和返回值的两种方式</h2>
<p>pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。</p>
<p>pass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节，
在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(<span style="color:#66d9ef">const</span> classname<span style="color:#f92672">&amp;</span> cl){};<span style="color:#75715e">//加了const
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(classname cl){};<span style="color:#75715e">//没有加const
</span></span></span></code></pre></div><p>对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？</p>
<p>在设计类中的函数时，可以先考虑返回类型适不适合<code>引用</code>,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>        __ap(complex <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span> ,<span style="color:#66d9ef">const</span> complex <span style="color:#f92672">&amp;</span> c){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>re <span style="color:#f92672">+=</span> c.re;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>im <span style="color:#f92672">+=</span> c.im;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        }</span></span></code></pre></div><p>向上面的函数就是使用了引用返回。</p>
<h2 id="操作符重载-1成员函数">操作符重载-1：成员函数</h2>
<p><a href="#R-image-9de82a2d7b8d18c4a1dd725100ff29b4" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png" alt="操作符重载" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9de82a2d7b8d18c4a1dd725100ff29b4"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png" alt="操作符重载" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="操作符重载-2非成员函数">操作符重载-2：非成员函数</h2>
<p>假设现在要计算复数的加减，如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    complex com3;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span></span></span></code></pre></div><p>对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。</p>
<p>接下来在考虑一个问题，就是如果我们只是做<code>cout&lt;&lt;com1;</code>那么对于&laquo;函数返回值可以是void类,但是如果我们做的是<code>cout&lt;&lt;com1&lt;&lt;com2&lt;&lt;endl;</code>
这样的操作返回类型为void类型，那么当运行<code>cout&lt;&lt;com1</code>后就无法运行<code>&lt;&lt;com2&lt;&lt;endl</code>的代码.</p>
<p>很显然要让代码继续运行，我们还需要返回iostream类型，而且使用<code>return by reference</code>返回方法，也就是返回引用。如下图：
<a href="#R-image-0b26883b4221a6bdf3bf54409914268b" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b26883b4221a6bdf3bf54409914268b"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="小结">小结</h2>
<p>通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：</p>
<ul>
<li>确定类的数据并写在private中;</li>
<li>对于构造函数要善于使用初始化数据方法；</li>
<li>对于函数要想一想，返回类型是否可以改变，要不要写const；</li>
<li>对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。</li>
</ul>
<p>是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用</p>
<h2 id="接下来通过学习stringh库进一步了解指针的使用">接下来通过学习string.h库，进一步了解指针的使用</h2>
<p>一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，</p>
<p><a href="#R-image-3ae41ba747ac62952bfbdcdabbf25f91" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png" alt="String" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ae41ba747ac62952bfbdcdabbf25f91"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png" alt="String" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-e90fb50931b4a1c24cc69929eafbcda6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e90fb50931b4a1c24cc69929eafbcda6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-c70591464f9728d7df89fe0189e952f6" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c70591464f9728d7df89fe0189e952f6"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-4287c52c0e07cc843b319b6af561aa09" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4287c52c0e07cc843b319b6af561aa09"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>有时候还需要用到new 和 delete。</p>
<h2 id="stack栈和heap堆">stack（栈）和heap（堆）</h2>
<p>如下代码：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        String str1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String();
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；</p>
<h3 id="stack-object-的生命周期">stack object 的生命周期</h3>
<p>在{}内的代码执行结束后，<strong>自动调用析构函数</strong>将变量清理掉，如下代码，</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="static-local-object-的生命周期">static local object 的生命周期</h3>
<p>添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉，
变量会存储直到程序结束。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="global-objects-生命周期">global objects 生命周期</h3>
<p>全局变量在程序接收后才会被清理掉。</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="调用new和delete的过程">调用new和delete的过程</h3>
<p>在使用new的地方需要使用delete清理内存，防止内存泄露。</p>
<p>调用new过程：</p>
<p><a href="#R-image-6d8c374d62d6ddb89f128eb06afcc3ca" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6d8c374d62d6ddb89f128eb06afcc3ca"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>调用delete的过程：</p>
<p><a href="#R-image-d9cafffe19a8f113d635692c0de4a793" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9cafffe19a8f113d635692c0de4a793"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-b1749d2bf816944458cedfce325d2d3d" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1749d2bf816944458cedfce325d2d3d"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存</p>
<p><a href="#R-image-1fc07ee2a25567360a092147a90c3be4" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1fc07ee2a25567360a092147a90c3be4"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>new与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：</p>
<p><a href="#R-image-14a097c4dc77900af87b61fbd29da7ff" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-14a097c4dc77900af87b61fbd29da7ff"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="new和delete的补充">new和delete的补充</h2>
<p>对new和delete的重载，用于设计内存管理，如内存池等操作。</p>
<h3 id="重载newdelete">重载::new,::delete</h3>
<p>重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图；
<a href="#R-image-d3bfab8b7cdd5fcabd11c7437a8e215a" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d3bfab8b7cdd5fcabd11c7437a8e215a"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。</p>
<h3 id="类中重载的new和delete">类中重载的new和delete</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();
</span></span><span style="display:flex;"><span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="类中重载的new和delete-1">类中重载的new[]和delete[]</h3>
<p>代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t<span style="color:#f92672">*</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>);<span style="color:#75715e">//指针占4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();<span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F[N];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="newdelete使用示例">new,delete使用示例</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _id;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> _data;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string _str;<span style="color:#75715e">//40个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Foo() <span style="color:#f92672">:</span>_id(<span style="color:#ae81ff">0</span>)       { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    Foo(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span>_id(i)  { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Foo()              { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;dtor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>运行结果如下：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>new size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span>_____________________________________________
</span></span><span style="display:flex;"><span>new[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span></span></span></code></pre></div><h3 id="为什么new操作会多出8个字节呢">为什么new[]操作会多出8个字节呢？</h3>
<p>我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。</p>
<p><a href="#R-image-120150889d650cbe0e8965f03375d535" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-120150889d650cbe0e8965f03375d535"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="对new的分配额外内存">对new的分配额外内存</h2>
<p>假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码：
<a href="#R-image-ba803ff986524ae98a838e3dfc44dc26" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba803ff986524ae98a838e3dfc44dc26"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h2 id="小结-1">小结</h2>
<p>对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码</p>
<div class="tab-panel" data-tab-group="4c586e35aa2efdd3bdb3cf65d0197cc9">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('4c586e35aa2efdd3bdb3cf65d0197cc9','class-stringfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> class String</span>
    </button>
    <button
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('4c586e35aa2efdd3bdb3cf65d0197cc9','destructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Destructor</span>
    </button>
    <button
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('4c586e35aa2efdd3bdb3cf65d0197cc9','constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Constructor</span>
    </button>
    <button
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;"
      onclick="switchTab('4c586e35aa2efdd3bdb3cf65d0197cc9','copy-constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Constructor</span>
    </button>
    <button
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('4c586e35aa2efdd3bdb3cf65d0197cc9','copy-assignment-operatorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Assignment Operator</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> m_data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);           <span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);              <span style="color:#75715e">//拷贝构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);  <span style="color:#75715e">//拷贝赋值函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">~</span>String();                              <span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">get_c_str</span>() <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> m_data;}
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    String<span style="color:#f92672">::~</span>String()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cstr)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data,<span style="color:#e6db74">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> cstr){
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">&amp;</span> String<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>str)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(str.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
  </div>
</div>
<h2 id="补充内容static">补充内容static</h2>
<p><a href="#R-image-959f0ef9837568ab088260765f136618" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-959f0ef9837568ab088260765f136618"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="static在private中的使用例子">static在private中的使用例子</h3>
<p><a href="#R-image-ca63d516d2e4b667daebbb2664219685" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ca63d516d2e4b667daebbb2664219685"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png" alt="alt text" class="lightbox-image        " loading="lazy"></a>
<a href="#R-image-23bc04e88970fb68ee4a0e07f73e3bcd" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-23bc04e88970fb68ee4a0e07f73e3bcd"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="class-template">class template</h3>
<p><a href="#R-image-ba372f8a2d244e413bda2ae0725bd351" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba372f8a2d244e413bda2ae0725bd351"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<h3 id="function-template">function template</h3>
<h3 id="member-template-成员模板">member template 成员模板</h3>
<p>类模板中，还有类模板，通常是对构造函数的操作，如下图：
<a href="#R-image-8844a79ba947bde42528bc793303652a" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8844a79ba947bde42528bc793303652a"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>如下图代码
<a href="#R-image-f03a10680eb0fd159390292a2165d6b0" class="lightbox-link"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png" alt="alt text" class="figure-image        " style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f03a10680eb0fd159390292a2165d6b0"><img src="../../branch-bundle-1/18.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png" alt="alt text" class="lightbox-image        " loading="lazy"></a></p>
<p>用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。</p>
<h3 id="namespace命令空间">namespace（命令空间）</h3>
<p>使用示例：</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>使用方法：</p>
<div class="tab-panel" data-tab-group="6b07c99d13bef3af6e5e4973ad9ffe2d">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('6b07c99d13bef3af6e5e4973ad9ffe2d','using-directionfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using direction</span>
    </button>
    <button
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('6b07c99d13bef3af6e5e4973ad9ffe2d','using-declarationfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using declaration</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
    <div
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>或者</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div></div>
    </div>
  </div>
</div>

<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>
            <footer class="footline">
<div class=" taxonomy-categories term-list cstyle  " title="Categories" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="../../categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
            </footer>
          </article>

          </section>
        </div>
      </main>
    </div>
    <script src="../../js/clipboard.min.js?1732203432" defer></script>
    <script src="../../js/perfect-scrollbar.min.js?1732203432" defer></script>
    <script src="../../js/theme.js?1732203432" defer></script>
  </body>
</html>
